---
title: "XCulture_paper_analyses"
author: "Rose M. Schneider"
date: "3/27/2019"
output: html_document
---

#Setup
```{r, include = FALSE}
rm(list = ls())
require("knitr")
opts_knit$set(root.dir = "~/Documents/Projects/xculture/HK_SLO/") #this is specific to RMS, change accordingly
library(tidyverse)
library(magrittr)
library(langcog)
library(lme4)
library(stringr)
library(RColorBrewer)
library(ggthemes)
library(memisc)
'%!in%' <- function(x,y)!('%in%'(x,y))
```

#Load data
Data is stored in separate CSVs; cleaned separately, and then binded. Done in a separate file to keep analysis script a little shorter. Warnings are suppressed because SIDs are coerced from factor to character.
```{r, warning = FALSE}
source_rmd <- function(file, local = FALSE, ...){
  options(knitr.duplicate.label = 'allow')

  tempR <- tempfile(tmpdir = ".", fileext = ".R")
  on.exit(unlink(tempR))
  knitr::purl(file, output=tempR, quiet = TRUE)

  envir <- globalenv()
  source(tempR, local = envir, ...)
}

source_rmd("~/Documents/Projects/xculture/HK_SLO/Analysis/xculture_data_cleaning.Rmd")
#this results in a cleaned .csv, re-compiled every time from original data
```

Now load the data as all.data and hc.df
```{r}
all.data <- read.csv("~/Documents/Projects/xculture/HK_SLO/Data/cleaned_data.csv")
hc.df <- read.csv("~/Documents/Projects/xculture/HK_SLO/Data/cleaned_hc_data.csv")
```

---

#Classifications
##CP or subset-knower
Children are classified as subset-knowers if they got all 4 numbers requested correct (on either the first or the second try).
```{r}
cp.df <- all.data %>%
  filter(Task == "GiveN")%>%
  group_by(SID)%>%
  summarise(sum_correct = sum(Correct, na.rm = TRUE))%>%
  mutate(Knower.level = ifelse(sum_correct >= 4, "CP-knower", "Subset-knower"))%>%
  dplyr::select(-sum_correct)

all.data <- full_join(all.data, cp.df, by = "SID")

#manual update, one participant only made it through one trial of 
```

##WPPSI score
WPPSI score is just the total correct items by participant, excluding feedback/training trials
```{r}
 #get sum per SID, add to sf and wcn for CROSS-LINGUISTIC models
 wppsi.sid <- all.data %>%
  filter(Task == "WPPSI")%>%
  filter(Exclude_trial != 1)%>%
  mutate(Trial_number = factor(Trial_number))%>%
  filter(Trial_number != "sample item A", #remove training trials
         Trial_number != "sample item B", 
         Trial_number != "Sample item A", 
         Trial_number != '1', 
         Trial_number != '2', 
         Trial_number != '7', 
        Trial_number != '8')%>%
   group_by(SID)%>%
   summarise(sum_wppsi = sum(Correct, na.rm = TRUE))

all.data <- full_join(all.data, wppsi.sid, by = "SID")
```


##Productivity
Children are classified as productive if they are able to count at least 2 decades higher than an error without making more than 3 errors along the way, OR if they are able to count to 140 without making an error.
```{r}
hc.df %<>%
  mutate(Last_successful = ifelse(Last_successful == "Is quiet", "IDK", Last_successful))%>%
  filter(Exclude != 1)%>%
  filter(SID != "CH-VC-1", 
         SID != "SR-8-MP", 
         SID != "CH-MV-14", 
         SID != 'GV-21-SB', 
         SID != 'RT09', 
         SID != 'SK-M-4-GJ')#excluding these kids because they break my productivity code

hc <- hc.df %>% 
  dplyr::select(SID, Last_successful, IHC, FHC, Language) %>%
  mutate_at(c('Last_successful','IHC','FHC'),
            function(col) as.integer(str_replace_all(col,'\\D',''))) %>% # some of these included '?', so i remove any char thats not a digit
  mutate(Last_successful = ifelse(is.na(Last_successful), 140, Last_successful))%>%
  mutate(SID = as.character(SID))

# 
# function for determining productivity
is.productive = function(subject){
  # takes as input the data for a single subject
  # RULES:
  # - counts to 120 unaided = productive
  # - after making first error, counts >= 20 higher, with no more than 3 errors on way
  if(subject$IHC[1] >= 140){
    # if they get to 140 on first try, = productive
    return("Productive")
  } else if(subject$FHC[1] == 140 & nrow(subject) < 4) {
    return("Productive")
  } else if(subject$FHC[1] < 140 & nrow(subject) == 1 
            & subject$FHC[1] == subject$IHC[1]) {
    return("Nonproductive")
  } else if((subject$FHC[1] - subject$IHC[1]) >= 20){
    # if their final is >= 20 larger than their intial...
    if(nrow(subject) < 4){
      # and they've made 3 or fewer total errors, = productive
      return("Productive")
    } 
    else {
      for(i in 1:nrow(subject)){ # start at row 2
        # check if they ever made it >= 20 counts & <= 3 errors after an error
        runLength = 0 # they just made an error, so no post-error successes yet
        numErrors = 0 # first row was an error if it's not finalCount == 120
        prev = subject$Last_successful[i]
        for (j in i+1:nrow(subject)){ # from current row until end...
          numErrors = numErrors + 1 # new row means new error
          runLength = runLength + (subject$Last_successful[j] - prev)
          # ^ add difference between current count and last count to run length
          prev = subject$Last_successful[j] # update last count
          if(runLength >= 20 & numErrors < 4){
            # if at any point the productivity conditions are met...
            return("Productive") # = productive
          }
        }
      }
      # productivity conditions were never met (because we got to this point) so...
      return("Nonproductive") # != productive
    }
  } else {
    # highest is not >= 20 greater than initial
    return("Nonproductive")
  }
}
# 
#make function to run for all participants
unique_SIDs <- as.vector(unique(hc.df$SID))
# 
class_prod <- function(vector) {
  temp_data <- data.frame()
  for (i in vector) {
    prod.class <- data.frame(i, is.productive(subset(hc, SID == i)))
    # print(i) # for debugging
    names(prod.class) <- c("SID", "productive")
    prod.class %<>%
      mutate(SID = as.character(SID), 
             productive = as.character(productive))
    
    temp_data <- bind_rows(temp_data, prod.class)
  }
  temp_data %<>%
    mutate(productive = as.character(productive))
  return(temp_data)
}
# 

productive <- class_prod(unique_SIDs)

#manually add child who broke productivity code: CH-VC-1, IHC 20, FHC 56, nonproductive, 
#SR-8-MP, IHC = 19, FHC = 39, Nonproductive
#CH-MV-14, IHC = 48, FHC = 68, Nonproductive
#GV-21-SB, IHC = 20, FHC = 40, nonproductive
#RT09, IHC = 20, FHC = 43, Nonproductive
#SK-M-4-GJ, IHC = 20, FHC = 44, Nonproductive

hc %<>%
  dplyr::select(-Last_successful)

productive <- full_join(productive, hc, by = "SID")%>%
  distinct(SID, IHC, FHC, productive)%>%
  dplyr::rename(Productive = productive)

#manually add back in kids who break the code
productive <- rbind(productive, c('CH-VC-1', 'Nonproductive', 20, 56))
productive <- rbind(productive, c('SR-8-MP', 'Nonproductive', 19, 39))
productive <- rbind(productive, c('CH-MV-14', 'Nonproductive', 48, 68))
productive <- rbind(productive, c("GV-21-SB", 'Nonproductive', 20, 40))
productive <- rbind(productive, c('RT09', 'Nonproductive', 20, 43))
productive <- rbind(productive, c('SK-M-4-GJ', 'Nonproductive', 20, 44))

all.data <- full_join(all.data, productive, by = "SID")%>%
  dplyr::mutate(IHC = as.integer(IHC), 
         FHC = as.integer(FHC))%>%
  filter(!is.na(Productive))

###UPDATED - rename "Productive" as "Resilient"
all.data %<>%
  mutate(Productive = ifelse(Productive == "Productive", "Resilient", "Non-Resilient"))

 
# # for sanity checks - trying to make sure we're not leaving people out
# unique.sid <- all.data %>%
#   distinct(SID)
# 
# unique.hc <- hc.df %>%
#   distinct(SID)
# 
# tmp <- unique.sid %>%
#   filter(SID %!in% unique.hc$SID)
# 
# l <- unique.sid %>%
#   filter(SID %!in% tmp$SID)
# 
# 
# tmp <- unique.hc %>%
#   filter(SID %in% unique.sid$SID)
```

###Sanity check for Productivity
Does anyone have a FHC higher than 130 and is Nonproductive?
```{r}
hc.check <- all.data %>%
  distinct(SID, Language, Productive, IHC, FHC)%>%
  filter(FHC > 130, 
         Productive == "Non-Resilient")

if(length(hc.check$SID) != 0) {
  print("WARNING: CHECK PRODUCTIVITY")
}
```

##Highest Contiguous NN
Highest Contiguous NN is a measure of productivity. This is the highest number for which a child was correct on the Next Number task, provided that all the previous numbers had also been correct.
```{r}
#get unique ids
unique.nn <- all.data %>%
  filter(Task == "NN")%>%
  droplevels() %>%
  distinct(SID)

unique.nn <- as.vector(unique.nn$SID)
nextnums <- as.vector(c(5, 7, 16, 24, 52, 71, 105, 107, 116, 224, 252, 271))

#this is a function that pulls out the largest number for which a participant had a correct consecutive
get_contiguous <- function(){
  contig <- data.frame()
  for (sub in unique.nn) {
    tmp <- all.data %>%
      filter(Task == "NN", 
             SID == sub, 
             Correct == 0)%>%
      mutate(Task_item = as.integer(as.character(Task_item)))%>%
      mutate(Task_item = sort(as.integer(as.character(Task_item))))
    if (length(tmp$SID) == 0) {
      highest_contig = 271
      sub_contig <- data.frame(sub, highest_contig)
       sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else if (sub %in% failed.nn.sids) {
      highest_contig = 0
      sub_contig <- data.frame(sub, highest_contig)
      sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else if (length(tmp$Task_item) > 0 & min(as.integer(as.character(tmp$Task_item))) == 5) {
      highest_contig = 1
      sub_contig <- data.frame(sub, highest_contig)
       sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else {
      min.nn <- min(as.integer(as.character(tmp$Task_item)))
      prev_correct <- nextnums[nextnums < min.nn]
      highest_contig <- as.character(max(prev_correct))
    
      sub_contig <- data.frame(sub,
                             highest_contig)
      sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    }
  }
  contig %<>%
    mutate(highest_contig = as.character(highest_contig))
  return(contig)
}

highest_contiguous_nn <- get_contiguous()%>%
  dplyr::rename(SID = sub)

#add this to df 
all.data <- full_join(all.data, highest_contiguous_nn, by = "SID")

all.data %<>%
  mutate(highest_contig = as.integer(highest_contig))

# #how many kids don't have a highest contiguous NN? 
# all.data %>%
#   filter(is.na(Language))
#   filter(is.na(highest_contig))%>%
#   distinct(Language, SID)%>%
#   group_by(Language)%>%
#   summarise(n = n())%>%
#   kable()

#Check - does anyone have NA for HCNN? Yes, these are kids who were excluded from NN
all.data %>%
  filter(is.na(highest_contig))
```

##Within/outside count range
Each trial on the Unit or WCN task was determined to be either within or outside a child's unprompted count range (IHC).
```{r}
all.data %<>%
  mutate(count_range = ifelse((Task == "SF" | Task == "NN") & as.numeric(as.character(Task_item)) <= IHC, "Within", "Outside"))
```

##Productivity gradient
For exploratory analyses
```{r}
all.data %<>%
  mutate(delta.hc = FHC-IHC, 
         prod.gradient = delta.hc/(140-IHC), 
         prod.gradient = ifelse(IHC == 140, 1, as.numeric(prod.gradient)))
```

---

##Memory checks - NAs to 1
Some participants have NAs rather than 1 for their first memory check. Also, if first mem check is a 0, and second is NA, change that second one to 1.
```{r}
all.data %<>%
  mutate(Task = factor(Task))%>%
  mutate(Mem_check_1 = ifelse(Task == "SF" & is.na(Mem_check_1), 1, Mem_check_1))%>%
  mutate(Mem_check_2 = ifelse(Task == "SF" & is.na(Mem_check_2) & Mem_check_1 == 0, 1, Mem_check_2))
```

---

#Demographics
```{r, warning = FALSE}
all.data %<>%
  filter(!is.na(Language))

#demos by age group, Language
all.data %>%
  distinct(SID, Language, Agegroup, Age)%>%
  group_by(Language, Agegroup)%>%
  summarise(n = n(), 
            Mean_age = round(mean(Age, na.rm = TRUE), 2), 
            SD_age = round(sd(Age, na.rm = TRUE), 2))%>%
  group_by(Language)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  kable()

#demos by Language
all.data %>%
  distinct(SID, Language, Age)%>%
  group_by(Language)%>%
  summarise(n = n(),
            Mean_age = round(mean(Age, na.rm = TRUE), 2), 
            SD_age = round(sd(Age, na.rm = TRUE), 2), 
            med_age = round(median(Age, na.rm = TRUE), 2))%>%
  kable()

#sex
all.data %>%
  distinct(SID, Age, Language, Sex)%>%
  group_by(Language, Sex)%>%
  summarise(n = n(), 
            mean_age = round(mean(Age),2), 
            sd_age = round(sd(Age),2))%>%
  group_by(Language)%>%
  mutate(total.n = sum(n))%>%
  kable()

#KL by language
all.data %>%
  distinct(SID, Language, Age, Productive, Knower.level)%>%
  group_by(Language, Knower.level)%>%
  summarise(n = n())%>%
  kable()
  
#histogram of age
all.data %>%
  distinct(SID, Language, Age)%>%
ggplot(aes(x = Age, fill = Language)) +
  geom_histogram(binwidth = .5, colour = "black") +
  theme_bw() + 
  facet_wrap(~Language) + 
  theme(panel.grid.minor = element_blank()) +
  scale_x_continuous(breaks = c(3.5, 4, 4.5, 5, 5.5, 6, 6.5)) +
  scale_fill_brewer(palette = "Dark2") + 
  guides(fill = FALSE) +
  labs(y = "Count", title = "Number of children in age bin by language")
```


---
#Highest Count descriptives
Productivity, prompts, errors

##What is the correlation between IHC and FHC in each language? 
```{r}
##make df
distinct_counts <- all.data %>%
  distinct(SID, Language, Productive, IHC, FHC)

#how many children were able to count at least a little beyond their IHC
tmp <- distinct_counts %>%
  mutate(delta = FHC-IHC, 
         delta.gain = ifelse(delta == 0, "no gain", "gain"))%>%
  group_by(delta.gain)%>%
  summarise(n = n())

##what do the children with 0 gain look like?
tmp <- distinct_counts %>%
  mutate(delta = FHC-IHC, 
         delta.gain = ifelse(delta == 0, "no gain", "gain"))%>%
  group_by(Language, delta.gain)%>%
  summarise(mean_IHC = mean(IHC), 
            mean_FHC = mean(FHC))

##HK
cor.test(subset(distinct_counts, Language == "Cantonese")$IHC, 
         subset(distinct_counts, Language == "Cantonese")$FHC)

cor.test(subset(distinct_counts, Language == "Slovenian")$IHC, 
         subset(distinct_counts, Language == "Slovenian")$FHC)

cor.test(subset(distinct_counts, Language == "English (US)")$IHC, 
         subset(distinct_counts, Language == "English (US)")$FHC)

cor.test(subset(distinct_counts, Language == "English (India)")$IHC, 
         subset(distinct_counts, Language == "English (India)")$FHC)

cor.test(subset(distinct_counts, Language == "Hindi")$IHC, 
         subset(distinct_counts, Language == "Hindi")$FHC)

cor.test(subset(distinct_counts, Language == "Gujarati")$IHC, 
         subset(distinct_counts, Language == "Gujarati")$FHC)

##what about by productivity
cor.test(subset(distinct_counts, Language == "Cantonese" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "Cantonese" & Productive == "Resilient")$FHC)

cor.test(subset(distinct_counts, Language == "Slovenian" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "Slovenian" & Productive == "Resilient")$FHC)

cor.test(subset(distinct_counts, Language == "English (US)" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "English (US)" & Productive == "Resilient")$FHC)

cor.test(subset(distinct_counts, Language == "English (India)" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "English (India)" & Productive == "Resilient")$FHC)

cor.test(subset(distinct_counts, Language == "Hindi" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "Hindi" & Productive == "Resilient")$FHC)

cor.test(subset(distinct_counts, Language == "Gujarati" & Productive == "Resilient")$IHC, 
         subset(distinct_counts, Language == "Gujarati" & Productive == "Resilient")$FHC)
```

##Productivity descriptives by language

###IHC, FHC by language, productivity
```{r}
productivity.pal <- c("#666666","#00b8e6")
#IHC, FHC by language, productiviity
all.data %>%
  filter(!is.na(Language))%>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  distinct(SID, Age, Productive, Language, IHC, FHC)%>%
  group_by(Language, Productive)%>%
  summarise(n = n(),
            mean_IHC = round(mean(IHC)), 
            sd_IHC = round(sd(IHC), 2), 
            median_IHC = round(median(IHC)), 
            mean_FHC = round(mean(FHC)), 
            sd_FHC = round(sd(FHC), 2), 
            median_FHC = round(median(FHC)))%>%
  kable()

```

###IHC, FHC by language
```{r}
productivity.pal <- c("#666666","#00b8e6")
#IHC, FHC by language, productiviity
all.data %>%
  filter(!is.na(Language))%>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  distinct(SID, Age, Language, IHC, FHC)%>%
  group_by(Language)%>%
  summarise(n = n(),
            mean_IHC = round(mean(IHC)), 
            sd_IHC = round(sd(IHC), 2), 
            median_IHC = round(median(IHC)), 
            mean_FHC = round(mean(FHC)), 
            sd_FHC = round(sd(FHC), 2), 
            median_FHC = round(median(FHC)))%>%
  kable()

```

###Productivity gradient
```{r}
#what about productivity gradient?
all.data %>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  distinct(SID, Age, Productive, Language, prod.gradient, delta.hc)%>%
  group_by(Language, Productive)%>%
  summarise(n =n(), 
            mean_prod.gradient = mean(prod.gradient), 
            sd_prod.gradient = sd(prod.gradient), 
            mean_delta.hc = mean(delta.hc), 
            sd_delta.hc = sd(delta.hc))%>%
  kable()
```

##Errors in HC
###Prompts by productivity and language
```{r}
#how many prompts do productive and nonproductive counters need? and what kind of errors do they make?
#bind productive and hc.df 
productive %<>% 
  dplyr::select(SID, Productive)

##rename for resilient
productive %<>%
  mutate(Productive = ifelse(Productive == "Productive", "Resilient", "Non-Resilient"))

error.freq <- full_join(hc.df, productive, by = "SID")%>%
  filter(!is.na(Last_successful))%>%
  mutate(Error_type = ifelse((Language == "Cantonese" | 
                                Language == "Slovenian" |
                                Language == "English (India)" |
                                Language == "English (US)") & Last_successful %% 10 == 9 , "Decade end", 
                             ifelse(Last_successful %% 10 == 0, "Decade beginning",
                                    ifelse(Last_successful %% 10 == 8 & (Language == "Hindi" | Language == "Gujarati"), "Hindi/Gujarati pre-decade transition", "Mid-decade"))))

#mean number of prompts by Language, productivity
mean_prompts.type <- error.freq %>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  group_by(Language, Error_type, Productive)%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

#all productive errors grouped together
mean_prompts.type.prod <- error.freq %>%
  group_by(Language, Error_type, Productive)%>%
  filter(Productive == "Resilient")%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

#all nonproductive errors grouped together
mean_prompts.type.nonprod <- error.freq %>%
  group_by(Language, Error_type, Productive)%>%
  filter(Productive == "Non-Resilient")%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

```

###Where are errors happening?
```{r}
error.freq.decade <- error.freq %>%
  filter(Last_successful != 140)%>%
  mutate(error.decade = ifelse(Last_successful < 10, 0, 
                               ifelse(Last_successful >= 10 & Last_successful < 20, 10, 
                                      ifelse(Last_successful >= 20 & Last_successful < 30, 20, 
                                             ifelse(Last_successful >= 30 & Last_successful < 40, 30, 
                                                    ifelse(Last_successful >=40 & Last_successful < 50, 40, 
                                                           ifelse(Last_successful >= 50 & Last_successful < 60, 50, 
                                                                  ifelse(Last_successful >= 60 & Last_successful < 70, 60, 
                                                                         ifelse(Last_successful >= 70 & Last_successful < 80, 70, 
                                                                                ifelse(Last_successful >= 80 & Last_successful < 90, 80, 
                                                                                       ifelse(Last_successful >= 90 & Last_successful < 100, 90, 
                                                                                              ifelse(Last_successful >= 100 & Last_successful < 110, 100, 
                                                                                                     ifelse(Last_successful >= 110 & Last_successful < 120, 110, 
                                                                                                            ifelse(Last_successful >= 120 & Last_successful < 130, 120,130)))))))))))))) %>%
  mutate(error.base = (error.decade - Last_successful) * -1, 
         error.base = ifelse(Last_successful == 140, 0, as.numeric(error.base)))


##Error by decade
##all
all.error <- error.freq.decade %>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati","English (India)", "English (US)", "Slovenian", "Cantonese")), 
         Productive = factor(Productive, levels = c("Resilient", "Non-Resilient"))) %>%
  mutate(error.decade = factor(error.decade, levels = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 
                                                        90, 100, 110, 120, 130)),
         error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.decade)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  mutate(n = ifelse(is.na(n), 0, as.numeric(n)))%>%
  ggplot(aes(x = error.decade, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 3) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 10) + 
  labs(x = "Decade of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) + 
  facet_wrap(~Productive, strip.position = 'right', nrow = 2)

###Error by unit
##all
error.freq.decade %>%
  filter(Last_successful <= 140)%>% #filter out trials where kid kept going beyond 140
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati","English (India)", "English (US)", "Slovenian", "Cantonese")), 
         Productive = factor(Productive, levels = c("Resilient", "Non-Resilient"))) %>%
  mutate(error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.base)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  mutate(n = ifelse(is.na(n), 0, as.numeric(n)))%>%
  ggplot(aes(x = error.base, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 2.5) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 13) + 
  labs(x = "Unit of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "right", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        legend.title = element_text(size = 11)) +
  facet_grid(rows = vars(Productive))
ggsave("errors.png")
```

####Sanity check - does anyone have more than 3 errors within a decade?
```{r}
check <- error.freq.decade %>%
  group_by(SID, error.decade)%>%
  summarise(n = n())%>%
  filter(n > 3)

#4 participants, but these are language switches did not receive a prompt
```

###How many participants used all 14 prompts?
```{r}
hc.df %>%
  group_by(SID, Language)%>%
  filter(Last_successful != 140)%>%
  summarise(n = n())%>%
  filter(n >= 10)%>%
  kable()

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

#HK/SLO/US
hc.df %>%
  group_by(SID, Language)%>%
  filter(Last_successful != 140, 
         Language == "Cantonese" | 
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  summarise(n = n())%>%
  group_by()%>%
  summarise(mean = mean(n), 
            median = median(n), 
            mode = getmode(n))
```

###How many errors on average by language, productivity?
```{r}
error.freq %>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  filter(Last_successful != 140)%>% #filter out kids who got to 140
  group_by(SID, Language, Productive)%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  summarise(mean_prompts = round(mean(n, na.rm = TRUE), 2),
            sd_prompts = round(sd(n, na.rm = TRUE), 2))%>%
  kable()
```
###Errors by language
```{r}
error.freq %>%
  filter(Last_successful != 140)%>% #filter out kids who got to 140
  group_by(SID, Language)%>%
  summarise(n = n())%>%
  group_by(Language)%>%
  summarise(mean_prompts = round(mean(n, na.rm = TRUE), 2),
            sd_prompts = round(sd(n, na.rm = TRUE), 2))%>%
  kable()
```

###Analysis: What proportion of kids in highest proportion cluster (from GMM) are labeled as resilient in each language?
First, set up GMM
```{r}
library(mclust)

#make a function to identify cluster membership
prod.clust <- function(df) {
  languages <- c("English (US)", "English (India)", "Hindi", "Gujarati", "Slovenian", "Cantonese")
  
  all.clust <- data.frame()
  for (lang in languages) {
    #filter down to correct language
    tmp.df <- df %>%
      filter(Language == lang)%>%
      distinct(SID, IHC)%>%
      dplyr::select(-SID)
    
    #run cluster analysis
    BIC <- mclustBIC(tmp.df)
    tmp.mclust <- Mclust(tmp.df, x = BIC)
    tmp.df$CLUST <- tmp.mclust$classification
    tmp.df$id <- row.names(tmp.df)
    
    #add SIDs back in
    tmp.sids <- df %>%
      filter(Language == lang)%>%
      distinct(SID, IHC)
    
    tmp.sids$id <- row.names(tmp.sids)
    
    tmp.all <- right_join(tmp.sids, tmp.df, by = "id")
    tmp.all$Language <- lang
    
    #add to large df to get back at end
    all.clust <- bind_rows(all.clust, tmp.all)
  }
  return(all.clust)
}

clusters <- prod.clust(all.data)%>%
  dplyr::select(SID, IHC.x, CLUST, Language)%>%
  dplyr::rename(IHC = IHC.x)

#add clusters to all.data
all.data <- full_join(all.data, clusters, by = "SID")

check <- all.data %>%
  filter(IHC.x != IHC.y) # all good

all.data %<>%
  dplyr::select(-IHC.y, -Language.y)%>%
  dplyr::rename(IHC = IHC.x,
                Language = Language.x)

```

####What percentage of each mode turned out to be productive?
```{r}
##Pull out only these clusters 
all.data %>%
  distinct(SID, Language, Productive, CLUST)%>%
  group_by(Language, CLUST, Productive)%>%
  summarise(n = n())%>%
  group_by(Language, CLUST)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  kable()
```

###Analysis: Do IHCs differ by language? - Gaussian Mixture Modeling
###Set up df for these
```{r}
initial_final <- all.data %>%
  filter(!is.na(Productive))%>%
  distinct(SID, Language, IHC, FHC, Productive, Dataset, prod.gradient, delta.hc)%>%
  mutate(IHC = as.numeric(IHC), 
         FHC = as.numeric(FHC))
```

###Cantonese
```{r}
#Cantonese
cant.df <- initial_final %>%
  filter(Language == "Cantonese")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(cant.df)

mod.cant <- Mclust(cant.df, x = BIC)
summary(mod.cant, parameters = TRUE)

```

###Slovenian
```{r}
#Slovenian
slo.df <- initial_final %>%
  filter(Language == "Slovenian")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(slo.df)

mod.slo <- Mclust(slo.df, x = BIC)
summary(mod.slo, parameters = TRUE)

```

###US English
```{r}
#English
us.df <- initial_final %>%
  filter(Language == "English (US)")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(us.df)

mod.us <- Mclust(us.df, x = BIC)
summary(mod.us, parameters = TRUE)

```

###Hindi
```{r}
#Hindi
hindi.df <- initial_final %>%
  filter(Language == "Hindi")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(hindi.df)

mod.hindi <- Mclust(hindi.df, x = BIC)
summary(mod.hindi, parameters = TRUE)

```

###Gujarati
```{r}
#Gujarati
gujarati.df <- initial_final %>%
  filter(Language == "Gujarati")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(gujarati.df)

mod.gujarati <- Mclust(gujarati.df, x = BIC)
summary(mod.gujarati, parameters = TRUE)

```

###Indian English
```{r}
#Indian English
ind.eng.df <- initial_final %>%
  filter(Language == "English (India)")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(ind.eng.df)

mod.ind.eng <- Mclust(ind.eng.df, x = BIC)
summary(mod.ind.eng, parameters = TRUE)

```



---
#Highest Contiguous Next Number
##HCNN by each language
```{r}
india.pal <- c("#E7298A","#66A61E","#E6AB02", "#7570B3")

#how many children have 0s
all.data %>%
  distinct(SID, highest_contig, Language)%>%
  filter(highest_contig == 0)%>%
  group_by(Language)%>%
  summarise(n = n())%>%
  mutate(total = sum(n))

#how many children have 271s
all.data %>%
  distinct(SID, highest_contig, Language)%>%
  filter(highest_contig == 271)%>%
  group_by(Language)%>%
  summarise(n = n())%>%
  mutate(total = sum(n))

#all together
all.data %>%
  distinct(SID, highest_contig, Language)%>%
  group_by(Language)%>%
  summarise(mean_hcnn = mean(highest_contig, na.rm = TRUE),
            sd_hcnn = sd(highest_contig, na.rm = TRUE), 
            median_hcnn = median(highest_contig, na.rm = TRUE))%>%
  kable()

#by productivity
all.data %>%
  filter(!is.na(highest_contig))%>%
  mutate(Productive = factor(Productive, levels = c("Resilient", "Non-Resilient")))%>%
  distinct(SID, highest_contig, Language, Productive)%>% 
  group_by(Language, Productive)%>%
  summarise(mean_hcnn = mean(highest_contig, na.rm = TRUE),
            sd_hcnn = sd(highest_contig, na.rm = TRUE), 
            median_hcnn = median(highest_contig, na.rm = TRUE))%>%
  kable()
```

###Analysis: Do transparent languages allow nonproductive counters to generate higher HCNNs?
No significant difference in HCNN for nonproductive counters for Cantonese in comparison to English or Slovenian. US English nonproductive counters have significantly higher HCNNs than Hindi or Gujarati. This difference holds for Indian English speakers.
```{r}
#lm predicting hcnn from language for nonproductive counters
#HK/SLO/US
hcnn.hk <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Cantonese" |
           Language == "Slovenian")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Non-Resilient")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.hk <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.hk)
summary(hcnn.nonprod.hk)

#india - US English
hcnn.ind <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Non-Resilient")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.india.us <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.ind)
summary(hcnn.nonprod.india.us)

#india - Indian English
hcnn.ind <- all.data %>%
  filter(Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Non-Resilient")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.india <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.ind)
summary(hcnn.nonprod.india)
```

---

#Task Visualizations 
##Scatterplot of IHC and FHC - now with density distributions
```{r}
library(ggstance)
library(ggjoy)
library(cowplot)
####Cantonese####
hk_initial <- initial_final %>%
  filter(Language == "Cantonese")

pmain.hk <- ggplot(hk_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha = .9, position = position_jitter()) + 
  # geom_jitter() + 
  scale_color_brewer(palette = "Paired") + 
  coord_fixed() + 
  theme_bw(base_size = 10) +
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"), 
        axis.title = element_text(size = 8),
        legend.position = c(.75, 0.2), 
        legend.text = element_text(size = 6), 
        legend.title = element_blank(), 
        axis.text = element_text(size = 7)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Cantonese")

xdens.hk <- axis_canvas(pmain.hk, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = hk_initial, aes(x = IHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.hk <- axis_canvas(pmain.hk, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = hk_initial, aes(x = FHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.hk, xdens.hk, grid::unit(.2, "null"), position = "top")
hk_dens <- insert_yaxis_grob(p5, ydens.hk, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "hk_density.png")
# ggdraw(p6)
# dev.off()
```

```{r}
#####SLO####
slo_initial <- initial_final %>%
  filter(Language == "Slovenian")

pmain.slo <- ggplot(slo_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha = .9, position = position_jitter()) + 
  geom_jitter() + 
  scale_color_brewer(palette = "Paired", guide = "none") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme_bw(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"), 
        legend.position = "none",
        axis.title = element_text(size = 8),
        legend.text = element_text(size = 5), 
        legend.title = element_text(size = 6), 
         axis.text = element_text(size = 7)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Slovenian")

xdens.slo <- axis_canvas(pmain.slo, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = slo_initial, aes(x = IHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.slo <- axis_canvas(pmain.slo, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = slo_initial, aes(x = FHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.slo, xdens.slo, grid::unit(.2, "null"), position = "top")
slo_dens <- insert_yaxis_grob(p5, ydens.slo, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "slo_density.png")
# ggdraw(p6)
# dev.off()
```

```{r}
#####US####
us_initial <- initial_final %>%
  filter(Language == "English (US)")

pmain.us <- ggplot(us_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha = .9, position = position_jitter()) + 
  geom_jitter() + 
  scale_color_brewer(palette = "Paired") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme_bw(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"),
        axis.title = element_text(size = 8),
        legend.position = "none", 
        legend.text = element_text(size = 5), 
        legend.title = element_text(size = 6), 
         axis.text = element_text(size = 7)) +
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "English (US)")

xdens.us <- axis_canvas(pmain.us, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = us_initial, aes(x = IHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.us <- axis_canvas(pmain.us, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = us_initial, aes(x = FHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.us, xdens.us, grid::unit(.2, "null"), position = "top")
us_dens <- insert_yaxis_grob(p5, ydens.us, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "us_density.png")
# ggdraw(p6)
# dev.off()
```

```{r}
#####HINDI####
hindi_initial <- initial_final %>%
  filter(Language == "Hindi")

pmain.hindi <- ggplot(hindi_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha = .9, position = position_jitter()) + 
  geom_jitter() + 
  theme(legend.position = c(.5, 0.2), 
        legend.title = element_blank()) + 
  scale_color_brewer(palette = "Paired", guide = "none") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) + 
  scale_y_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) +
  theme_bw(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"), 
        legend.position = "none", 
        axis.title = element_text(size = 8),
        legend.text = element_text(size = 5), 
        legend.title = element_text(size = 6), 
         axis.text = element_text(size = 7)) +
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Hindi")

xdens.hindi <- axis_canvas(pmain.hindi, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = hindi_initial, aes(x = IHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.hindi <- axis_canvas(pmain.hindi, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = hindi_initial, aes(x = FHC, y = ..density.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.hindi, xdens.hindi, grid::unit(.2, "null"), position = "top")
hind_dens <- insert_yaxis_grob(p5, ydens.hindi, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "hindi_density.png")
# ggdraw(p6)
# dev.off()
```

```{r}
#####Gujarati####
gujarati_initial <- initial_final %>%
  filter(Language == "Gujarati")

pmain.gujarati <- ggplot(gujarati_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha = .9, position = position_jitter()) + 
  geom_jitter() + 
  scale_color_brewer(palette = "Paired", guide = "none") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) + 
  scale_y_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) +
  theme_bw(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"),
        axis.title = element_text(size = 8),
        legend.position = "none", 
        legend.text = element_text(size = 5), 
        legend.title = element_text(size = 6), 
         axis.text = element_text(size = 7)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Gujarati")

xdens.gujarati <- axis_canvas(pmain.gujarati, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = gujarati_initial, aes(x = IHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.gujarati <- axis_canvas(pmain.gujarati, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = gujarati_initial, aes(x = FHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.gujarati, xdens.gujarati, grid::unit(.2, "null"), position = "top")
gujarati_dens <- insert_yaxis_grob(p5, ydens.gujarati, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "gujarati_density.png")
# ggdraw(p6)
# dev.off()
```

```{r}
ind.eng_initial <- initial_final %>%
  filter(Language == "English (India)")

pmain.ind.eng <- ggplot(ind.eng_initial, aes(x = IHC, y = FHC, color = Productive, shape = Productive)) + 
  geom_point(size = 1.3, alpha= .9, position = position_jitter()) + 
  geom_jitter() + 
  scale_color_brewer(palette = "Paired", guide = "none") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) + 
  scale_y_continuous(breaks = seq(0, 140, 10), limits = c(0, 140)) +
   theme_bw(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5, size = 9, face = "bold"),
        axis.title = element_text(size = 8),
        legend.position = "none", 
        legend.text = element_text(size = 5), 
        legend.title = element_text(size = 6), 
         axis.text = element_text(size = 7)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "English (India)")

xdens.ind.eng <- axis_canvas(pmain.ind.eng, axis = "x") + 
  # geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
  #                                       fill = Productive), 
  #                stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = ind.eng_initial, aes(x = IHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) + 
  scale_fill_brewer(palette = "Paired") 

ydens.ind.eng <- axis_canvas(pmain.ind.eng, axis = "y", coord_flip = TRUE) + 
  # geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
  #                                       fill = Productive), 
  #                stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  geom_density(data = ind.eng_initial, aes(x = FHC, y = ..count.., fill = Productive), 
               alpha=.7, adjust = .5) +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") 

p5 <- insert_xaxis_grob(pmain.ind.eng, xdens.ind.eng, grid::unit(.2, "null"), position = "top")
ind_dens <- insert_yaxis_grob(p5, ydens.ind.eng, grid::unit(.2, "null"), position = "right")
# ggdraw(p6)
# png(filename = "indeng_density.png")
# ggdraw(p6)
# dev.off()
```

##Get all of these scatterplots together in a single plot
```{r}
cowplot::plot_grid(ggdraw(hk_dens), ggdraw(slo_dens), 
                   ggdraw(us_dens), ggdraw(ind_dens), 
                   ggdraw(hind_dens), ggdraw(gujarati_dens), ncol = 2)
```

---

##Unit Task
##Descriptive statistics  
```{r}
all.data %>%
  filter(Task == "SF")%>%
  group_by(SID, Language)%>%
  summarise(mean_sub = mean(Correct, na.rm = TRUE))%>%
  group_by(Language)%>%
  summarise(n = n(),
            mean = mean(mean_sub, na.rm = TRUE), 
            sd = sd(mean_sub, na.rm = TRUE), 
            se = sd/sqrt(n))%>%
  kable()
```

##Test of mean performance 
First HK/SLO/US
```{r}
#hk and slo 
sf.ms <- all.data %>%
  filter(Task == "SF")%>%
  group_by(SID, Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

#hk vs. slo
t.test(subset(sf.ms, Language == "Cantonese")$mean, 
       subset(sf.ms, Language == "Slovenian")$mean, var.equal = TRUE) #sig. higher performance in Cantonese

#hk vs. us
t.test(subset(sf.ms, Language == "Cantonese")$mean, 
       subset(sf.ms, Language == "English (US)")$mean, var.equal = TRUE) #ns, no difference

#us vs. slo
t.test(subset(sf.ms, Language == "Slovenian")$mean, 
       subset(sf.ms, Language == "English (US)")$mean, var.equal = TRUE) #ns, no difference

```

##Unit Task Models
###Make model analysis dfs
Note that there is a lot more variability in highest counts and highest contiguous NN than in categorical variables. I am centering age, and centering and scaling FHC, IHC, and highest contiguous NN (which has the most variability).
```{r, include = FALSE}
##HK##
###UNIT###
sf.hk.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language== "Cantonese")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))
###NN###  
wcn.hk.within <- all.data%>%
  filter(Task == "NN")%>%
  filter(Language == "Cantonese")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)),
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))

##SLO##
###UNIT###
sf.slo.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language == "Slovenian")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

###NN###
wcn.slo.within <- all.data%>%
  filter(Language == "Slovenian")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

##US##
###UNIT###
sf.us.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

###NN###
wcn.us.within <- all.data%>%
  filter(Language == "English (US)")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

##English - India##
###UNIT###
sf.ind.eng.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (India)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

###NN###
wcn.ind.eng.within <- all.data %>%
  filter(Language == "English (India)")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

##Hindi##
####UNIT###
sf.hindi.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Hindi")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

###NN###
wcn.hindi.within <- all.data %>%
  filter(Language == "Hindi")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))


##Gujarati##
###UNIT###
sf.gujarati.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

###NN###
wcn.gujarati.within <- all.data %>%
  filter(Language == "Gujarati")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))
```

#Hong Kong: Within-language models, Unit Task
Build the models

##Build the models
```{r}
#base
sf.hk.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#Productivity
sf.hk.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#FHC
sf.hk.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#IHC
sf.hk.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)
#Highest contig.
sf.hk.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)

##Exploratory - productivity gradient
sf.hk.within.model.pg <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                               family = "binomial", data = sf.hk.within)
```

##Hong Kong: Unit task models
```{r}
library(sjPlot)
mtable.sf.hk <- mtable('Base Model' = sf.hk.within.base,
            'Model 1: Productivity' = sf.hk.within.model1,
            'Model 2: FHC' = sf.hk.within.model2,
            'Model 3: IHC' = sf.hk.within.model3,
            'Model 4: Highest Contig.' = sf.hk.within.model4,
            'EXP: Prod. Gradient' = sf.hk.within.model.pg,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hk

tab_model(sf.hk.within.base, transform = NULL)
tab_model(sf.hk.within.model1, transform= NULL)
tab_model(sf.hk.within.model2, transform = NULL)
tab_model(sf.hk.within.model3, transform = NULL)
tab_model(sf.hk.within.model4, transform = NULL)
```


##Model comparisons
###Base v. productivity - NS, Chisq(1) = 0.05. p = .82
```{r}
anova(sf.hk.within.base, sf.hk.within.model1, test = 'LRT') #ns
```

###Base v. FHC - Sig, Chisq(1) = 11.65, p = 0.0006, AIC = 1616.5
```{r}
anova(sf.hk.within.base, sf.hk.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 38.91, p < .0001, AIC = 1589.3
```{r}
anova(sf.hk.within.base, sf.hk.within.model3, test = 'LRT')
```

###Base v. Highest Contiguous NN - Sig, Chisq(1) = 11.8251, p = .0002, AIC = 1616.3
```{r}
anova(sf.hk.within.base, sf.hk.within.model4, test = 'LRT')
```

#Exploratory - productivity gain - Marginal
```{r}
anova(sf.hk.within.base, sf.hk.within.model.pg, test = 'LRT')
```

###Ranking of predictors from individual models 
1.  IHC - AIC = 1589.3
2.  HCNN - AIC = 1616.3
3.  FHC - AIC = 1616.5
4.  Productivity - 1624.3

####Exploratory
1. Productivity gradient - AIC = 1624.3

##Large model
We have three significant predictors of performance on the Unit task (FHC, IHC, and Highest Contiguous NN). Now, we need to create our 'large' Model 5 which will contain the best predictors of performance on the Unit Task.

The simple model with the lowest AIC is IHC, so we will begin with that as our base term. 
```{r}
#Base = IHC
sf.hk.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)

#IHC and Highest Contiguous
sf.hk.within.plus2.hc <- glmer(Correct ~ highest_contig.c + ihc.c+ count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hk.within)

#compare
anova(sf.hk.within.plus1, sf.hk.within.plus2.hc, test = 'LRT')# HCNN ns

#IHC and FHC
sf.hk.within.plus2.fhc <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hk.within)

#compare
anova(sf.hk.within.plus1, sf.hk.within.plus2.fhc, test = 'LRT') #fhc ns

#IHC and FHC and HCNN
sf.hk.within.plus3 <- glmer(Correct ~ highest_contig.c + fhc.c + ihc.c + count_range + starting_num.c + age.c + 
                              (1|SID), family = "binomial", data = sf.hk.within)


#comparison of 3 (minus HCNN)
anova(sf.hk.within.plus1, sf.hk.within.plus2.fhc, sf.hk.within.plus3, test = 'LRT') 
#comparison of 3 (minus FHC)
anova(sf.hk.within.plus1, sf.hk.within.plus2.hc, sf.hk.within.plus3, test = 'LRT') 

mtable.sf.hk.large <- mtable('IHC alone' = sf.hk.within.plus1,
            'Highest Contig + IHC' = sf.hk.within.plus2.hc,
            'FHC + IHC' = sf.hk.within.plus2.fhc,
            'Highest Contig. + FHC + IHC' = sf.hk.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hk.large
```
####Exploratory - productivity gradient
Productivity gradient does not significantly add to the model
```{r}
#Explore 
##What about productivity gradient?
sf.hk.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)
anova(sf.hk.within.plus1, sf.hk.within.plus.gain, test = 'LRT') # productivity gradient does not significantly explain add'l variance
```

##HK Unit Task within-language results: IHC emerges as best predictor of performance on Unit Task
```{r}
summary(sf.hk.within.plus1)

###Statistics
##Sigma^2 
library(sjstats)
library(sjPlot)
tab_model(sf.hk.within.plus1, transform = NULL)
```

***

#SLO: Within-language models, Unit Task

##Build the models
```{r}
#base
sf.slo.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID) , family = "binomial", 
                           data = sf.slo.within)
#productivity
sf.slo.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.slo.within)
#FHC
sf.slo.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.slo.within)
#IHC
sf.slo.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.slo.within)
#highest contiguous NN
sf.slo.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.slo.within) 

#exploratory - productivity gradient
sf.slo.within.model.pg <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                family = "binomial", data = sf.slo.within)

```

##SLO: Unit task models
```{r}
mtable.sf.slo <- mtable('Base Model' = sf.slo.within.base,
            'Model 1: Productivity' = sf.slo.within.model1,
            'Model 2: FHC' = sf.slo.within.model2,
            'Model 3: IHC' = sf.slo.within.model3,
            'Model 4: Highest Contig.' = sf.slo.within.model4,
            'EXP: Prod. Gradient' = sf.slo.within.model.pg,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.slo

tab_model(sf.slo.within.base, transform = NULL)
tab_model(sf.slo.within.model1, transform = NULL)
tab_model(sf.slo.within.model2, transform = NULL)
tab_model(sf.slo.within.model3, transform = NULL)
tab_model(sf.slo.within.model4, transform = NULL)
```

##Model Comparisons
###Base v. Productivity - sig, Chis(1) = 19.749, p < .001, AIC = 1401.2
```{r}
anova(sf.slo.within.base, sf.slo.within.model1, test = 'LRT')
```

 
###Base v. FHC - Sig, Chisq(1) = 24.661, p < .001, AIC = 1396.3
```{r}
anova(sf.slo.within.base, sf.slo.within.model2, test = 'LRT')
```

###Base v. IHC - Chisq(1) = 13.847, p = .0002, AIC = 1407.2
```{r}
anova(sf.slo.within.base, sf.slo.within.model3, test = 'LRT')
````

###Base v. Highest Contiguous NN - Sig, Chisq(1) = 25.127, p < .0001, AIC = 1395.9
```{r}
anova(sf.slo.within.base, sf.slo.within.model4, test = 'LRT')
```

###Exploratory - Prod. gain - significant, Chisq. = 9.56, p = .002
```{r}
anova(sf.slo.within.base, sf.slo.within.model.pg, test = 'LRT')
```

##Ranking of Productivity predictors from AIC 
1.  HCNN - 1395.1
2.  FHC - 1396.3
3.  Productivity - 1401.2
4.  IHC - 1407.2


##Large model
```{r}
#Base - HCNN
sf.slo.within.plus1 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#Now add second-lowest AIC
#HCNN + FHC
sf.slo.within.plus2.fhc <- glmer(Correct ~ fhc.c + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#now compare
anova(sf.slo.within.plus1, sf.slo.within.plus2.fhc, test = 'LRT') ###FHC is significant


##Now add Productivity
#Productive + FHC + HCNN
sf.slo.within.plus3 <- glmer(Correct ~ Productive + fhc.c + highest_contig.c + count_range + starting_num.c + age.c + 
                               (1|SID), family = "binomial", data = sf.slo.within)
#Compare
anova(sf.slo.within.plus2.fhc, sf.slo.within.plus3, test = 'LRT')#NS

##FHC and HCNN best predictors, Productivity does not add anything. Now add IHC
#IHC + FHC + HCNN
sf.slo.within.plus3.ihc <- glmer(Correct ~ ihc.c + fhc.c + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#HCNN and FHC best predictors - now add IHC
anova(sf.slo.within.plus2.fhc, sf.slo.within.plus3.ihc, test = 'LRT') #NS

#what about productivity gradient
sf.slo.within.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")
anova(sf.slo.within.plus1, sf.slo.within.plus.gain, test = 'LRT')

summary(sf.slo.within.plus1)
# summary(sf.slo.within.plus.nn)
```

##Summary, SLO Unit: HCNN + FHC is best predictor
```{r}
summary(sf.slo.within.plus2.fhc)
tab_model(sf.slo.within.plus2.fhc, transform = NULL)
```

#English (US): Within-language models, Unit Task

##Build the models
```{r}
#base
sf.us.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#productivity
sf.us.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#FHC
sf.us.within.model2 <- glmer(Correct ~ fhc.c + count_range +  starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#IHC
sf.us.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c +  age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within, control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Highest contiguous
sf.us.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within) 
#Exploratory, Prod. gradient
sf.us.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c +age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within) #ns
```

##English (US): Unit task models
```{r}
mtable.sf.us <- mtable('Base Model' = sf.us.within.base,
            'Model 1: Productivity' = sf.us.within.model1,
            'Model 2: FHC' = sf.us.within.model2,
            'Model 3: IHC' = sf.us.within.model3,
            'Model 4: Highest Contig.' = sf.us.within.model4,
            'Exp. model: Prod. gradient' = sf.us.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.us
tab_model(sf.us.within.base, transform = NULL)
tab_model(sf.us.within.model1, transform = NULL)
tab_model(sf.us.within.model2, transform = NULL)
tab_model(sf.us.within.model3, transform = NULL)
tab_model(sf.us.within.model4, transform = NULL)

```

##Model comparisons
###Base v. Productivity - NS, Chisq(1) = 1.19, p = .27, AIC = 1514.6
```{r}
anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 18.85, p < .0001, AIC = 1496.9
```{r}
anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 49.48, p < .0001, AIC = 1466.3
```{r}
anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')
````

###Base v. Highest Contig. - Sig, Chisq(1) = 35.86, p < .0001, AIC = 1479.9
```{r}
anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')
```

###Post-hoc: Prod.gradient - Sig, Chisq(1) = 4.3153, p = .04, AIC = 1526.8
```{r}
anova(sf.us.within.base, sf.us.within.model.gain, test = 'LRT')
# anova(sf.us.within.base, sf.us.within.model.clust, test = 'LRT') 
# anova(sf.us.within.base, sf.us.within.model.nn, test = 'LRT')
```

##Ranking of productivity predictors by AIC 
1.  IHC - 1466.3 
2.  HCNN - 1479.9
3.  FHC - 1496.9
4.  Productivity - 1514

##Large model
Base = IHC 
```{r}
#IHC
sf.us.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#IHC + HCNN
sf.us.within.plus2.highest.contig <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c +  age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                             control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#compare 
anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, test = 'LRT') #hcnn significant

#IHC + FHC + HCNN
sf.us.within.plus3 <- glmer(Correct ~ fhc.c + highest_contig.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#compare 3, minus fhc
anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, sf.us.within.plus3, test = 'LRT') #fhc does not add  
#regression table
mtable.sf.us.large <- mtable('IHC' = sf.us.within.plus1,
            'FHC + IHC' = sf.us.within.plus2.fhc,
            'Highest Contig + IHC' = sf.us.within.plus2.highest.contig,
            # 'Prod. gradient + IHC' = sf.us.within.plus2.gain,
            'Highest Contig + FHC + IHC' = sf.us.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.us.large

#exp - prod.gradient + hcnn + ihc
sf.us.within.plus3.pg <- glmer(Correct ~ prod.gradient + highest_contig.c + ihc.c + starting_num.c + count_range + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                             control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(sf.us.within.plus2.highest.contig, sf.us.within.plus3.pg, test = 'LRT')#ns

summary(sf.us.within.plus2.highest.contig)
```

##US Unit Task within-language results: IHC and HCNN best predictor of performance on Unit Task
```{r}
summary(sf.us.within.plus2.highest.contig)
tab_model(sf.us.within.plus2.highest.contig, transform = NULL)
```

***

#Hindi: Within-language models, Unit Task
##Build the models
```{r}
#Base
sf.hindi.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#Productivity
sf.hindi.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c  + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#FHC
sf.hindi.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#IHC
sf.hindi.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#Highest contig
sf.hindi.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)

#Exploratory - prod. gradient 
sf.hindi.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c +
                                      (1|SID), family = "binomial", data = sf.hindi.within)

```

##Hindi: Unit task models
```{r}
mtable.sf.hindi <- mtable('Base Model' = sf.hindi.within.base,
            'Model 1: Productivity' = sf.hindi.within.model1,
            'Model 2: FHC' = sf.hindi.within.model2,
            'Model 3: IHC' = sf.hindi.within.model3,
            'Model 4: Highest Contig.' = sf.hindi.within.model4,
            'Exp: Prod. gradient' = sf.hindi.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hindi

tab_model(sf.hindi.within.base, transform = NULL)
tab_model(sf.hindi.within.model1, transform = NULL)
tab_model(sf.hindi.within.model2, transform = NULL)
tab_model(sf.hindi.within.model3, transform = NULL)
tab_model(sf.hindi.within.model4, transform = NULL)
```

##Model comparisons
###Base v. Productivity - marginal, p = .07
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model1, test = 'LRT')
```

###Base v. FHC - sig, Chisq(1) = 21.6, p < .0001, AIC = 1325.1
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, chisq(1) = 28.436, p < .0001, AIC = 1318.4
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model3, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 27.63, p < .0001, AIC = 1319.1
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model4, test = 'LRT')
```

###Exploratory - prod. gradient, p = .008
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model.gain, test = 'LRT')
```

###Ranking of productivity predictors by AIC
1.  IHC = 1318.4
2.  HCNN = 1319.1
3.  FHC = 1325.1
4.  Productivity = 1343


##Large model

IHC v. FHC v. Highest Contig
```{r}
#IHC
sf.hindi.within.plus1 <- glmer(Correct ~ ihc.c + count_range +  starting_num.c + age.c  + (1|SID), 
                             family = "binomial", 
                           data = sf.hindi.within)
#HCNN + IHC 
sf.hindi.within.plus2.hc <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = sf.hindi.within)

##compare
anova(sf.hindi.within.plus1, sf.hindi.within.plus2.hc, test = 'LRT') #hcnn significantly adds to the model

#HCNN + FHC + IHC
sf.hindi.within.plus3 <- glmer(Correct ~ fhc.c + highest_contig.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hindi.within)
#Comparison of 3 minus fhc
anova(sf.hindi.within.plus1, sf.hindi.within.plus2.hc, sf.hindi.within.plus3, test = 'LRT') #FHC does not

#IHC V. prod gradient
sf.hindi.within.plus1.pg <- glmer(Correct ~ prod.gradient + highest_contig.c + ihc.c + count_range +  starting_num.c + age.c  + (1|SID),
                             family = "binomial",
                           data = sf.hindi.within)
anova(sf.hindi.within.plus2.hc, sf.hindi.within.plus1.pg, test = 'LRT')

#SUMMARY of final model
summary(sf.hindi.within.plus2.hc)
# #summary of mean nn model
# summary(sf.hindi.within.plus1.nn)
```

##Hindi Unit Task  within-language results: IHC, and Highest Contig. emerge as best predictor of performance on Unit Task
```{r}
summary(sf.hindi.within.plus2.hc)
tab_model(sf.hindi.within.plus2.hc, transform = NULL)
```
---

#Gujarati: Within-language models, Unit Task
##Build the models
```{r}
#Base
sf.gujarati.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#Productivity
sf.gujarati.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#FHC
sf.gujarati.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#IHC
sf.gujarati.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#Highest contig.
sf.gujarati.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)

#Exploratory - prod.gradient
sf.gujarati.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + 
                                         (1|SID), family = "binomial", data = sf.gujarati.within)
```

##Gujarati: Unit task models
```{r}
mtable.sf.gujarati <- mtable('Base Model' = sf.gujarati.within.base,
            'Model 1: Productivity' = sf.gujarati.within.model1,
            'Model 2: FHC' = sf.gujarati.within.model2,
            'Model 3: IHC' = sf.gujarati.within.model3,
            'Model 4: Highest Contig.' = sf.gujarati.within.model4,
            # 'Exp.: Prod. gradient' = sf.gujarati.within.model.gain,
            # 'Exp.: Cluster' = sf.gujarati.within.model.clust,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.gujarati

tab_model(sf.gujarati.within.base, transform = NULL)
tab_model(sf.gujarati.within.model1, transform = NULL)
tab_model(sf.gujarati.within.model2, transform = NULL)
tab_model(sf.gujarati.within.model3, transform= NULL)
tab_model(sf.gujarati.within.model4, transform = NULL)
```

##Model comparisons
###Base v. productivity - NS, p = .4
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model1, test = 'LRT')
```

###Base v. FHC - NS, p = .3
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model2, test = 'LRT')
```

###Base v. IHC - p = .19
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model3, test = 'LRT')
```

###Base v. Highest contig, NS p = .2
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model4, test = 'LRT')
```

###Exploratory - prod.gradient, NS, p = .96
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model.gain, test = 'LRT')
```

#Large model - mean NN
```{r}
# summary(sf.gujarati.within.base)
# summary(sf.gujarati.within.model.nn)
```

```{r}
summary(sf.gujarati.within.base)
tab_model(sf.gujarati.within.base, transform = NULL)
```


##Productivity t-test of Unit Task performance
Using the Productive/Non-Productive categorical classification outlined above, we will compare performance between both groups on the Unit task using t-tests. We may do this by considering average performance (averaging the 0s and 1s on each task for each participant); should doing so provide greater precision, we may also compare Highest Contiguous Number.

###HK: Marginally significant difference between groups (*p* = .06)
```{r}
#with mean performance
sf.hk.mean.ms <- all.data %>%
  filter(Language == "Cantonese", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.hk.mean.ms, Productive == "Resilient")$mean, 
       subset(sf.hk.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #marginally significant difference between productive and nonproductive counters for performance on Unit Task
```

###SLO
```{r}
#with mean performance
sf.slo.mean.ms <- all.data %>%
  filter(Language == "Slovenian", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.slo.mean.ms, Productive == "Resilient")$mean, 
       subset(sf.slo.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###US
```{r}
#with mean performance
sf.us.mean.ms <- all.data %>%
  filter(Language == "English (US)", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.us.mean.ms, Productive == "Resilient")$mean, 
       subset(sf.us.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###Hindi
```{r}
#with mean performance
sf.hindi.mean.ms <- all.data %>%
  filter(Language == "Hindi", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.hindi.mean.ms, Productive == "Resilient")$mean, 
       subset(sf.hindi.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###Gujarati
```{r}
#with mean performance
sf.gujarati.mean.ms <- all.data %>%
  filter(Language == "Gujarati", 
         Task == "SF")%>%
  group_by(SID, Productive)%>% 
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.gujarati.mean.ms, Productive == "Resilient")$mean, 
       subset(sf.gujarati.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

---
#Next Number
##Descriptive statistics  
```{r}
all.data %>%
  filter(Task == "NN")%>%
  group_by(SID, Language)%>%
  summarise(mean_sub = mean(Correct, na.rm = TRUE))%>%
  group_by(Language)%>%
  summarise(n = n(),
            mean = mean(mean_sub, na.rm = TRUE), 
            sd = sd(mean_sub, na.rm = TRUE), 
            se = sd/sqrt(n))%>%
  kable()
```

##Do English US/India differ?
```{r}
nn.ms <- all.data %>%
  filter(Task == "NN")%>%
  group_by(SID,Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(nn.ms, Language == "English (US)")$mean, 
       subset(nn.ms, Language == "English (India)")$mean, var.equal = TRUE)
```

##NN performance by HC
```{r}
unique.hc.data <- all.data %>%
  distinct(SID, IHC, FHC, Productive, Language, Dataset)%>%
  gather(IHC_FHC,highest_count, IHC:FHC)%>%
  mutate(highest_count = as.integer(highest_count), 
         IHC_FHC = factor(IHC_FHC, levels = c("IHC", "FHC"), 
                          labels = c("Initial Highest Count", "Final Highest Count")))

ms.nn <- all.data %>%
  filter(Task == "NN")%>%
  group_by(SID)%>%
  summarise(mean.nn = mean(Correct, na.rm = TRUE))

nn.full <- full_join(ms.nn, unique.hc.data, by = "SID")

##HK/SLO/US
nn.full %>%
  filter(Language == "Cantonese" |
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)")))%>%
  ggplot(aes(x = highest_count, y = mean.nn, color = Language, group = Language)) +
  geom_count(show.legend = FALSE, alpha = .85) +
  geom_smooth(aes(fill = Language), se = TRUE, size = 1.6, alpha =.16) + 
  facet_grid(~IHC_FHC)+
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2")+
  coord_cartesian(ylim = c(0, 1))+
  theme_bw(base_size = 13) +
  theme(legend.position = "bottom", 
        legend.direction = 'horizontal',
        legend.title = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) + 
  scale_x_continuous(breaks = seq(0, 140, 20)) + 
  labs(x = "Highest Count", y = "Mean Next Number performance")
ggsave("nn_by_hc_hkSloUS.png")

india.pal <- c("#E7298A","#66A61E","#E6AB02", "#D95F02")

nn.full %>%
  filter(Language == "Hindi" |
           Language == "Gujarati" | 
           Language == "English (US)" |
           Language == "English (India)")%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  ggplot(aes(x = highest_count, y = mean.nn, color = Language, group = Language)) +
  geom_count(show.legend = FALSE, alpha = .85) +
  geom_smooth(aes(fill = Language), se = TRUE, size = 1.6, alpha =.16) + 
  facet_grid(~IHC_FHC)+
  scale_color_manual(values = india.pal) +
  scale_fill_manual(values = india.pal)+
  coord_cartesian(ylim = c(0, 1))+
  theme_bw(base_size = 13) +
  theme(legend.position = "bottom", 
        legend.direction = 'horizontal',
        legend.title = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) + 
  scale_x_continuous(breaks = seq(0, 140, 20)) + 
  labs(x = "Highest Count", y = "Mean Next Number performance")
ggsave("nn_by_hc_india.png")
```

##Analysis: Productivity Range, NN
Do Productive counters have significantly more accurate performance for next number prompts outside their count range?
```{r}
ms <- all.data %>%
  filter(Task == "NN")%>%
  mutate(count_range = factor(count_range, levels = c("Within", "Outside")))%>%
 mutate(ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)),
        Task_item = as.numeric(as.character(Task_item)),
        starting_num.c = as.vector(scale(Task_item, center = TRUE, scale = TRUE)), 
        age.c = as.vector(scale(Age, center = TRUE, scale = TRUE)))%>%
  group_by(SID, Language, ihc.c, age.c, Productive, count_range)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))%>%
  filter(count_range == "Outside")


#t-test
#Cantonese
t.test(subset(ms, Language == "Cantonese" & Productive == "Resilient")$mean, 
       subset(ms, Language == "Cantonese" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

#Slovenian
t.test(subset(ms, Language == "Slovenian" & Productive == "Resilient")$mean, 
       subset(ms, Language == "Slovenian" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

#English (US)
t.test(subset(ms, Language == "English (US)" & Productive == "Resilient")$mean, 
       subset(ms, Language == "English (US)" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

#Hindi
t.test(subset(ms, Language == "Hindi" & Productive == "Resilient")$mean, 
       subset(ms, Language == "Hindi" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

#Gujarati
t.test(subset(ms, Language == "Gujarati" & Productive == "Resilient")$mean, 
       subset(ms, Language == "Gujarati" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

#Indian English
t.test(subset(ms, Language == "English (India)" & Productive == "Resilient")$mean, 
       subset(ms, Language == "English (India)" & Productive == "Non-Resilient")$mean, var.equal = TRUE)

```

#WCN Task- within-language analyses, simple models

All models will be logistic mixed effects models, predicting next number performance (0 or 1) on a trial as a function of the following predictors, with a random intercept for subject. In R, the formula will be glmer(predictedSF_correct ~ (predictor) + age + within/outside range + (1|subject), family = binomial).

-  Model 0 (null model): NextNumber.Performance ~ Within/Outside range + Age + (1|subject)
-  Model 1: Next.Number.Performance ~ Productivity + Within/Outside range + Age + (1|subject)
-  Model 2: Next.Number.Performance ~ Final.Count + Within/Outside range + Age + (1|subject)
-  Model 3: Next.Number.Performance ~ Initial.Count + Within/Outside range + Age + (1|subject)

In each language, after running these first three models, any predictor that significantly (p <.05) predicted Next Number Performance (as assessed by running a likelihood ratio test on the Null Model (Model 0) and Models 1, 2, and 3) will be added into Model 6, which will be our Large model (containing all predictors that significantly predicted Next Number Task Performance in the simple models). We will construct model 6 hierarchically. Model comparisons will be performed at each stage by running a likelihood ratio test between reduced and full models, with significant effects retained in the full model (Model 6). Model selection will be done on the basis of AIC evaluation and significant Chi-square statistic.

#HK: Within-language analyses, Next Number Task
##Build the models
```{r}
#base
wcn.hk.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#productivity
wcn.hk.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#FHC
wcn.hk.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#IHC
wcn.hk.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)

#exp - prod gradient
wcn.hk.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                  family = "binomial", data = wcn.hk.within)
```

##Hong Kong: NN task models
```{r}
mtable.wcn.hk <- mtable('Base Model' = wcn.hk.within.base,
            'Model 1: Productivity' = wcn.hk.within.model1,
            'Model 2: FHC' = wcn.hk.within.model2,
            'Model 3: IHC' = wcn.hk.within.model3,
            'Exp: Prod. gradient' = wcn.hk.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.hk

tab_model(wcn.hk.within.base, transform = NULL)
tab_model(wcn.hk.within.model1, transform = NULL)
tab_model(wcn.hk.within.model2, transform = NULL)
tab_model(wcn.hk.within.model3, transform = NULL)
```

##Model comparisons
###Base v. Productivity - NS, p = .36
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 34.33, p < .0001, AIC = 1171.2
````{r}
anova(wcn.hk.within.base, wcn.hk.within.model2, test = 'LRT')
````

###Base v. IHC = Sig, Chisq(1) = 68.63, p < .0001, AIC = 1136.9
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model3, test = 'LRT')
```

###Exploratory - prod. gradient - Sig, Prod. 
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model.gain, test = 'LRT')
```

##Ranking of HK prod. predictors - WCN by AIC
1.  IHC - 1136.9
2.  FHC - 1171.2
3.  Productivity - 1206.7 (NS)


##Large Model
```{r}
#IHC
wcn.hk.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hk.within)
#IHC + FHC
wcn.hk.within.plus2 <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.hk.within)

#compare IHC and FHC
anova(wcn.hk.within.plus1, wcn.hk.within.plus2, test = 'LRT')  #FHC 

#exp - prod.gradient
wcn.hk.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hk.within)
#anova
anova(wcn.hk.within.plus1, wcn.hk.within.plus.gain, test = 'LRT')#prod. gradient NS

mtable.wcn.hk.large <- mtable('IHC alone' = wcn.hk.within.plus1,
            'IHC + FHC' = wcn.hk.within.plus2,
            'Exp: IHC + Gradient' = wcn.hk.within.plus.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.hk.large

summary(wcn.hk.within.plus1)
```

##HK NN Task within-language results: IHC emerge as best predictor of performance on Unit Task
```{r}
summary(wcn.hk.within.plus1)
tab_model(wcn.hk.within.plus1, transform = NULL)
```

---

#SLO: Within-language analyses, NN Task
##Build the models
```{r}
#Base
wcn.slo.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#Productivity
wcn.slo.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#FHC
wcn.slo.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#IHC
wcn.slo.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)

#Explore - prod gradient
wcn.slo.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                   family = "binomial", data = wcn.slo.within)
```

##SLO: NN task models
```{r}
mtable.wcn.slo <- mtable('Base Model' = wcn.slo.within.base,
            'Model 1: Productivity' = wcn.slo.within.model1,
            'Model 2: FHC' = wcn.slo.within.model2,
            'Model 3: IHC' = wcn.slo.within.model3,
            'Exp: Prod. gradient' = wcn.slo.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.slo

tab_model(wcn.slo.within.base, transform = NULL)
tab_model(wcn.slo.within.model1, transform = NULL)
tab_model(wcn.slo.within.model2, transform = NULL)
tab_model(wcn.slo.within.model3, transform = NULL)
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 41.1, p < .0001, AIC = 846.98
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 71.56, p < .0001, AIC = 816.51
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 35.40 p < .0001, AIC = 852.67
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model3, test = 'LRT')
```

###Productivity gradient - Sig, Chisq(1) = 25.37, p < .0001, AIC = 842.35
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model.gain, test = 'LRT')
```
##Ranking of prod predictors - WCN by AIC
1.  FHC - 816.54
2.  Productivity - 846.98
3.  IHC - 852.67


##Large Model comparison
```{r}
#FHC
wcn.slo.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.slo.within)
#Prod + FHC
wcn.slo.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.slo.within)

#compare
anova(wcn.slo.within.plus1, wcn.slo.within.plus2.prod, test = 'LRT')#Prod NS

#IHC + FHC
wcn.slo.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.slo.within)

#compare
anova(wcn.slo.within.plus1, wcn.slo.within.plus2, test = 'LRT')# IHC NS

summary(wcn.slo.within.plus1)
```

##SLO NN Task (interim) within-language results: FHC emerges as best predictors of performance on Unit Task
```{r}
summary(wcn.slo.within.plus1)
tab_model(wcn.slo.within.plus1, transform = NULL)
```
---

#US: Within-language analyses, NN Task
##Build the models
```{r}
#base
wcn.us.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#productivity
wcn.us.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#FHC
wcn.us.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#IHC
wcn.us.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)

#Explore - prod gradient
wcn.us.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
```

##English (US): NN Task models
```{r}
mtable.wcn.us <- mtable('Base Model' = wcn.us.within.base,
            'Model 1: Productivity' = wcn.us.within.model1,
            'Model 2: FHC' = wcn.us.within.model2,
            'Model 3: IHC' = wcn.us.within.model3,
            'Exp: Prod. gradient' = wcn.us.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.us

tab_model(wcn.us.within.base, transform = NULL)
tab_model(wcn.us.within.model1, transform = NULL)
tab_model(wcn.us.within.model2, transform = NULL)
tab_model(wcn.us.within.model3, transform = NULL)
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 14.8, p = .0001, AIC = 1042.3
```{r}
anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 44, p < .0001, AIC = 1013
```{r}
anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 30.52, p < .0001, AIC = 1026.5
```{r}
anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')
```

###Prod gradient
```{r}
anova(wcn.us.within.base, wcn.us.within.model.gain, test = 'LRT')
```

##Ranking of prod predictors - WCN by AIC
1.  FHC - 1013
2.  IHC - 1026.5
3.  Productivity - 1042.3

##Large Model comparison
```{r}
#FHC
wcn.us.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.us.within)
#IHC + FHC
wcn.us.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + 
                               age.c + (1|SID), 
                            family = "binomial", data = wcn.us.within)
#compare
anova(wcn.us.within.plus1, wcn.us.within.plus2, test = 'LRT') #IHC marginal

#Prod + FHC
wcn.us.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c + 
                                    age.c + (1|SID), 
                            family = "binomial", data = wcn.us.within)
#compare
anova(wcn.us.within.plus1, wcn.us.within.plus2.prod, test = 'LRT') #Prod NS



# #add prod. gradient, compare
# wcn.us.within.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
#                              family = "binomial", 
#                            data = wcn.us.within)
# anova(wcn.us.within.plus1, wcn.us.within.plus.gain, test = 'LRT')
```

##US NN Task (interim) within-language results: FHC emerges as best predictor of performance on Unit Task
```{r}
summary(wcn.us.within.plus1)
tab_model(wcn.us.within.plus1, transform = NULL)
```

---

#India English: Within-language analyses, NN task

Build the models
```{r}
#Base Model
wcn.ind.eng.within.base <- glmer(Correct ~ count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#Productivity
wcn.ind.eng.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#FHC
wcn.ind.eng.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#IHC
wcn.ind.eng.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)

#prod.gradient
wcn.ind.eng.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
```

---

##English (India) WCN Models 
Summary
```{r}
mtable.ind.eng <- mtable('Base Model' = wcn.ind.eng.within.base,
            'Model 1: Productivity' = wcn.ind.eng.within.model1,
            'Model 2: FHC' = wcn.ind.eng.within.model2,
            'Model 3: IHC' = wcn.ind.eng.within.model3,
            # 'Exp: Prod. gradient' = wcn.ind.eng.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.ind.eng

tab_model(wcn.ind.eng.within.base, transform = NULL)
tab_model(wcn.ind.eng.within.model1, transform = NULL)
tab_model(wcn.ind.eng.within.model2, transform = NULL)
tab_model(wcn.ind.eng.within.model3, transform = NULL)
```

##Model comparisons
###Base v. Productivity - NS
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 21.1, p < .0001, AIC = 678.7
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 19.49, p < .0001, AIC = 680.30
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model3, test = 'LRT')
```

###Base v. prod. gradient - marginal
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model.gain, test = 'LRT')
```

##Large Model

```{r}
#FHC
wcn.ind.eng.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.ind.eng.within)
#IHC + FHC
wcn.ind.eng.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = wcn.ind.eng.within)

anova(wcn.ind.eng.within.plus1, wcn.ind.eng.within.plus2,test = 'LRT') #IHC sig

# mtable.wcn.ind.eng.large <- mtable('FHC alone' = wcn.ind.eng.within.plus1,
#             'IHC + FHC' = wcn.ind.eng.within.plus2,
#             summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
# mtable.wcn.ind.eng.large

summary(wcn.ind.eng.within.plus2)
```

##English (India) NN Task within-language results: IHC and FHC emerge as best predictors of performance on Unit Task
```{r}
summary(wcn.ind.eng.within.plus2)
tab_model(wcn.ind.eng.within.plus2, transform = NULL)
```
---

#Hindi: Within-language analyses, NN
##Build the models
```{r}
#Base Model
wcn.hindi.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c  + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#Productivity
wcn.hindi.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c +(1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#FHC
wcn.hindi.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +(1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#IHC
wcn.hindi.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)

#Exp- prod.gradient
wcn.hindi.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)

```

##Hindi: NN Task models 
Summary
```{r}
mtable.hindi <- mtable('Base Model' = wcn.hindi.within.base,
            'Model 1: Productivity' = wcn.hindi.within.model1,
            'Model 2: FHC' = wcn.hindi.within.model2,
            'Model 3: IHC' = wcn.hindi.within.model3,
            'Exp: Prod. gradient' = wcn.hindi.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.hindi

tab_model(wcn.hindi.within.base, transform= NULL)
tab_model(wcn.hindi.within.model1, transform = NULL)
tab_model(wcn.hindi.within.model2, transform = NULL)
tab_model(wcn.hindi.within.model3, transform = NULL)
```

##Model comparisons
###Base v. Productivity - sig, Chisq(1) = 4.5, p = .03, AIC = 850.45
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model1, test = 'LRT')
```

###Base v. FHC - sig, Chisq(1) = 27.4, p < .0001, AIC = 827.62
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 33.41, p < .0001, AIC = 821.6
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model3, test = 'LRT')
```

###Base v. Prod. gradient - Sig, Chisq(1) = 10.03, p = .001, AIC = 844.97
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model.gain, test = 'LRT')
```

##Ranking of NN predictors, HIndi, by AIC
1.  IHC - 821.6
2.  FHC - 827.6
3.  Productivity - 850


##Large Model
```{r}
#IHC
wcn.hindi.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hindi.within)
#FHC + IHC
wcn.hindi.within.plus2 <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.hindi.within)

#compare
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2, test= 'LRT')#FHC NS

#Prod + IHC
wcn.hindi.within.plus2.prod <- glmer(Correct ~ Productive + ihc.c + count_range + starting_num.c +age.c +  (1|SID), 
                            family = "binomial", data = wcn.hindi.within)

#compare
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2.prod, test = 'LRT')# prod ns

# #IHC v. IHC+FHC
# anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2, test = 'LRT') 
# #IHC v. Prod + FHC
# anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2.prod, test = 'LRT') 

#Add Prod. gradient, test
wcn.hindi.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hindi.within)
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus.gain, test = 'LRT')

summary(wcn.hindi.within.plus1)
```

##Hindi NN Task within-language results: IHC emerges as best predictor of performance on Unit Task
```{r}
summary(wcn.hindi.within.plus1)
tab_model(wcn.hindi.within.plus1, transform = NULL)
```
---

#Gujarati: Within-language analyses, NN
##Build the models
```{r}
#Base Model
wcn.gujarati.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#Productivity
wcn.gujarati.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#FHC
wcn.gujarati.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#IHC
wcn.gujarati.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)

#Exp. - prod. gradient
wcn.gujarati.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
```

##Gujarati: NN Task models 
Summary
```{r}
mtable.gujarati <- mtable('Base Model' = wcn.gujarati.within.base,
            'Model 1: Productivity' = wcn.gujarati.within.model1,
            'Model 2: FHC' = wcn.gujarati.within.model2,
            'Model 3: IHC' = wcn.gujarati.within.model3,
            # 'Exp: Prod. gradient' = wcn.gujarati.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.gujarati

tab_model(wcn.gujarati.within.base, transform = NULL)
tab_model(wcn.gujarati.within.model1, transform = NULL)
tab_model(wcn.gujarati.within.model2, transform = NULL)
tab_model(wcn.gujarati.within.model3, transform= NULL)
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 10.06, p = .002, AIC = 787.41
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 36.25, p < .0001, AIC  761.2
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model2, test = 'LRT')
```

###Base v. IHC = Sig, Chisq(1) = 33.45, p < .0001, AIC = 764.02
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model3, test = 'LRT')
```

###Base v. Prod. gradient
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model.gain, test = 'LRT')
```

##Ranking of NN Predictors, Gujarati, by AIC 
1.  FHC - 761.2
2.  IHC - 764.02
3.  Productivity - 787

##Large Model
```{r}
#FHC
wcn.gujarati.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.gujarati.within)
#IHC + FHC
wcn.gujarati.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = wcn.gujarati.within)
#compare
anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2, test = 'LRT') #IHC ns

#Prod + FHC
wcn.gujarati.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c +age.c +  (1|SID), 
                            family = "binomial", data = wcn.gujarati.within)
#compare
anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2.prod, test = 'LRT') #Productivity significant

##ADD IHC, compare
wcn.gujarati.within.plus3 <- glmer(Correct ~ ihc.c + Productive + fhc.c + count_range + age.c + starting_num.c + (1|SID),
                            family = "binomial", data = wcn.gujarati.within)
anova(wcn.gujarati.within.plus2.prod, wcn.gujarati.within.plus3, test = 'LRT') #IHC NS


#add prod.gradient, compare
wcn.gujarati.within.plus.gain <- glmer(Correct ~ prod.gradient + Productive + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.gujarati.within)

summary(wcn.gujarati.within.plus2.prod)
summary(wcn.gujarati.within.plus.gain)
```

##Gujarati NN Task within-language results: FHC and Productivity emerge as best predictor of performance on Unit Task
```{r}
summary(wcn.gujarati.within.plus2.prod)
tab_model(wcn.gujarati.within.plus2.prod, transform = NULL)
```

---

#Next number T-tests
##Productivity t-test of Highest contiguous NN
###HK: Significant difference between groups (*p* = .002)
```{r}
sf.hk.mean.nn <- all.data %>%
  filter(Language == "Cantonese")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.hk.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.hk.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```

###SLO - sig, p < .0001
```{r}
sf.slo.mean.nn <- all.data %>%
  filter(Language == "Slovenian")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.slo.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.slo.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```


###US - sig, p < .0001
```{r}
sf.us.mean.nn <- all.data %>%
  filter(Language == "English (US)")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.us.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.us.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```

###India-Eng
```{r}
sf.ind.eng.mean.nn <- all.data %>%
  filter(Language == "English (India)")%>%
  distinct(SID, Productive, highest_contig)%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.ind.eng.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.ind.eng.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```

###Hindi
```{r}
sf.hindi.mean.nn <- all.data %>%
  filter(Language == "Hindi")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.hindi.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.hindi.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```


###Gujarati
```{r}
sf.gujarati.mean.nn <- all.data %>%
  filter(Language == "Gujarati")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.gujarati.mean.nn, Productive == "Resilient")$mean_nn, 
       subset(sf.gujarati.mean.nn, Productive == "Non-Resilient")$mean_nn, var.equal = TRUE)
```

---

#Productivity t-test of WCN performance
Using the Productive/Non-Productive categorical classification outlined above, we will compare performance between both groups on the Next Number task using t-tests. We may do this by considering average performance
(averaring the 0s and 1s on each task for each participant).

###HK: Significant difference between productive and nonproductive counters (*p* = .002)
```{r}
#with mean performance
wcn.hk.mean.ms <- all.data %>%
  filter(Language == "Cantonese", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.hk.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.hk.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###SLO: Significant difference between groups (*p* < .0001)

```{r}
#with mean performance
wcn.slo.mean.ms <- all.data %>%
  filter(Language == "Slovenian", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.slo.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.slo.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###US: Significant difference between groups (*p* < .0001)

```{r}
#with mean performance
wcn.us.mean.ms <- all.data %>%
  filter(Language == "English (US)", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))


t.test(subset(wcn.us.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.us.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```


###Hindi

```{r}
#with mean performance
wcn.hindi.mean.ms <- all.data %>%
  filter(Language == "Hindi", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.hindi.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.hindi.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###Gujarati

```{r}
#with mean performance
wcn.gujarati.mean.ms <- all.data %>%
  filter(Language == "Gujarati", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.gujarati.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.gujarati.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###Indian English

```{r}
#with mean performance
wcn.ind.eng.mean.ms <- all.data%>%
  filter(Language == "English (India)", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.ind.eng.mean.ms, Productive == "Resilient")$mean, 
       subset(wcn.ind.eng.mean.ms, Productive == "Non-Resilient")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

---

#Cross-linguistic comparisons
Our second set of analyses is aimed at understanding cross-linguistic differences in performance on the Unit and Next Number Tasks. To do this, we will analyze all participants, from all language groups, in a single model. We will then construct our models from above, but will add (a) a measure of Working Memory and (b) the interaction of Initial Highest Count and Language group to each model. These models therefore allow us to test whether (a) language; (b) counting ability; or (c) some interaction between the two predict unit performance. We include Working Memory in all cross-linguistic models with the intention of taking into account baseline differences in processing across samples.

##Make model dfs
```{r, include = FALSE}
#currently for Exp 1
sf.df.cross <- all.data %>%
  filter(Task == "SF", 
         Language == "Cantonese" |
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN
  
wcn.df.cross <- all.data %>%
  filter(Task == "NN",
         Language == "Cantonese" |
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)),
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))

##For India
sf.df.cross.india <- all.data %>%
  filter(Task == "SF", 
         Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (US)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN

wcn.df.cross.india <- all.data %>%
  filter(Task == "NN", 
         Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (US)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN

#followup with Indian English 
wcn.df.cross.india.follow <- all.data %>%
  filter(Task == "NN", 
         Language == "English (India)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (India)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN
```

---

#Unit Task: Cross linguistic models - HK/SLO/US (Cantonese as reference group)
##Build the models
```{r}
#base
sf.cross.base <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#productivity
sf.cross.model1 <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#fhc
sf.cross.model2 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#highest contig.
sf.cross.model3 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#prod gradient
sf.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
```

##Cross-linguistic model comparison
```{r}
mtable.sf.cross <- mtable('Base Model' = sf.cross.base,
            'Model 1: Productivity' = sf.cross.model1,
            'Model 2: FHC' = sf.cross.model2,
            'Model 3: Highest Contig.' = sf.cross.model3, 
            # 'Exp: Prod. gradient' = sf.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.cross

tab_model(sf.cross.base, transform = NULL)
tab_model(sf.cross.model1, transform = NULL)
tab_model(sf.cross.model2, transform = NULL)
tab_model(sf.cross.model3, transform = NULL)
```

##Model Comparisons
###Base v. productivity - NS, p = .16
```{r}
anova(sf.cross.base, sf.cross.model1, test = 'LRT')
```

###Base v. FHC - NS, p = .14
```{r}
anova(sf.cross.base, sf.cross.model2, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 22.21, p < .0001, AIC = 4366.
```{r}
anova(sf.cross.base, sf.cross.model3, test = 'LRT')
```

##HCNN emerges as best cross-linguistic predictor
```{r}
tab_model(sf.cross.model3, transform = NULL)
```

###Exploratory -  prod. gradient
```{r}
# anova(sf.cross.base, sf.cross.model.nn, test = 'LRT')
anova(sf.cross.base, sf.cross.model.gain, test = 'LRT')
```

##Do the same process with Slovenian as the reference group
```{r}
slo.ref <- sf.df.cross %>%
  mutate(Language = factor(Language, levels = c("Slovenian", "English (US)", "Cantonese")))

#base
sf.cross.base.slo <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = slo.ref, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#model output
tab_model(sf.cross.base.slo, transform = NULL)
#productivity
sf.cross.model1.slo <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = slo.ref, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))


#model output
tab_model(sf.cross.model1.slo, transform = NULL)
#fhc
sf.cross.model2.slo <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = slo.ref, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
tab_model(sf.cross.model2.slo, transform = NULL)
#highest contig.
sf.cross.model3.slo <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = slo.ref, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

tab_model(sf.cross.model3.slo, transform = NULL)

```

##Large model - no model comparison needed, only sig. predictor above is HCNN
```{r}
#cantonese as comparison
summary(sf.cross.model3)
tab_model(sf.cross.model3, transform = NULL)

#slovenian as comparison
tmp <- sf.df.cross %>%
  mutate(Language = factor(Language, levels = c("Slovenian", "English (US)", "Cantonese")))

sf.cross.model3.slo.comp <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = tmp, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
tab_model(sf.cross.model3.slo.comp, transform = NULL)
```

```{r}
#Exploraotory - mean nn v. hcnn
sf.cross.model3 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
# sf.cross.model.plus.nn <- glmer(Correct ~ mean.nn+ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
#                            (1|SID), 
#                        family = "binomial", data = sf.df.cross, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# #compare
# anova(sf.cross.model3, sf.cross.model.plus.nn, test = 'LRT')


summary(sf.cross.model3)
# summary(sf.cross.model.plus.nn)

```

#Test if effects of language are significant
```{r}
sf.nolang.base <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.nolang.model1 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.nolang.base, sf.nolang.model1, test = 'LRT') 
```

##Follow-up - HCNN significantly interacts with Language group
In the event that, when analyzing each language group separately, we find evidence that a particular counting/productivity measure (Next Number, Final HC, Productivity) improves model fit for one language group by not another, we will conduct a follow-up analysis testing whether productivity classification interacts with language group. We will compare the model containing an interaction to one that excludes the interaction. It is important to note that our critical effect of interest is not necessarily a [Productivity Measure]:[Language Group] interaction, although finding such an interaction may be interpretable (e.g., it may suggest that productivity predicts other measures to a greater degree in some languages vs. others): ProductivityLang: Unit ~ Productivity Measure (Highest NN, FHC, Productivity classification)*Language.Group +
Language*IHC + Within/Outside range + Age + WM (1|subject)
```{r}
#HK/SLO/US
#HCNN
lang.prod.int.hk.noint <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = sf.df.cross, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
lang.prod.int.hk <- glmer(Correct ~ highest_contig.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = sf.df.cross, 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(lang.prod.int.hk.noint, lang.prod.int.hk, test = 'LRT')

summary(lang.prod.int.hk)
summary(lang.prod.int.hk.noint)
```

***
#Unit Task: Cross linguistic models - India (English/Hindi/Gujarati)
##Build the models
```{r}
#base
sf.cross.base.india <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#productivity
sf.cross.model1.india <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#fhc
sf.cross.model2.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#highest contig.
sf.cross.model3.india <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

##exploratory - prod.gain
sf.cross.model.gain.india <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
```

##Cross-linguistic model comparison
```{r}
mtable.sf.cross.india <- mtable('Base Model' = sf.cross.base.india,
            'Model 1: Productivity' = sf.cross.model1.india,
            'Model 2: FHC' = sf.cross.model2.india,
            'Model 3: Highest Contig.' = sf.cross.model3.india, 
            'Exp: Prod. gradient' = sf.cross.model.gain.india,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.cross.india

tab_model(sf.cross.base.india, transform = NULL)
tab_model(sf.cross.model1.india, transform = NULL)
tab_model(sf.cross.model2.india, transform = NULL)
tab_model(sf.cross.model3.india, transform = NULL)
```

##Model Comparisons
###Base v. productivity - NS, p = .85
```{r}
anova(sf.cross.base.india, sf.cross.model1.india, test = 'LRT')
```

###Base v. FHC - NS, p = .99
```{r}
anova(sf.cross.base.india, sf.cross.model2.india, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 13.11, p = .0003, AIC = 3943.9
```{r}
anova(sf.cross.base.india, sf.cross.model3.india, test = 'LRT')
```

#Exploratory - Prod. gradient, NS - p = .46
```{r}
anova(sf.cross.base.india, sf.cross.model.gain.india, test = 'LRT')
# anova(sf.cross.base.india, sf.cross.model.nn.india, test = 'LRT')
```

##Large model - no model comparison needed, only sig. predictor above is HCNN
```{r}
#Summary of final model - hcnn
summary(sf.cross.model3.india)
tab_model(sf.cross.model3.india, transform = NULL)

# #summary of model with hcnn + mean nn
# summary(sf.cross.plus.nn.india)
```

###Test if effects of language are significant
```{r}
sf.nolang.base <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross.india, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.nolang.model1 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross.india, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.nolang.base, sf.nolang.model1, test = 'LRT') 
```

###Lang*prod interaction followup
```{r}
tmp <- sf.df.cross.india %>%
  mutate(Language = factor(Language, levels = c("Gujarati", "English (US)", "Hindi")))

sf.india.lang.noint <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = tmp, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.india.lang.int <- glmer(Correct ~ highest_contig.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = tmp, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.india.lang.noint, sf.india.lang.int, test = 'LRT') 

summary(sf.india.lang.int)
```

###Cross-linguistic comparison of mean performance on unit task 
```{r}
sf.df.cross.india.ms <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = sf.df.cross.india.ms)
summary(lm.india)
```


---

##WCN India
##Build the models
```{r}
#base
wcn.cross.base.india <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1.india <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - Prod. gradient
wcn.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross.india <- mtable('Base Model' = wcn.cross.base.india,
            'Model 1: Productivity' = wcn.cross.model1.india,
            'Model 2: FHC' = wcn.cross.model2.india,
            'Exp: Prod. gradient' = wcn.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.india

tab_model(wcn.cross.base.india, transform = NULL)
tab_model(wcn.cross.model1.india, transform = NULL)
tab_model(wcn.cross.model2.india, transform = NULL)
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 9.9, p = .002, AIC = 2550
```{r}
anova(wcn.cross.base.india, wcn.cross.model1.india, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 22.71, p < .0001, AIC = 2537.9
```{r}
anova(wcn.cross.base.india, wcn.cross.model2.india, test = 'LRT')
```

###Base v. Prod. gradient - Sig, Chisq(1) = 16.05, p < .0001, AIC = 2544
```{r}
anova(wcn.cross.base.india, wcn.cross.model.gain, test = 'LRT')
```

##Large model
```{r}
#FHC
wcn.cross.plus1.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Prod + FHC
wcn.cross.plus2.india <- glmer(Correct ~ Productive + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1.india, wcn.cross.plus2.india, test = 'LRT')##Prod does not add to this model

#what about productivity gradient
wcn.cross.plus2.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1.india, wcn.cross.plus2.gain, test = 'LRT')##prod gradient does not add to this model


mtable.wcn.cross.large.india <- mtable('FHC alone' = wcn.cross.plus1.india,
            'Productive + FHC.' = wcn.cross.plus2.india,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.large.india

#summary of final model
summary(wcn.cross.plus1.india)
tab_model(wcn.cross.plus1.india, transform = NULL)

```

##Test if interaction between FHC and language is significant
```{r}
lang.prod.int.india.noint <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
lang.prod.int.india <- glmer(Correct ~ fhc.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(lang.prod.int.india.noint, lang.prod.int.india, test = 'LRT')##FHC does not interact with language

summary(lang.prod.int.india)
summary(lang.prod.int.india.noint)
```

###Test if effects of language are significant
```{r}
ind.lang <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
ind.nolang <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(ind.lang, ind.nolang, test = 'LRT')#language significant
summary(ind.lang)

```

#Cross-linguistic comparison of mean performance on nn task 
```{r}
nn.df.cross.india.ms <- all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = nn.df.cross.india.ms)
summary(lm.india)

nn.df.cross.india.ms <- all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = nn.df.cross.india.ms)
summary(lm.india)
```
---

#WCN - HK/SLO/US Cross linguistic

##Build the models
```{r}
#base
wcn.cross.base <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1 <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - prod. gradient
wcn.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross <- mtable('Base Model' = wcn.cross.base,
            'Model 1: Productivity' = wcn.cross.model1,
            'Model 2: FHC' = wcn.cross.model2,
            'Exp: Prod.gradient' = wcn.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross

tab_model(wcn.cross.base, transform = NULL)
tab_model(wcn.cross.model1, transform = NULL)
tab_model(wcn.cross.model2, transform = NULL)

```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 19.45, p = .0001, AIC = 2954.2
```{r}
anova(wcn.cross.base, wcn.cross.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 38.82, p < .0001, AIC = 2934.8
```{r}
anova(wcn.cross.base, wcn.cross.model2, test = 'LRT')
```

###Base v. Prod. gradient 
```{r}
anova(wcn.cross.base, wcn.cross.model.gain, test = 'LRT')
```

##Ranking of productivity predictors - WCN by AIC
1.  FHC - 2934.8
2.  Productivity - 2954

##Large model
```{r}
wcn.cross.plus1 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.cross.plus2 <- glmer(Correct ~ Productive + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1, wcn.cross.plus2, test = 'LRT')#Prod is NS

#what about productivity gradient? 
wcn.cross.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.cross.plus1, wcn.cross.plus.gain, test = 'LRT')

# mtable.wcn.cross.large <- mtable('FHC alone' = wcn.cross.plus1,
#             'Productive + FHC.' = wcn.cross.plus2,
#             summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
# mtable.wcn.cross.large

#summary of final model
summary(wcn.cross.plus1)
# summary(wcn.cross.plus.gain)

```

##Slovenian as comparison 
```{r}
wcn.df.cross.slo <- wcn.df.cross %>%
  mutate(Language = factor(Language, levels = c("Slovenian", "English (US)", "Cantonese")))

###BUILD THE MODELS
#base
wcn.cross.base.slo <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.slo, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

tab_model(wcn.cross.base.slo, transform = NULL)
#Productivity
wcn.cross.model1.slo <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.slo, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

tab_model(wcn.cross.model1.slo, transform = NULL)
#FHC
wcn.cross.model2.slo <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.slo, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
tab_model(wcn.cross.model2.slo, transform = NULL)

#Exp - prod. gradient
wcn.cross.model.gain.slo <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.slo, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

```{r}
#Cantonese as comparsion
summary(wcn.cross.plus1)
tab_model(wcn.cross.plus1, transform = NULL)

#Slovenian as comparison
tmp <- wcn.df.cross %>%
  mutate(Language = factor(Language, levels = c("Slovenian", "English (US)", "Cantonese")))
         
         
wcn.cross.plus1.slo.comp <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = tmp, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

summary(wcn.cross.plus1.slo.comp)
tab_model(wcn.cross.plus1.slo.comp, transform = NULL)
```

#Test if effects of language are significant
```{r}
wcn.nolang.base <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.nolang.model1 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.nolang.base, wcn.nolang.model1, test = 'LRT') 
```

#Lang*prod interaction because we found significant effects for FHC in SLO and English, but not Cantonese
```{r}
wcn.prod.int <- glmer(Correct ~ fhc.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.prod.noint <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.prod.noint, wcn.prod.int, test = 'LRT') 

summary(wcn.prod.int)

all.data %>%
  filter(Task == "NN", 
         Language == "Cantonese" | 
           Language == "English (US)" | 
           Language == "Slovenian")%>%
  group_by(SID, IHC, FHC, Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = FHC, y = mean, color = IHC, group = Language)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  facet_grid(~Language)
```

---
#Followup with Indian English for NN
##Build the models
```{r}
#base
wcn.cross.base.india.follow <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india.follow, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1.india.follow <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india.follow, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2.india.follow <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - prod. gradient
wcn.cross.model.gain.india.follow <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross.india.follow <- mtable('Base Model' = wcn.cross.base.india.follow,
            'Model 1: Productivity' = wcn.cross.model1.india.follow,
            'Model 2: FHC' = wcn.cross.model2.india.follow,
            'Exp: Prod. gradient' = wcn.cross.model.gain.india.follow,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.india.follow

tab_model(wcn.cross.base.india.follow, transform = NULL)
tab_model(wcn.cross.model1.india.follow, transform = NULL)
tab_model(wcn.cross.model2.india.follow, transform = NULL)
```

##Model comparisons
###Base v. Productivity - NS
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model1.india.follow, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 8.36, p = .004, AIC = 2140.2
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model2.india.follow, test = 'LRT')
```

###Base v. Prod. gradient
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model.gain.india.follow, test = 'LRT')
```

##Large model
```{r}
#compare with prod. gradient
wcn.cross.model.india.follow.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.model2.india.follow, wcn.cross.model.india.follow.plus.gain, test = 'LRT')

#summary of final model
summary(wcn.cross.model2.india.follow)
tab_model(wcn.cross.model2.india.follow, transform = NULL)
```

###Are the effects of language significant?
```{r}
ind.eng.lang <- wcn.cross.model2.india.follow
ind.eng.nolang <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(ind.eng.nolang, ind.eng.lang, test = 'LRT')
```

---

#Cross-linguistic comparison for mean performance on NN task (India)
```{r}
nn.ms <- all.data %>%
  filter(Task == "NN", 
         Language == "English (India)" | 
           Language == "Gujarati" | 
           Language == "Hindi")%>%
  group_by(SID)%>%
  mutate(mean_nn = mean(Correct, na.rm = TRUE))

lm1 <- lm(mean_nn ~ Language*Age + sum_wppsi, data = nn.ms)
summary(lm1)
```

---

#Cross-linguistic comparison for mean performance on Unit task (US)
```{r}
sf.ms <- all.data %>%
  filter(Task == "SF", 
         Language == "English (India)" | 
           Language == "Gujarati" | 
           Language == "Hindi")%>%
  group_by(SID)%>%
  mutate(mean_sf = mean(Correct, na.rm = TRUE))

lm2 <- lm(mean_sf ~ Language*Age + sum_wppsi, data = sf.ms)
summary(lm2)
```

---

#Counting distribution
We plan to conduct descriptive analyses to describe the ways in which Initial Highest Count differs across
languages.
```{r}
hc.df %>%
  group_by(Language)%>%
  summarise(mean = mean(IHC, na.rm = TRUE), 
            sd = sd(IHC, na.rm = TRUE), 
            median = median(IHC, na.rm = TRUE))
```

In addition, we plan to test whether children in transparent languages can become productive with less counting experience. To test this, we will consider non-productive counters (those who were labeled as non-Productive). We will then ask whether IHC for these non-productive counters differs across languages. We will only conduct these analyses if we have at least 30 non-productive counters in each language. If count-list transparency allows children to converge on a productive count rule more quickly, then children who learn a system with a transparent-count list should move to the productive counter category on the basis of relatively less experience than children who learn a system with an opaque- count list. This predicts that, when considering non-Productive counters, initial highest count should be higher for opaque languages (like English) than for Slovenian, and higher for Slovenian than for Cantonese. The model would like this: 

Model 1: IHC ~ Language + Age + WM, data = NonProductiveCounters

###Model
```{r}
ihc.cross <- all.data %>%
   filter(!is.na(Productive))%>%
  distinct(SID, Language, Age, sum_wppsi, Productive, IHC, Dataset)%>%
  filter(Productive == "Non-Resilient")%>%
  mutate(Language = factor(Language))%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale = TRUE)))

ihc.cross.hk.slo <- ihc.cross %>%
  filter(Language == "Cantonese" | 
           Language == "Slovenian" | 
           Language == "English (US)")

ihc.cross.model.hk.slo <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.hk.slo)
summary(ihc.cross.model.hk.slo)

ihc.cross.ind <- ihc.cross %>%
  filter(Language == "English (US)"|
           Language == "Hindi" |
           Language == "Gujarati")

ihc.cross.model.ind <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.ind)
summary(ihc.cross.model.ind)

ihc.cross.ind <- ihc.cross %>%
  filter(Language == "English (India)"|
           Language == "Hindi" |
           Language == "Gujarati")

ihc.cross.model.ind <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.ind)
summary(ihc.cross.model.ind)
```

In addition, we will test whether count-list transparency allows children to acquire some degree of productivity, even before they are labeled productive counters based on their overall counting performance. To test this, we will predict Highest Contiguous Next Number from Language. If transparent languages allow children to generate a productive counting rule, speakers of these transparent languages may perform better on the Next Number task than speakers of non- transparent languages, even when only considering non-productive counters. Model 2: Highest.Contiguous.NextNumber ~ Language + Age + WM + (1|subject), data = NonProductiveCounters

###Model: No effect of Language here
```{r}
wcn.model <- all.data %>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  distinct(SID, Language, Age, sum_wppsi, Productive, highest_contig, Dataset)%>%
  filter(Productive == "Nonproductive")%>%
  mutate(Language = factor(Language))%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale = TRUE)))

wcn.model.hk.slo <- wcn.model %>%
  filter(Dataset == "HK/SLO/US")

highest_contig.model.hk.slo <- lm(highest_contig ~ Language + age.c + wppsi.c, data = wcn.model.hk.slo)
summary(highest_contig.model.hk.slo)

wcn.model.ind <- wcn.model %>%
  filter(Dataset == "India")

highest_contig.model.ind <- lm(highest_contig ~ Language + age.c + wppsi.c, data = wcn.model.ind)
summary(highest_contig.model.ind)

```
---

##Post-hoc: Analysis of >100 and <100 items
Unit task first
```{r}
##first create a variable for whether items are above or below 100
#cantonese
sf.hk.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#slovenian
sf.slo.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#us english
sf.us.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#hindi
sf.hindi.within %<>%
  mutate(above.100 = ifelse(as.numeric(as.character(Task_item)) <100, "<100", ">100"))

#gujarati
sf.gujarati.within %<>%
  mutate(above.100 = ifelse(as.numeric(as.character(Task_item)) <100, "<100", ">100"))

##now run a model within langauge
##We're testing whether items below or above 100 take a hit; in all languages, 100 marks the introduction of new syntax and words

##Getting rid of starting num - this is going to overlap with >100, so it's likely going to give us some weird results

##cantonese
#does above 100 explain additional variance
hk.sf.100.base <- glmer(Correct ~ ihc.c + count_range + age.c + (1|SID), 
                   family = 'binomial', data = sf.hk.within)

hk.sf.100.full <- glmer(Correct ~ above.100 + ihc.c + count_range+ age.c + (1|SID),
                        family = 'binomial', data = sf.hk.within)
anova(hk.sf.100.base, hk.sf.100.full, test = 'LRT')
summary(hk.sf.100.full) ##no difference for items above 100

#Slovenian
#does above 100 explain additional variances
slo.sf.100.base <- glmer(Correct ~ fhc.c + highest_contig.c + count_range  + age.c + (1|SID), 
                   family = 'binomial', data = sf.slo.within)

slo.sf.100.full <- glmer(Correct ~ above.100 + fhc.c + highest_contig.c + count_range + age.c + (1|SID),
                        family = 'binomial', data = sf.slo.within)
anova(slo.sf.100.base, slo.sf.100.full, test = 'LRT')
summary(slo.sf.100.full)

#us
#does above 100 explain additional variance
us.sf.100.base <- glmer(Correct ~ ihc.c + highest_contig.c + count_range+ age.c + (1|SID), 
                   family = 'binomial', data = sf.us.within)

us.sf.100.full <- glmer(Correct ~ above.100 +  ihc.c + highest_contig.c +count_range+ age.c + (1|SID),
                        family = 'binomial', data = sf.us.within)
anova(us.sf.100.base, us.sf.100.full, test = 'LRT')
summary(us.sf.100.full)

#hindi
#does above 100 explain additional variance
hindi.sf.100.base <- glmer(Correct ~ ihc.c + highest_contig.c + count_range+ age.c + (1|SID), 
                   family = 'binomial', data = sf.hindi.within)

hindi.sf.100.full <- glmer(Correct ~ above.100 +  ihc.c + highest_contig.c +count_range+ age.c + (1|SID),
                        family = 'binomial', data = sf.hindi.within)
anova(hindi.sf.100.base, hindi.sf.100.full, test = 'LRT')
summary(hindi.sf.100.full)

#gujarati
#does above 100 explain additional variance
gujarati.sf.100.base <- glmer(Correct ~ count_range+ age.c + (1|SID), 
                   family = 'binomial', data = sf.gujarati.within)

gujarati.sf.100.full <- glmer(Correct ~ above.100 +count_range+ age.c + (1|SID),
                        family = 'binomial', data = sf.gujarati.within)
anova(gujarati.sf.100.base, gujarati.sf.100.full, test = 'LRT')
summary(gujarati.sf.100.full)
```

Now Next Number
```{r}
##first create a variable for whether items are above or below 100
#cantonese
wcn.hk.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#slovenian
wcn.slo.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#us english
wcn.us.within %<>%
  mutate(above.100 = ifelse(Task_item <100, "<100", ">100"))

#hindi
wcn.hindi.within %<>%
  mutate(above.100 = ifelse(as.numeric(as.character(Task_item)) <100, "<100", ">100"))

#gujarati
wcn.gujarati.within %<>%
  mutate(above.100 = ifelse(as.numeric(as.character(Task_item)) <100, "<100", ">100"))

##now run a model within langauge
##We're testing whether items below or above 100 take a hit; in all languages, 100 marks the introduction of new syntax and words

##Getting rid of starting num - this is going to overlap with >100, so it's likely going to give us some weird results

##cantonese
#does above 100 explain additional variance
hk.wcn.100.base <- glmer(Correct ~ ihc.c + count_range + age.c + (1|SID), 
                   family = 'binomial', data = wcn.hk.within)

hk.wcn.100.full <- glmer(Correct ~ above.100 + ihc.c + count_range+ age.c + (1|SID),
                        family = 'binomial', data = wcn.hk.within)
anova(hk.wcn.100.base, hk.wcn.100.full, test = 'LRT')
summary(hk.wcn.100.full) ##no difference for items above 100

#Slovenian
#does above 100 explain additional variances
slo.wcn.100.base <- glmer(Correct ~ fhc.c + count_range  + age.c + (1|SID), 
                   family = 'binomial', data = wcn.slo.within)

slo.wcn.100.full <- glmer(Correct ~ above.100 + fhc.c + count_range + age.c + (1|SID),
                        family = 'binomial', data = wcn.slo.within)
anova(slo.wcn.100.base, slo.wcn.100.full, test = 'LRT')
summary(slo.wcn.100.full)

#us
#does above 100 explain additional variance
us.wcn.100.base <- glmer(Correct ~ ihc.c + highest_contig.c + count_range+ age.c + (1|SID), 
                   family = 'binomial', data = wcn.us.within)

us.wcn.100.full <- glmer(Correct ~ above.100 +  ihc.c + highest_contig.c +count_range+ age.c + (1|SID),
                        family = 'binomial', data = wcn.us.within)
anova(us.wcn.100.base, us.wcn.100.full, test = 'LRT')
summary(us.wcn.100.full)

#hindi
#does above 100 explain additional variance
hindi.wcn.100.base <- glmer(Correct ~ ihc.c + count_range+ age.c + (1|SID), 
                   family = 'binomial', data = wcn.hindi.within)

hindi.wcn.100.full <- glmer(Correct ~ above.100 +  ihc.c  +count_range+ age.c + (1|SID),
                        family = 'binomial', data = wcn.hindi.within)
anova(hindi.wcn.100.base, hindi.wcn.100.full, test = 'LRT')
summary(hindi.wcn.100.full)

#gujarati
#does above 100 explain additional variance
gujarati.wcn.100.base <- glmer(Correct ~ fhc.c + count_range + age.c + (1|SID), 
                   family = 'binomial', data = wcn.gujarati.within)

gujarati.wcn.100.full <- glmer(Correct ~ above.100 +fhc.c + count_range+ age.c + (1|SID),
                        family = 'binomial', data = wcn.gujarati.within)
anova(gujarati.wcn.100.base, gujarati.wcn.100.full, test = 'LRT')
summary(gujarati.wcn.100.full)
```


##By-item graph for each lang
```{r}
##first SF
all.data %>%
  mutate(exclude = ifelse((Language == "English (India)" & Task == "SF"), 1, 0))%>%
  filter(exclude != 1)%>%
  filter(Task == "SF" | 
           Task == "NN")%>%
  mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)", "Hindi", 
                                                "Gujarati", "English (India)")))%>%
  mutate(Task_item = factor(Task_item, levels = c("5", "7", "16", 
                                                  "24", "52","71", 
                                                  "105", "107", "116", 
                                                  "224", "252", "271")), 
         Experiment = ifelse((Language == "Cantonese" | Language == "Slovenian" | Language == "English (US)"), "Experiment 1", "Experiment 2"), 
         Task = factor(Task, levels = c("SF", "NN"), labels = c("Unit Task", "Next Number")))%>%
  group_by(SID, Task, Language, Experiment, Task_item)%>%
  summarise(mean_sub = mean(Correct, na.rm = TRUE))%>%
  group_by(Language, Task, Experiment, Task_item)%>%
  summarise(n = n(), 
            mean = mean(mean_sub), 
            sd = sd(mean_sub, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = Task_item, y = mean, colour = Language, group= Language, shape = Language)) +
  geom_point(size = 3) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1, size = .8) +
  theme_bw(base_size = 13) + 
  facet_grid(Experiment~Task) + 
  scale_color_brewer(palette = "Dark2")+
  theme(legend.position = "right", 
        legend.title = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Number queried", y = "Mean Unit Task performance")
ggsave("unit_nn_item.png", width = 9, height = 5.3)

```

##IHC cluster visualization 
```{r}
initial_final %>%
  mutate(Experiment = ifelse((Language == "Hindi" | Language == "Gujarati" | Language == "English (India)"), "Experiment 2", "Experiment 1"))%>%
  dplyr::select(IHC, Experiment, Language)%>%
  mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)", "Hindi", "Gujarati", "English (India)")))%>%
  ggplot(aes(x = IHC, colour= Language)) + geom_density(adjust = .5, size = 1.5) +
  scale_x_continuous(breaks = seq(0, 140, 10)) +
  theme_bw(base_size = 13) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank()) +
  scale_colour_brewer(palette = "Dark2") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        legend.position = "bottom") +
  labs(x = "Initial Highest Count", y = "Density") + 
  facet_grid(~Experiment)
ggsave("ihc_density_language.png", height = 5)
```
