---
title: "XCulture Analysis"
author: "Rose M. Schneider"
date: "8/5/2018"
output: html_document
---
#Setup
```{r, include = FALSE}
rm(list = ls())
require("knitr")
opts_knit$set(root.dir = "~/Documents/Projects/xculture/HK_SLO/") #this is specific to RMS, change accordingly
library(tidyverse)
library(magrittr)
library(langcog)
library(lme4)
library(stringr)
library(RColorBrewer)
library(ggthemes)
library(memisc)
'%!in%' <- function(x,y)!('%in%'(x,y))
```

#Load data
##Slovenian
```{r}
#slo data
slo.full.data <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/SLO_data.csv')%>%
  filter(SID != "CopyPasteMe")%>%
  droplevels()%>%
  dplyr::select(-Response_single, -Response_double, -Mem_check_1_single, -Mem_check_1_double, 
                -Mem_check_2_single, -Mem_check_2_double, - X, - X.1, -DOB, -DOT, 
                -Notes_single_coding, -Notes_double, -Location)%>% #remove single & double coding, keep final
  dplyr::rename(Response = Response_final, 
                Mem_check_1 = Mem_check_1_final, 
                Mem_check_2 = Mem_check_2_final, 
                Exclude_trial_reason = Exclude_trial_single_reason)%>% #rename final coding
  mutate(Exclude_analysis = ifelse(is.na(Exclude_analysis), 0 , as.integer(as.character(Exclude_analysis))),
         Exclude_task = ifelse(is.na(Exclude_task), 0 , as.integer(as.character(Exclude_analysis))),
         Task_item = factor(Task_item), 
         Response = ifelse(Task == "WPPSI", as.character(Correct), as.character(Response)),
         Age = as.numeric(as.character(Age)),  
         Mem_check_1 = as.integer(as.character(Mem_check_1)), 
         Mem_check_2 = as.integer(as.character(Mem_check_2)))

#slo highest count
slo.hc <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/SLO_HC.csv')%>%
  dplyr::select(-Special_count, -IHC_single, -FHC_single)%>%
  dplyr::rename(IHC = IHC_final, 
                FHC = FHC_final, 
                Last_successful = Last_Successful)%>%
  filter(Exclude != 1)%>% #some kids have extra prompts, or had errors listed that were actually self corrections
  mutate(Language = "Slovenian", 
         Last_successful = as.integer(as.character(Last_successful)))

#sanity check for hc - does everyone have just one IHC and one FHC?
sanity.slo.hc <- slo.hc %>%
  distinct(SID, IHC, FHC)%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  filter(n != 1)

if (length(sanity.slo.hc$SID) > 0) {
  print("ERROR: Mistake in IHC or FHC - more than one per participant")
} 
```

##Cantonese
```{r}
#hk data
hk.full.data <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/HK_Data.csv')%>%
  filter(SID != "CopyPasteMe")%>%
  droplevels()%>%
  dplyr::select(-Response_single, -Response_double, -Mem_check_1_single, -Mem_check_1_double, 
                -Mem_check_2_single, -Mem_check_2_double, -Exclude_trial_single, 
                -Exclude_trial_double, -Unit_task_repeat_alts, -Notes_single, -Notes_double, -Location)%>%#remove single & double coding, keep final
  dplyr::rename(Response = Response_final, 
                Correct = Correct_final, 
                Mem_check_1 = Mem_check_1_final, 
                Mem_check_2 = Mem_check_2_final,
                Exclude_trial = Exclude_trial_final)%>% 
  mutate(Correct = as.integer(as.character(Correct)),
         Age = as.numeric(as.character(Age)),  
         Mem_check_1 = as.integer(as.character(Mem_check_1)), 
         Mem_check_2 = as.integer(as.character(Mem_check_2)), 
         Response = ifelse(Task == "WPPSI", as.character(Correct), as.character(Response)),
         Exclude_analysis_reason = ifelse(Exclude_analysis_reason == 0, "", as.character(Exclude_analysis_reason)))

#hk highest count
hk.hc <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/HK_HC.csv')%>%
  dplyr::select(-Special_count, -IHC_single, -FHC_single, -hundred.syntax, 
                -raw.count)%>%
  dplyr::rename(IHC = IHC_double, 
                FHC = FHC_double)%>%
  filter(Exclude != 1)%>% #some kids have extra prompts, or had errors listed that were actually self corrections
  mutate(Language = "Cantonese")

#sanity check for hc
sanity.hk.hc <- hk.hc %>%
  distinct(SID, IHC, FHC)%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  filter(n != 1)

if (length(sanity.hk.hc$SID) > 0) {
  print("ERROR: Mistake in IHC or FHC - more than one per participant")
}
```

##English - US
```{r}
us.full.data <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/US_Data.csv') %>%
  filter(SID != "CopyPasteMe")%>%
  droplevels()%>%
  dplyr::select(-Response_single, -Response_double, -Mem_check_1_single, -Mem_check_2_single, 
         -Mem_check_1_double, -Mem_check_2_double, -repeated.alts, -Location, -DOB, -DOT)%>%
  dplyr::rename(Response = Response_final, 
                Mem_check_1 = Mem_check_1_final, 
                Mem_check_2 = Mem_check_2_final)%>%
  mutate(Age = as.numeric(as.character(Age)), 
         Mem_check_1 = as.integer(as.character(Mem_check_1)), 
         Mem_check_2 = as.integer(as.character(Mem_check_2)), 
         Correct = as.integer(as.character(Correct)),
         Exclude_task = ifelse(is.na(Exclude_task), 0, as.character(Exclude_task)), 
         Exclude_trial = as.integer(as.character(Exclude_trial)),
         Exclude_task = as.integer(Exclude_task))

#highest count
us.hc <- read.csv('/Users/roseschneider/Documents/Projects/xculture/HK_SLO/Data/US_HC.csv')%>%
  dplyr::rename(IHC = IHC_final, 
                FHC = FHC_final)%>%
  filter(Exclude != 1)%>%
  mutate(Exclude = as.integer(as.character(Exclude)))%>%
  mutate(Special_Count = ifelse(Special_Count != "0", 1, 0), 
         Special_Count = as.integer(as.character(Special_Count)), 
         IHC = as.integer(as.character(IHC)), 
         FHC = as.integer(as.character(FHC)))%>%
  dplyr::select(-Special_Count, -IHC_single, -FHC_single, -Second_coder.notes) %>%
  mutate(Last_Successful = as.integer(as.character(Last_Successful)), 
         Language = "English (US)")%>%
  dplyr::rename(Last_successful = Last_Successful, 
                After_prompt = After_Prompt)

#sanity check for hc
sanity.us.hc <- us.hc %>%
  distinct(SID, IHC, FHC)%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  filter(n != 1)

if (length(sanity.us.hc$SID) > 0) {
  print("ERROR: Mistake in IHC or FHC - more than one per participant")
}
```

##India data
```{r}
india.full.data <- read.csv('/Users/roseschneider/Documents/Projects/xculture/India/Data/India_Data.csv')%>%
  filter(SID != "CopyPasteMe",
         Language != "ChangeMe")%>%
  droplevels()%>%
  dplyr::select(-Response_single, -Response_double, -Mem_check_1_single, 
         -Mem_check_1_double, -Mem_check_2_single, -Mem_check_2_double, -Exclude_trial_single,
         -Exclude_trial_double, -Exclude_trial_reason_single,
         -Exclude_trial_double, -Exclude_trial_reason_double, - Unit_task_repeat_alts, 
         -Notes_single, -Notes_double, -Location)%>%
  mutate(Response = ifelse(Response == "<NA>", NA, as.character(Response)),
         Language = ifelse(Language == "English", "English (India)", as.character(Language)),
         Task = ifelse(Task == "WCN", "NN", as.character(Task)),
         Trial_number = ifelse(Trial_number == "training", "Training", as.character(Trial_number)), 
         Language = factor(Language))

#hc
india.hc <- read.csv("/Users/roseschneider/Documents/Projects/xculture/India/Data/India_HC.csv") %>%
  filter(Exclude != 1)%>%
  mutate(Last_successful = as.integer(as.character(Last_successful)))%>%
  dplyr::select(-Special_count, -IHC_single, -FHC_single, -Experimenter_missed, 
                -Coder)%>%
  dplyr::rename(IHC = IHC_final, 
                FHC = FHC_final, 
                Exclude_reason = Exclude.reason)

#sanity check for hc
sanity.india.hc <- india.hc %>%
  distinct(SID, IHC, FHC)%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  filter(n != 1)

if (length(sanity.india.hc$SID) > 0) {
  print("ERROR: Mistake in IHC or FHC - more than one per participant")
}
```

##Bind together
```{r, warning = FALSE}
#suppress warning because factors are being coerced to characters when binding dfs
#regular data
all.data <- bind_rows(slo.full.data, hk.full.data, us.full.data, india.full.data)%>%
  mutate(Age = round(Age, 2), 
         Agegroup = cut(Age, breaks = c(3.49, 4, 4.5, 5, 5.5, 6, 6.66), 
                        labels = c("3.5-4", "4-4.5", "4.5-5", 
                                   "5-5.5", "5.5-6", "6-6.5")))%>%
  mutate(Language = factor(Language), 
         SID = factor(SID))%>%
  filter(SID != "")%>%
  mutate(Dataset = ifelse(Language == "English (US)" |
                            Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))

##now highest count, with caps for IHC and FHC
slo.hc %<>%
  filter(Exclude != 1)%>%
  mutate(IHC = ifelse(IHC > 140, 140, IHC), 
         FHC = ifelse(FHC > 140, 140, FHC))

hk.hc %<>%
  filter(Exclude != 1)%>%
  mutate(IHC = ifelse(IHC > 140, 140, IHC), 
         FHC = ifelse(FHC > 140, 140, FHC))

us.hc %<>%
  filter(Exclude != 1)%>%
  mutate(IHC = ifelse(IHC > 140, 140, IHC), 
         FHC = ifelse(FHC > 140, 140, FHC))

india.hc %<>%
  mutate(IHC = as.integer(as.character(IHC)), 
         FHC = as.integer(as.character(FHC)), 
         IHC = ifelse(IHC > 140, 140, IHC), 
         FHC = ifelse(FHC > 140, 140, FHC))%>%
  mutate(Language = factor(Language), 
         Last_successful)

#bind hk and slo hc data
hc.df <- bind_rows(slo.hc, hk.hc, us.hc, india.hc)%>%
  dplyr::select(-Note, -Notes, -PB.on.11.13.18)%>%
  mutate(Language = factor(Language), 
         SID = factor(SID))%>%
  filter(SID != "")

#get unique SIDs from HC
unique_hc <- as.vector(unique(hc.df$SID))
```

---
#Exclusions
##Global exclusions
Children were excluded from the analysis only if a) they did not complete the highest count task, or b) their exclusion was noted by the experimenter. Note that there are currently participants excluded from the Slovenian dataset due to not having enough data from the WPPSI. These children may be added back in, but we're currently in a position to replace them. 
```{r}
#How many children pre-exclusions
#HK/SLO/US
all.data %>%
  filter(Language == "English (US)" | 
           Language == "Slovenian" |
           Language == "Cantonese")%>%
  distinct(SID, Language)%>%
  group_by(Language)%>%
  summarise(n = n())%>%
  mutate(Total = sum(n))%>%
  kable()

#India
all.data %>%
  filter(Language == "English (India)" | 
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, Language)%>%
   group_by(Language)%>%
  summarise(n = n())%>%
  mutate(Total = sum(n))%>%
  kable()


#How many kids are excluded per dataset, and for what reason? Saved to variables because tables are big and confusing
#HK/SLO/US
total.exc.hk <- all.data %>%
  filter(Exclude_analysis == 1, 
         Language == "English (US)" | 
           Language == "Slovenian" |
           Language == "Cantonese")%>%
  distinct(SID, Exclude_analysis, Exclude_analysis_reason, Language)%>%
  group_by(Exclude_analysis_reason)%>%
  summarise(n = n())%>%
  group_by()%>%
  mutate(Total_exc = sum(n))

#India
total.exc.india <- all.data %>%
  filter(Exclude_analysis == 1, 
         Language == "English (India)" | 
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, Exclude_analysis, Exclude_analysis_reason, Language)%>%
  group_by(Exclude_analysis_reason)%>%
  summarise(n = n())%>%
  group_by()%>%
  mutate(Total_exc = sum(n))

#breakdown of exclusions by language 
#HK/SLO/US
total.exc.hk.lang <- all.data %>%
  filter(Exclude_analysis == 1, 
         Language == "English (US)" | 
           Language == "Slovenian" |
           Language == "Cantonese")%>%
  distinct(SID, Exclude_analysis, Exclude_analysis_reason, Language)%>%
  group_by(Language, Exclude_analysis_reason)%>%
  summarise(n = n())%>%
  group_by(Language)%>%
  mutate(Total_exc = sum(n))

#India
total.exc.india.lang <- all.data %>%
  filter(Exclude_analysis == 1, 
         Language == "English (India)" | 
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, Exclude_analysis, Exclude_analysis_reason, Language)%>%
  group_by(Language, Exclude_analysis_reason)%>%
  summarise(n = n())%>%
  group_by(Language)%>%
  mutate(Total_exc = sum(n))

###Make sure we have the same SIDs in all.data and hc.df
#get exclude kids, exclude from hc
excluded_all_sids <- as.vector(unique(subset(all.data, Exclude_analysis == 1)$SID))

hc.df %<>%
  filter(SID %!in% excluded_all_sids)

#exclude exclude_analysis from full dataset
all.data %<>%
  filter(Exclude_analysis != 1)

#filter out NAs for Language and SID
all.data %<>%
  filter(!is.na(Language))%>%
  filter(SID != "")

####sanity check#####
#Do we have the same number of participants in all.data and hc.df?
unique.sid <- all.data%>%
  distinct(SID)
# 
##check against HC
unique.hc <- as.vector(unique(hc.df$SID))

##Check to make sure length of unique SID = length of unqiue HC SID
if (length(unique.sid$SID) == length(unique.hc)) {
  print("Same length of SIDS")
} else {
  print("ERROR: Differing numbers")
}

##only need to run this if lengths differ - this will tell you which SIDs are not included in hc.df that are in all.data. Change order of dfs if depending on which one is larger.
unique.hc.sids <- hc.df %>%
  distinct(SID)%>%
  filter(SID %!in% unique.sid$SID)
```

###Task exclusions
Children were excluded from a given task if they did not complete at least TWO trials of that task (in addition to the training trial). In order to be considered as having completed a trial of the task, a child must at least say "I don't know."  These children were excluded manually.
```{r}
#what tasks have children excluded in each dataset
#HK/SLO/US
task.excl.hk <- all.data %>%
  filter(Language == "English (US)" | 
           Language == "Slovenian" |
           Language == "Cantonese")%>%
  filter(Exclude_task == 1)%>%
  distinct(SID, Language, Exclude_task, Excluded_task, Exclude_task_reason)%>%
  group_by(Language, Excluded_task)%>%
  summarise(n = n())

task.excl.india <- all.data %>%
  filter(Language == "English (India)" | 
           Language == "Hindi" |
           Language == "Gujarati")%>%
  filter(Exclude_task == 1)%>%
  distinct(SID, Language, Exclude_task, Excluded_task, Exclude_task_reason)%>%
  group_by(Language, Excluded_task)%>%
  summarise(n = n())

#exclude kids from data
all.data %<>%
  filter(Exclude_task != 1)

#check to make sure there aren't other kids who snuck in
check_wppsi <- all.data %>%
  filter(Task == "WPPSI")%>%
  filter(Exclude_trial != 1)%>%
  mutate(Trial_number = factor(Trial_number))%>%
  filter(Trial_number != "sample item A", 
         Trial_number != "sample item B", 
         Trial_number != "Sample item A", 
         Trial_number != '1', 
         Trial_number != '2', 
         Trial_number != '7', 
        Trial_number != '8')%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  mutate(WPPSI_exc = ifelse(n < 3, 'EXCLUDE', 'KEEP'))%>%
  filter(WPPSI_exc == 'EXCLUDE')

exclude_wppsi_SIDs <- as.vector(unique(check_wppsi$SID))

if (length(check_wppsi$SID != 0)) {
  print("ERROR: Participant doesn't have enough trials in WPPSI")
} else {
  print("All participants have enough WPPSI trials")
}

#what about for other tasks?
check_all <- all.data %>%
  filter(Trial_number != "Training")%>%
  group_by(SID, Task)%>%
  summarise(n = n())%>%
  mutate(GiveN_exc = ifelse(Task == "GiveN" & n < 2, 'EXCLUDE', 'KEEP'), 
         SF_exc = ifelse(Task == "SF" & n < 2, 'EXCLUDE', 'KEEP'), 
         NN_exc = ifelse(Task == "NN" & n < 2, 'EXCLUDE', 'KEEP'))%>%
  filter(GiveN_exc == 'EXCLUDE' |
           SF_exc == "EXCLUDE" |
           NN_exc == 'EXCLUDE')

if (length(check_all$SID != 0)) {
  print("ERROR: Participant doesn't have enough trials in task")
} else {
  print("All participants have enough task trials")
}

#exclude any kids who missed manual coding
all.data %<>%
  mutate(Exclude_task = ifelse(SID %in% exclude_wppsi_SIDs, 1, as.integer(as.character(Exclude_task))))
```

##Excluded trials
Trials where a participant gave no response were excluded from analysis.
```{r}
#How many trials are excluded from each task
all.data %>%
  filter(Exclude_trial == 1)%>%
  group_by(Task, Exclude_trial_reason)%>%
  summarise(n = n())

all.data %<>%
  filter(Exclude_trial != 1)

#how many trials do we have for each task?
all.data %>%
  filter(Task == "SF" | 
         Task == "NN")%>%
  group_by(Language, Task, Task_item)%>%
  summarise(n = n())
```

##Exclude practice trials for SF and NN
Practice trials are excluded from analysis. 
```{r}
#how many kids failed the practice trials on these tasks?
all.data %>%
  filter(Task == "SF" | Task == "NN")%>%
  filter(Task_item == "1", 
         Correct == 0)%>%
  group_by(Language, Task)%>%
  summarise(n = n())

#Get kids who failed NN for highest contiguous
failed.nn <- all.data %>%
  filter(Task == "NN", 
         Correct == 0, 
         Trial_number == "Training")

failed.nn.sids <- unique(as.vector(failed.nn$SID))

#exclude practice trials
all.data %<>%
  filter(Trial_number != "Training")

```

#Sanity check - does anyone have crazy low number of trials?
```{r}
#total number of possible trials = 4 + 12 + 12 + 3 = 31
all.data %>%
  group_by(SID)%>%
  summarise(n = n())%>%
  mutate(prop = n/31)%>%
  filter(prop < .8)
##Decision - For Indian English, excluding kids who do not have NN, keeping kids with low number of trials due to low SF

```

---

#Classifications
##CP or subset-knower
Children are classified as subset-knowers if they got all 4 numbers requested correct (on either the first or the second try).
```{r}
cp.df <- all.data %>%
  filter(Task == "GiveN")%>%
  group_by(SID)%>%
  summarise(sum_correct = sum(Correct, na.rm = TRUE))%>%
  mutate(Knower.level = ifelse(sum_correct >= 4, "CP-knower", "Subset-knower"))%>%
  dplyr::select(-sum_correct)

all.data <- full_join(all.data, cp.df, by = "SID")

#manual update, one participant only made it through one trial of 
```

##WPPSI score
WPPSI score is just the total correct items by participant, excluding feedback/training trials
```{r}
 #get sum per SID, add to sf and wcn for CROSS-LINGUISTIC models
 wppsi.sid <- all.data %>%
  filter(Task == "WPPSI")%>%
  filter(Exclude_trial != 1)%>%
  mutate(Trial_number = factor(Trial_number))%>%
  filter(Trial_number != "sample item A", #remove training trials
         Trial_number != "sample item B", 
         Trial_number != "Sample item A", 
         Trial_number != '1', 
         Trial_number != '2', 
         Trial_number != '7', 
        Trial_number != '8')%>%
   group_by(SID)%>%
   summarise(sum_wppsi = sum(Correct, na.rm = TRUE))

all.data <- full_join(all.data, wppsi.sid, by = "SID")
```


##Productivity
Children are classified as productive if they are able to count at least 2 decades higher than an error without making more than 3 errors along the way, OR if they are able to count to 140 without making an error.
```{r}
hc.df %<>%
  mutate(Last_successful = ifelse(Last_successful == "Is quiet", "IDK", Last_successful))%>%
  filter(Exclude != 1)%>%
  filter(SID != "CH-VC-1", 
         SID != "SR-8-MP", 
         SID != "CH-MV-14", 
         SID != 'GV-21-SB', 
         SID != 'RT09', 
         SID != 'SK-M-4-GJ')#excluding these kids because they break my productivity code

hc <- hc.df %>% 
  dplyr::select(SID, Last_successful, IHC, FHC, Language) %>%
  mutate_at(c('Last_successful','IHC','FHC'),
            function(col) as.integer(str_replace_all(col,'\\D',''))) %>% # some of these included '?', so i remove any char thats not a digit
  mutate(Last_successful = ifelse(is.na(Last_successful), 140, Last_successful))%>%
  mutate(SID = as.character(SID))

# 
# function for determining productivity
is.productive = function(subject){
  # takes as input the data for a single subject
  # RULES:
  # - counts to 120 unaided = productive
  # - after making first error, counts >= 20 higher, with no more than 3 errors on way
  if(subject$IHC[1] >= 140){
    # if they get to 140 on first try, = productive
    return("Productive")
  } else if(subject$FHC[1] == 140 & nrow(subject) < 4) {
    return("Productive")
  } else if(subject$FHC[1] < 140 & nrow(subject) == 1 
            & subject$FHC[1] == subject$IHC[1]) {
    return("Nonproductive")
  } else if((subject$FHC[1] - subject$IHC[1]) >= 20){
    # if their final is >= 20 larger than their intial...
    if(nrow(subject) < 4){
      # and they've made 3 or fewer total errors, = productive
      return("Productive")
    } 
    else {
      for(i in 1:nrow(subject)){ # start at row 2
        # check if they ever made it >= 20 counts & <= 3 errors after an error
        runLength = 0 # they just made an error, so no post-error successes yet
        numErrors = 0 # first row was an error if it's not finalCount == 120
        prev = subject$Last_successful[i]
        for (j in i+1:nrow(subject)){ # from current row until end...
          numErrors = numErrors + 1 # new row means new error
          runLength = runLength + (subject$Last_successful[j] - prev)
          # ^ add difference between current count and last count to run length
          prev = subject$Last_successful[j] # update last count
          if(runLength >= 20 & numErrors < 4){
            # if at any point the productivity conditions are met...
            return("Productive") # = productive
          }
        }
      }
      # productivity conditions were never met (because we got to this point) so...
      return("Nonproductive") # != productive
    }
  } else {
    # highest is not >= 20 greater than initial
    return("Nonproductive")
  }
}
# 
#make function to run for all participants
unique_SIDs <- as.vector(unique(hc.df$SID))
# 
class_prod <- function(vector) {
  temp_data <- data.frame()
  for (i in vector) {
    prod.class <- data.frame(i, is.productive(subset(hc, SID == i)))
    # print(i) # for debugging
    names(prod.class) <- c("SID", "productive")
    prod.class %<>%
      mutate(SID = as.character(SID), 
             productive = as.character(productive))
    
    temp_data <- bind_rows(temp_data, prod.class)
  }
  temp_data %<>%
    mutate(productive = as.character(productive))
  return(temp_data)
}
# 

productive <- class_prod(unique_SIDs)

#manually add child who broke productivity code: CH-VC-1, IHC 20, FHC 56, nonproductive, 
#SR-8-MP, IHC = 19, FHC = 39, Nonproductive
#CH-MV-14, IHC = 48, FHC = 68, Nonproductive
#GV-21-SB, IHC = 20, FHC = 40, nonproductive
#RT09, IHC = 20, FHC = 43, Nonproductive
#SK-M-4-GJ, IHC = 20, FHC = 44, Nonproductive

hc %<>%
  dplyr::select(-Last_successful)

productive <- full_join(productive, hc, by = "SID")%>%
  distinct(SID, IHC, FHC, productive)%>%
  dplyr::rename(Productive = productive)

#manually add back in kids who break the code
productive <- rbind(productive, c('CH-VC-1', 'Nonproductive', 20, 56))
productive <- rbind(productive, c('SR-8-MP', 'Nonproductive', 19, 39))
productive <- rbind(productive, c('CH-MV-14', 'Nonproductive', 48, 68))
productive <- rbind(productive, c("GV-21-SB", 'Nonproductive', 20, 40))
productive <- rbind(productive, c('RT09', 'Nonproductive', 20, 43))
productive <- rbind(productive, c('SK-M-4-GJ', 'Nonproductive', 20, 44))

all.data <- full_join(all.data, productive, by = "SID")%>%
  dplyr::mutate(IHC = as.integer(IHC), 
         FHC = as.integer(FHC))%>%
  filter(!is.na(Productive))

 
# # for sanity checks - trying to make sure we're not leaving people out
# unique.sid <- all.data %>%
#   distinct(SID)
# 
# unique.hc <- hc.df %>%
#   distinct(SID)
# 
# tmp <- unique.sid %>%
#   filter(SID %!in% unique.hc$SID)
# 
# l <- unique.sid %>%
#   filter(SID %!in% tmp$SID)
# 
# 
# tmp <- unique.hc %>%
#   filter(SID %in% unique.sid$SID)
```


##Highest Contiguous NN
Highest Contiguous NN is a measure of productivity. This is the highest number for which a child was correct on the Next Number task, provided that all the previous numbers had also been correct.
```{r}
#get unique ids
unique.nn <- all.data %>%
  filter(Task == "NN")%>%
  droplevels() %>%
  distinct(SID)

unique.nn <- as.vector(unique.nn$SID)
nextnums <- as.vector(c(5, 7, 16, 24, 52, 71, 105, 107, 116, 224, 252, 271))

#this is a function that pulls out the largest number for which a participant had a correct consecutive
get_contiguous <- function(){
  contig <- data.frame()
  for (sub in unique.nn) {
    tmp <- all.data %>%
      filter(Task == "NN", 
             SID == sub, 
             Correct == 0)%>%
      mutate(Task_item = as.integer(as.character(Task_item)))%>%
      mutate(Task_item = sort(as.integer(as.character(Task_item))))
    if (length(tmp$SID) == 0) {
      highest_contig = 271
      sub_contig <- data.frame(sub, highest_contig)
       sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else if (sub %in% failed.nn.sids) {
      highest_contig = 0
      sub_contig <- data.frame(sub, highest_contig)
      sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else if (length(tmp$Task_item) > 0 & min(as.integer(as.character(tmp$Task_item))) == 5) {
      highest_contig = 1
      sub_contig <- data.frame(sub, highest_contig)
       sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    } else {
      min.nn <- min(as.integer(as.character(tmp$Task_item)))
      prev_correct <- nextnums[nextnums < min.nn]
      highest_contig <- as.character(max(prev_correct))
    
      sub_contig <- data.frame(sub,
                             highest_contig)
      sub_contig %<>%
        mutate(sub = as.character(sub),
                highest_contig = as.character(highest_contig))
      contig <- bind_rows(contig, sub_contig)
    }
  }
  contig %<>%
    mutate(highest_contig = as.character(highest_contig))
  return(contig)
}

highest_contiguous_nn <- get_contiguous()%>%
  dplyr::rename(SID = sub)

#add this to df 
all.data <- full_join(all.data, highest_contiguous_nn, by = "SID")

all.data %<>%
  mutate(highest_contig = as.integer(highest_contig))

# #how many kids don't have a highest contiguous NN? 
# all.data %>%
#   filter(is.na(Language))
#   filter(is.na(highest_contig))%>%
#   distinct(Language, SID)%>%
#   group_by(Language)%>%
#   summarise(n = n())%>%
#   kable()

#Check - does anyone have NA for HCNN? Yes, these are kids who were excluded from NN
all.data %>%
  filter(is.na(highest_contig))
```

##Within/outside count range
Each trial on the Unit or WCN task was determined to be either within or outside a child's unprompted count range (IHC).
```{r}
all.data %<>%
  mutate(count_range = ifelse((Task == "SF" | Task == "NN") & as.numeric(as.character(Task_item)) <= IHC, "Within", "Outside"))
```

##Productivity gradient
```{r}
all.data %<>%
  mutate(delta.hc = FHC-IHC, 
         prod.gradient = delta.hc/(140-IHC), 
         prod.gradient = ifelse(IHC == 140, 1, as.numeric(prod.gradient)))
```

---

##Memory checks - NAs to 1
Some participants have NAs rather than 1 for their first memory check. Also, if first mem check is a 0, and second is NA, change that second one to 1.
```{r}
all.data %<>%
  mutate(Task = factor(Task))%>%
  mutate(Mem_check_1 = ifelse(Task == "SF" & is.na(Mem_check_1), 1, Mem_check_1))%>%
  mutate(Mem_check_2 = ifelse(Task == "SF" & is.na(Mem_check_2) & Mem_check_1 == 0, 1, Mem_check_2))
```

---

#Demographics
```{r, warning = FALSE}
all.data %<>%
  filter(!is.na(Language))

#demos by age group, Language
all.data %>%
  distinct(SID, Language, Agegroup, Age)%>%
  group_by(Language, Agegroup)%>%
  summarise(n = n(), 
            Mean_age = round(mean(Age, na.rm = TRUE), 2), 
            SD_age = round(sd(Age, na.rm = TRUE), 2))%>%
  group_by(Language)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)

#demos by Language
all.data %>%
  distinct(SID, Language, Age)%>%
  group_by(Language)%>%
  summarise(n = n(),
            Mean_age = round(mean(Age, na.rm = TRUE), 2), 
            SD_age = round(sd(Age, na.rm = TRUE), 2), 
            med_age = round(median(Age, na.rm = TRUE), 2))%>%
  kable()

#sex
all.data %>%
  distinct(SID, Age, Language, Sex)%>%
  group_by(Language, Sex)%>%
  summarise(n = n(), 
            mean_age = round(mean(Age),2), 
            sd_age = round(sd(Age),2))%>%
  group_by(Language)%>%
  mutate(total.n = sum(n))%>%
  kable()

#KL by language
all.data %>%
  distinct(SID, Language, Age, Productive, Knower.level)%>%
  group_by(Language, Knower.level)%>%
  summarise(n = n())
  
#histogram of age
all.data %>%
  distinct(SID, Language, Age)%>%
ggplot(aes(x = Age, fill = Language)) +
  geom_histogram(binwidth = .5, colour = "black") +
  theme_bw() + 
  facet_wrap(~Language) + 
  theme(panel.grid.minor = element_blank()) +
  scale_x_continuous(breaks = c(3.5, 4, 4.5, 5, 5.5, 6, 6.5)) +
  scale_fill_brewer(palette = "Dark2") + 
  guides(fill = FALSE) +
  labs(y = "Count", title = "Number of children in age bin by language")
```

---
#Highest Count descriptives
Productivity, prompts, errors

##Productivity descriptives by language

###IHC, FHC by language, productivity
```{r}
productivity.pal <- c("#666666","#00b8e6")
#IHC, FHC by language, productiviity
all.data %>%
  filter(!is.na(Language))%>%
  distinct(SID, Age, Productive, Language, IHC, FHC)%>%
  group_by(Language, Productive)%>%
  summarise(n = n(),
            mean_IHC = round(mean(IHC)), 
            sd_IHC = round(sd(IHC), 2), 
            median_IHC = round(median(IHC)), 
            mean_FHC = round(mean(FHC)), 
            sd_FHC = round(sd(FHC), 2), 
            median_FHC = round(median(FHC)))%>%
  kable()

```

###Productivity gradient
```{r}
#what about productivity gradient?
all.data %>%
  distinct(SID, Age, Productive, Language, prod.gradient, delta.hc)%>%
  group_by(Language, Productive)%>%
  summarise(n =n(), 
            mean_prod.gradient = mean(prod.gradient), 
            sd_prod.gradient = sd(prod.gradient), 
            mean_delta.hc = mean(delta.hc), 
            sd_delta.hc = sd(delta.hc))%>%
  kable()
```

###Mean IHC/FHC overall by language
```{r}
#overall mean ihc/fhc by language
all.data %>%
  distinct(SID, Age, Language, IHC, FHC)%>%
  group_by(Language)%>%
  summarise(mean_IHC = mean(IHC), 
           sd_IHC = sd(IHC), 
           mean_FHC = mean(FHC), 
           sd_FHC = sd(FHC))
```

###Prompts by productivity and language
```{r}
#how many prompts do productive and nonproductive counters need? and what kind of errors do they make?
#bind productive and hc.df 
productive %<>% 
  dplyr::select(SID, Productive)

error.freq <- full_join(hc.df, productive, by = "SID")%>%
  filter(!is.na(Last_successful))%>%
  mutate(Error_type = ifelse((Language == "Cantonese" | 
                                Language == "Slovenian" |
                                Language == "English (India)" |
                                Language == "English (US)") & Last_successful %% 10 == 9 , "Decade end", 
                             ifelse(Last_successful %% 10 == 0, "Decade beginning",
                                    ifelse(Last_successful %% 10 == 8 & (Language == "Hindi" | Language == "Gujarati"), "Hindi/Gujarati pre-decade transition", "Mid-decade"))))

#mean number of prompts by Language, productivity
mean_prompts.type <- error.freq %>%
  group_by(Language, Error_type, Productive)%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

#all productive errors grouped together
mean_prompts.type.prod <- error.freq %>%
  group_by(Language, Error_type, Productive)%>%
  filter(Productive == "Productive")%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

#all nonproductive errors grouped together
mean_prompts.type.nonprod <- error.freq %>%
  group_by(Language, Error_type, Productive)%>%
  filter(Productive == "Nonproductive")%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
            prop = n/total.n)

```

###Analysis: Are there significantly more productive counters by language?
```{r}
##HK/SLO/US
#Cantonese v. English & Slovenian
class.data <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Cantonese" | 
           Language == "Slovenian")%>%
  distinct(SID, Productive, Language)%>%
  mutate(Productive = factor(Productive))
  

prod.lang <- glm(Productive ~ Language, family = "binomial", data = class.data)
summary(prod.lang)

#english v. slovenian
class.data <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Cantonese" | 
           Language == "Slovenian")%>%
  distinct(SID, Productive, Language)%>%
  mutate(Productive = factor(Productive), 
         Language = factor(Language, levels = c("Slovenian", "Cantonese", "English (US)")))
  

prod.lang <- glm(Productive ~ Language, family = "binomial", data = class.data)
summary(prod.lang)

##INDIA
##English v. Hindi/Gujarati
##Indian english
class.data <- all.data %>%
  filter(Language == "English (India)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  distinct(SID, Productive, Language)%>%
  mutate(Productive = factor(Productive), 
         Language = factor(Language, levels = c("English (India)", "Hindi", "Gujarati")))
  

prod.lang.ind.eng <- glm(Productive ~ Language, family = "binomial", data = class.data)
summary(prod.lang.ind.eng)

##US English
class.data <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  distinct(SID, Productive, Language)%>%
  mutate(Productive = factor(Productive), 
         Language = factor(Language, levels = c("English (US)", "Hindi", "Gujarati")))
  

prod.lang.us.eng <- glm(Productive ~ Language, family = "binomial", data = class.data)
summary(prod.lang.us.eng)
```

###Where are errors happening?
```{r}
error.freq.decade <- error.freq %>%
  mutate(error.decade = ifelse(Last_successful < 10, 0, 
                               ifelse(Last_successful >= 10 & Last_successful < 20, 10, 
                                      ifelse(Last_successful >= 20 & Last_successful < 30, 20, 
                                             ifelse(Last_successful >= 30 & Last_successful < 40, 30, 
                                                    ifelse(Last_successful >=40 & Last_successful < 50, 40, 
                                                           ifelse(Last_successful >= 50 & Last_successful < 60, 50, 
                                                                  ifelse(Last_successful >= 60 & Last_successful < 70, 60, 
                                                                         ifelse(Last_successful >= 70 & Last_successful < 80, 70, 
                                                                                ifelse(Last_successful >= 80 & Last_successful < 90, 80, 
                                                                                       ifelse(Last_successful >= 90 & Last_successful < 100, 90, 
                                                                                              ifelse(Last_successful >= 100 & Last_successful < 110, 100, 
                                                                                                     ifelse(Last_successful >= 110 & Last_successful < 120, 110, 
                                                                                                            ifelse(Last_successful >= 120 & Last_successful < 130, 120,130)))))))))))))) %>%
  mutate(error.base = (error.decade - Last_successful) * -1, 
         error.base = ifelse(Last_successful == 140, 0, as.numeric(error.base)))


##Error by decade
##HK/SLO/US
error.freq.decade %>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian")%>%
  mutate(Language = factor(Language, levels = c("English (US)", "Slovenian", "Cantonese")), 
         Productive = factor(Productive, levels = c("Productive", "Nonproductive"))) %>%
  mutate(error.decade = factor(error.decade, levels = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 
                                                        90, 100, 110, 120, 130)),
         error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.decade)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  mutate(n = ifelse(is.na(n), 0, as.numeric(n)))%>%
  ggplot(aes(x = error.decade, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 2.5) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 10) + 
  labs(x = "Decade of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  facet_grid(rows = vars(Productive))

##INDIA
error.freq.decade %>%
  filter(Language == "Hindi" | 
           Language == "English (India)" |
           Language == "English (US)" |
           Language == "Gujarati")%>%
  mutate(Language = factor(Language, levels = c("English (US)", "English (India)", "Gujarati", "Hindi")), 
         Productive = factor(Productive, levels = c("Productive", "Nonproductive"))) %>%
  mutate(error.decade = factor(error.decade, levels = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 
                                                        90, 100, 110, 120, 130)),
         error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.decade)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  ggplot(aes(x = error.decade, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 2.5) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 10) + 
  labs(x = "Decade of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  facet_grid(rows = vars(Productive))

###Error by unit
##HK/SLO/US
error.freq.decade %>%
  filter(Last_successful <= 140)%>% #filter out trials where kid kept going beyond 140
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian")%>%
  mutate(Language = factor(Language, levels = c("English (US)", "Slovenian", "Cantonese")), 
         Productive = factor(Productive, levels = c("Productive", "Nonproductive"))) %>%
  mutate(error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.base)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  mutate(n = ifelse(is.na(n), 0, as.numeric(n)))%>%
  ggplot(aes(x = error.base, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 2.5) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 10) + 
  labs(x = "Unit of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  facet_grid(rows = vars(Productive))

##India
error.freq.decade %>%
  filter(Last_successful <= 140)%>% #filter out trials where kid kept going beyond 140
  filter(Language == "Hindi" | 
           Language == "English (US)" |
           Language == "English (India)" |
           Language == "Gujarati")%>%
  mutate(Language = factor(Language, levels = c("English (US)", "English (India)", "Gujarati", "Hindi")), 
         Productive = factor(Productive, levels = c("Productive", "Nonproductive"))) %>%
  mutate(error.base = factor(error.base))%>%
  mutate(Lang.prod = paste0(as.character(Language), " ", as.character(Productive), collapse = NULL))%>%
  group_by(Language, Productive, error.base)%>%
  summarise(n = n())%>% 
  group_by(Language, Productive)%>%
  mutate(total.n = sum(n), 
         prop = n/total.n)%>%
  mutate(n = ifelse(is.na(n), 0, as.numeric(n)))%>%
  ggplot(aes(x = error.base, y = Language)) +
  geom_tile(aes(fill = round(prop, 2))) +
  geom_text(aes(label = as.character(round(prop, 2))), 
            size = 2.5) +
  coord_equal() +
  scale_fill_gradient2(low = "white", high = "red", "Proportion") + 
  theme_bw(base_size = 10) + 
  labs(x = "Unit of error") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = "bottom", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  facet_grid(rows = vars(Productive))
```

###Sanity check - does anyone have more than 3 errors within a decade?
```{r}
check <- error.freq.decade %>%
  group_by(SID, error.decade)%>%
  summarise(n = n())%>%
  filter(n > 3)

#4 participants, but these are language switches did not receive a prompt
```

###How many participants used all 14 prompts?
```{r}
hc.df %>%
  group_by(SID, Language)%>%
  filter(Last_successful != 140)%>%
  summarise(n = n())%>%
  filter(n >= 10)%>%
  kable()

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

#HK/SLO/US
hc.df %>%
  group_by(SID, Language)%>%
  filter(Last_successful != 140, 
         Language == "Cantonese" | 
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  summarise(n = n())%>%
  group_by()%>%
  summarise(mean = mean(n), 
            median = median(n), 
            mode = getmode(n))
```

###How many errors on average by language?
```{r}
error.freq %>%
  filter(Last_successful != 140)%>%
  group_by(SID, Language, Productive)%>%
  summarise(n = n())%>%
  group_by(Language, Productive)%>%
  summarise(mean_prompts = round(mean(n, na.rm = TRUE), 2),
            sd_prompts = round(sd(n, na.rm = TRUE), 2))%>%
  kable()
```

---
#Highest Contiguous Next Number
##HCNN by each language
```{r}
india.pal <- c("#E7298A","#66A61E","#E6AB02", "#D95F02")

#HK/SLO/US
all.data %>%
  filter(Language == "English (US)" |
           Language == "Cantonese" |
           Language == "Slovenian")%>%
  distinct(SID, highest_contig, Language, Productive)%>%
  group_by(Language, Productive)%>%
  summarise(mean_hcnn = mean(highest_contig, na.rm = TRUE),
            sd_hcnn = sd(highest_contig, na.rm = TRUE), 
            median_hcnn = sd(highest_contig, na.rm = TRUE))%>%
  kable()

#India
all.data %>%
  filter(!is.na(highest_contig))%>%
  filter(Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, highest_contig, Language, Productive)%>% 
  group_by(Language, Productive)%>%
  summarise(mean_hcnn = mean(highest_contig, na.rm = TRUE),
            sd_hcnn = sd(highest_contig, na.rm = TRUE), 
            median_hcnn = sd(highest_contig, na.rm = TRUE))%>%
  kable()
```

###Analysis: Do transparent languages allow nonproductive counters to generate higher HCNNs?
No significant difference in HCNN for nonproductive counters for Cantonese in comparison to English or Slovenian. US English nonproductive counters have significantly higher HCNNs than Hindi or Gujarati. This difference holds for Indian English speakers.
```{r}
#lm predicting hcnn from language for nonproductive counters
#HK/SLO/US
hcnn.hk <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Cantonese" |
           Language == "Slovenian")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Nonproductive")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.hk <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.hk)
summary(hcnn.nonprod.hk)

#india - US English
hcnn.ind <- all.data %>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Nonproductive")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.india <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.ind)
summary(hcnn.nonprod.india)

#india - Indian English
hcnn.ind <- all.data %>%
  filter(Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  distinct(SID, highest_contig, Language, Age, sum_wppsi, Productive)%>%
  filter(!is.na(highest_contig), 
         Productive == "Nonproductive")%>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))

hcnn.nonprod.india <- lm(highest_contig ~ Language + Age + wppsi.c, data = hcnn.ind)
summary(hcnn.nonprod.india)
```

---

#Task visualizations
##Highest count
###Histogram Initial and Final Highest Count

```{r}
unique.hc.data <- all.data %>%
  distinct(SID, IHC, FHC, Productive, Language, Dataset)%>%
  gather(IHC_FHC,highest_count, IHC:FHC)%>%
  mutate(highest_count = as.integer(highest_count), 
         IHC_FHC = factor(IHC_FHC, levels = c("IHC", "FHC"), 
                          labels = c("Initial Highest Count", "Final Highest Count")))

# #Initial/Final, HK/SLO/US
# unique.hc.data %>%
#   filter(Language == "English (US)" |
#            Language == "Cantonese" |
#            Language == "Slovenian")%>%
#   mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)")))%>%
# ggplot(aes(x=highest_count, fill=Productive)) + 
#   geom_histogram(binwidth = 10, colour = "black") +
#   theme_bw(base_size = 10)+
#   facet_grid(IHC_FHC~Language) +
#   scale_x_continuous(breaks = seq(0, 140, 10))+
#   scale_fill_manual(values = productivity.pal) +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1), 
#         panel.grid.minor = element_blank(), 
#         legend.title = element_blank())+
#   theme(legend.position = "bottom") + 
#   labs(x = "Highest count", y = "Frequency")
# 
# #Initial/Final, India
# unique.hc.data %>%
#   filter(Language == "English (India)"|
#            Language == "English (US)" |
#            Language == "Hindi" | 
#            Language == "Gujarati")%>%
#   mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
# ggplot(aes(x=highest_count, fill=Productive)) + 
#   geom_histogram(binwidth = 10, colour = "black") +
#   theme_bw(base_size = 10)+
#   facet_grid(IHC_FHC~Language) +
#   scale_x_continuous(breaks = seq(0, 140, 10))+
#   scale_fill_manual(values = productivity.pal) +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1), 
#         panel.grid.minor = element_blank(), 
#         legend.title = element_blank()) +
#   theme(legend.position = "bottom") + 
#   labs(x = "Highest count", y = "Frequency")

```

###Analysis: Are IHC distributions bimodal?
Diptests for IHC, collapsing over Productive and Nonproductive counters. Cantonese, US English, and Indian English are all significantly bimodal (*p*s < .0001), while Slovenian, Hindi, and Gujarati are unimodal (although Slovenian *p* = .064). 
```{r}
initial_final <- all.data %>%
  filter(!is.na(Productive))%>%
  distinct(SID, Language, IHC, FHC, Productive, Dataset, prod.gradient, delta.hc)%>%
  mutate(IHC = as.numeric(IHC), 
         FHC = as.numeric(FHC))

library(diptest)

#Cantonese
dip.test(subset(initial_final, Language == "Cantonese")$IHC)

#Slovenian
dip.test(subset(initial_final, Language == "Slovenian")$IHC)

#Hindi
dip.test(subset(initial_final, Language == "Hindi")$IHC)

#Gujarati
dip.test(subset(initial_final, Language == "Gujarati")$IHC)

#Indian English
dip.test(subset(initial_final, Language == "English (India)")$IHC)

#US English
dip.test(subset(initial_final, Language == "English (US)")$IHC)
```

##Scatterplot of IHC and FHC - now with density distributions
```{r}
library("cowplot")
library('ggjoy')
library('ggstance')

####HK#####
hk_initial <- initial_final %>%
  filter(Language == "Cantonese")

pmain <- ggplot(hk_initial, aes(x = IHC, y = FHC, color = Productive)) + 
  geom_point(size = 1.2) + 
  geom_jitter() + 
  theme(legend.position = c(.5, 0.2), 
        legend.title = element_blank()) + 
  scale_color_manual(values = productivity.pal) + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Cantonese")

xdens <- axis_canvas(pmain, axis = "x") + 
  geom_ridgeline(data = hk_initial, aes(x = IHC, y = 0, height=..density.., 
                                        fill = Productive), 
                 stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

ydens <- axis_canvas(pmain, axis = "y") + 
  geom_vridgeline(data = hk_initial, aes(y = FHC, x = 0, width=..density.., 
                                        fill = Productive), 
                 stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

p1 <- insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
ggdraw(p2)

####SLO####
slo_initial <- initial_final %>%
  filter(Language == "Slovenian")

pmain.slo <- ggplot(slo_initial, aes(x = IHC, y = FHC, color = Productive)) + 
  geom_point(size = 1.2) + 
  theme(legend.position = c(.5, 0.2), 
        legend.title = element_blank()) + 
  viridis::scale_color_viridis(discrete = TRUE, option = "C") + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Slovenian")

xdens.slo <- axis_canvas(pmain.slo, axis = "x") + 
  geom_ridgeline(data = slo_initial, aes(x = IHC, y = 0, height=..density.., 
                                        fill = Productive), 
                 stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  viridis::scale_fill_viridis(discrete = TRUE, option = "C")

ydens.slo <- axis_canvas(pmain.slo, axis = "y") + 
  geom_vridgeline(data = slo_initial, aes(y = FHC, x = 0, width=..density.., 
                                        fill = Productive), 
                 stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  viridis::scale_fill_viridis(discrete = TRUE, option = "C")

p3 <- insert_xaxis_grob(pmain.slo, xdens.slo, grid::unit(.2, "null"), position = "top")
p4 <- insert_yaxis_grob(p3, ydens.slo, grid::unit(.2, "null"), position = "right")
ggdraw(p4)


#####US####
us_initial <- initial_final %>%
  filter(Language == "English (US)")

pmain.us <- ggplot(us_initial, aes(x = IHC, y = FHC, color = Productive)) + 
  geom_point(size = 1.2) + 
  geom_jitter() + 
  theme(legend.position = c(.5, 0.2), 
        legend.title = element_blank()) + 
  scale_color_manual(values = productivity.pal) + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "English")

xdens.us <- axis_canvas(pmain, axis = "x") + 
  geom_ridgeline(data = us_initial, aes(x = IHC, y = 0, height=..density.., 
                                        fill = Productive), 
                 stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

ydens.us <- axis_canvas(pmain, axis = "y") + 
  geom_vridgeline(data = us_initial, aes(y = FHC, x = 0, width=..density.., 
                                        fill = Productive), 
                 stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

p5 <- insert_xaxis_grob(pmain.us, xdens.us, grid::unit(.2, "null"), position = "top")
p6 <- insert_yaxis_grob(p5, ydens.us, grid::unit(.2, "null"), position = "right")
ggdraw(p6)


####HINDI####
hindi_initial <- initial_final %>%
  filter(Language == "Hindi")

pmain.hindi <- ggplot(hindi_initial, aes(x = IHC, y = FHC, color = Productive)) + 
  geom_point(size = 1.2) + 
  geom_jitter() + 
  theme(legend.position = c(.5, 0.2), 
        legend.title = element_blank()) + 
  scale_color_manual(values = productivity.pal) + 
  coord_fixed() + 
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  scale_y_continuous(breaks = seq(0, 140, 10)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Initial Highest Count", y = "Final Highest Count", 
       title = "Hindi")

xdens.hindi <- axis_canvas(pmain, axis = "x") + 
  geom_ridgeline(data = hindi_initial, aes(x = IHC, y = 0, height=..density.., 
                                        fill = Productive), 
                 stat = 'xdensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

ydens.hindi <- axis_canvas(pmain, axis = "y") + 
  geom_vridgeline(data = hindi_initial, aes(y = FHC, x = 0, width=..density.., 
                                        fill = Productive), 
                 stat = 'ydensity', alpha = .5, size = .2, trim = FALSE) + 
  scale_fill_manual(values = productivity.pal)

p7 <- insert_xaxis_grob(pmain.hindi, xdens.us, grid::unit(.2, "null"), position = "top")
p8 <- insert_yaxis_grob(p7, ydens.hindi, grid::unit(.2, "null"), position = "right")
ggdraw(p8)
```

###IHC/FHC scatter, HK/SLO/US
```{r}
# initial_final %>%
#   filter(Language == "English (US)" |
#            Language == "Cantonese" |
#            Language == "Slovenian")%>%
#   mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)")))%>%
# ggplot(aes(x = IHC, y = FHC, 
#                           color = Productive)) +
#   geom_point(size = 1) + geom_jitter(width = .1) +
#   labs(x = "Initial highest count", y = "Final highest count", 
#                       color = "", title = "") +
#   theme_bw(base_size = 12) + 
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   scale_y_continuous(breaks = seq(0, 140, 10)) + 
#   theme(panel.grid.minor = element_blank(), 
#         legend.position = "bottom", 
#         legend.text = element_text(size = 8)) + 
#   facet_wrap(~Language, ncol = 3) + 
#   scale_colour_manual(values = productivity.pal) +
#   theme(legend.position = "bottom") + 
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# #IHC/FHC scatter, India
# initial_final %>%
#   filter(Language == "English (US)" |
#            Language == "English (India)" |
#            Language == "Hindi" |
#            Language == "Gujarati")%>%
#    mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (US)", "English (India)")))%>%
# ggplot(aes(x = IHC, y = FHC, 
#                           color = Productive)) +
#   geom_point(size = 1) + geom_jitter(width = .1) +
#   labs(x = "Initial highest count", y = "Final highest count", 
#                       color = "", title = "") +
#   theme_bw(base_size = 12) + 
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   scale_y_continuous(breaks = seq(0, 140, 10)) + 
#   theme(panel.grid.minor = element_blank(), 
#         legend.position = "bottom", 
#         legend.text = element_text(size = 8)) + 
#   facet_wrap(~Language, ncol = 4) + 
#   scale_colour_manual(values = productivity.pal) +
#   theme(legend.position = "bottom") + 
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


###Analysis: Do IHCs differ by language? - Gaussian Mixture Modeling
####Test for multiple modes, quantify each mode
First, get density of IHC in each language
```{r}
initial_final %>%
  dplyr::select(IHC, Language)%>%
  filter(Language == "Hindi" | 
           Language == "Gujarati" |
           Language == "English (India)" | 
           Language == "English (US)")%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  ggplot(aes(x = IHC, colour= Language)) + geom_density(adjust = .5, size = 1.5) + 
  scale_x_continuous(breaks = seq(0, 140, 10)) +
  theme_bw(base_size = 10) +
  theme(legend.position = "right", 
        panel.grid.minor = element_blank()) +
  scale_colour_manual(values = india.pal) +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Initial Highest Count", y = "Density")
```

##Get number of clusters (modes) for each language, mean and variance of each cluster
###Cantonese
```{r}
library(mclust)
#Cantonese
cant.df <- initial_final %>%
  filter(Language == "Cantonese")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(cant.df)

mod.cant <- Mclust(cant.df, x = BIC)
summary(mod.cant, parameters = TRUE)

plot(mod.cant, what = "classification")
```

###Slovenian
```{r}
#Slovenian
slo.df <- initial_final %>%
  filter(Language == "Slovenian")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(slo.df)

mod.slo <- Mclust(slo.df, x = BIC)
summary(mod.slo, parameters = TRUE)

plot(mod.slo, what = "classification")
```

###US English
```{r}
#English
us.df <- initial_final %>%
  filter(Language == "English (US)")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(us.df)

mod.us <- Mclust(us.df, x = BIC)
summary(mod.us, parameters = TRUE)

plot(mod.us, what = "classification")
```

###Hindi
```{r}
#Hindi
hindi.df <- initial_final %>%
  filter(Language == "Hindi")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(hindi.df)

mod.hindi <- Mclust(hindi.df, x = BIC)
summary(mod.hindi, parameters = TRUE)

plot(mod.hindi, what = "classification")
```

###Gujarati
```{r}
#Gujarati
gujarati.df <- initial_final %>%
  filter(Language == "Gujarati")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(gujarati.df)

mod.gujarati <- Mclust(gujarati.df, x = BIC)
summary(mod.gujarati, parameters = TRUE)

plot(mod.gujarati, what = "classification")
```

###Indian English
```{r}
#Indian English
ind.eng.df <- initial_final %>%
  filter(Language == "English (India)")%>%
  dplyr::select(IHC)

BIC <- mclustBIC(ind.eng.df)

mod.ind.eng <- Mclust(ind.eng.df, x = BIC)
summary(mod.ind.eng, parameters = TRUE)

plot(mod.ind.eng, what = "classification")
```

####Identifying clusters from IHC-FHC by language - for predicting Unit from cluster membership
```{r}
#make a function to identify cluster membership
prod.clust <- function(df) {
  languages <- c("English (US)", "English (India)", "Hindi", "Gujarati", "Slovenian", "Cantonese")
  
  all.clust <- data.frame()
  for (lang in languages) {
    #filter down to correct language
    tmp.df <- df %>%
      filter(Language == lang)%>%
      distinct(SID, IHC, FHC)%>%
      dplyr::select(-SID)
    
    #run cluster analysis
    BIC <- mclustBIC(tmp.df)
    tmp.mclust <- Mclust(tmp.df, x = BIC)
    tmp.df$CLUST <- tmp.mclust$classification
    tmp.df$id <- row.names(tmp.df)
    
    #add SIDs back in
    tmp.sids <- df %>%
      filter(Language == lang)%>%
      distinct(SID, IHC, FHC)
    
    tmp.sids$id <- row.names(tmp.sids)
    
    tmp.all <- right_join(tmp.sids, tmp.df, by = "id")
    tmp.all$Language <- lang
    
    #add to large df to get back at end
    all.clust <- bind_rows(all.clust, tmp.all)
  }
  return(all.clust)
}

clusters <- prod.clust(all.data)%>%
  dplyr::select(SID, IHC.x, FHC.x, CLUST, Language)%>%
  dplyr::rename(IHC = IHC.x, 
                FHC = FHC.x)

#add clusters to all.data
all.data <- full_join(all.data, clusters, by = "SID")

check <- all.data %>%
  filter(IHC.x != IHC.y |
           FHC.x != FHC.y) # all good

all.data %<>%
  dplyr::select(-IHC.y, -FHC.y, -Language.y)%>%
  dplyr::rename(IHC = IHC.x,
                FHC = FHC.x, 
                Language = Language.x)

```


---

##Unit Task
###How many kids failed the memory checks in each dataset by number
```{r}
#for SF
sf.df <- all.data %>%
  filter(Task == "SF")%>%
  mutate(mem_check_status = ifelse((Mem_check_1 == 1 & is.na(Mem_check_2)), "Needed_1_passed_1",
                                    ifelse((Mem_check_1 == 0 & Mem_check_2 == 0), "Needed_2_failed_2",
                                           ifelse((Mem_check_1 == 1 & Mem_check_2 == 1),
                                                  "unclear_pass1_pass2",
                                                  ifelse((Mem_check_1 == 1 & Mem_check_2 == 0),
                                                         "unclear_passed1_failed2",
                                                         ifelse((Mem_check_1 == 0 & Mem_check_2 == 1),
                                                                "failed1_passed2", "other"))))))

#by number
sf.mem.num.ms <- sf.df %>%
  mutate(Task_item = factor(Task_item, levels = c("5", '7', '16', '24', '52', '71', '105', '107', '116', '224', '252', '271')))%>%
  filter(!is.na(Productive))%>%
  group_by(Task_item, mem_check_status, Language, Productive)%>%
  summarise(n = n())

ggplot(subset(sf.mem.num.ms), aes(x = Task_item, y = n, fill = mem_check_status)) + 
  geom_bar(stat = "identity") + 
  facet_grid(~Language) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "bottom")
  labs(x = "Number queried", y = "Number of trials", title = "Memory checks by number in Unit Task")
```

###Overall performance by language, with individual productivity points
####HK/SLO/US
```{r}
india.pal <- c("#E7298A","#66A61E","#E6AB02", "#D95F02")

#HK/SLO/US
all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  group_by(SID, Language, Dataset, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black", 
               show.legend = FALSE) +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=2,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  guides(shape = "none") + 
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE)+
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  # ggtitle("Overall mean correct on Unit Task") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_brewer(palette = "Dark2", guide = "none") +
  scale_colour_manual(values = productivity.pal) +
  guides(size = "none")
```

####India
```{r}
#India
all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati" |
           Language == "English (India)") %>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  group_by(SID, Language, Dataset, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black", 
               show.legend = FALSE) +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=2,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  guides(shape = "none") + 
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE)+
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  # ggtitle("Overall mean correct on Unit Task") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_manual(values = india.pal, guide = "none") +
  scale_colour_manual(values = productivity.pal) +
  guides(size = "none")
```

###By language and productivity, with individual prod points
####HK/SLO/US
```{r}
##HK/SLO/US
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Task == "SF")%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  group_by(SID, Productive, Language, Dataset)%>%
  summarise(mean = mean(as.numeric(as.character(Correct), na.rm=TRUE)),
            sd = sd(as.numeric(as.character(Correct), na.rm=TRUE))) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  geom_violin(alpha = .1) +
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=1.5,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  ylab("Mean correct") + 
  xlab('') + 
  facet_grid(~Productive, scale = "free_x")+
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  # ggtitle("Performance on Unit Task by language, productivity") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_brewer(palette = "Dark2", guide = "none") +
  scale_colour_manual(values = productivity.pal) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

####India
```{r}
##India
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Task == "SF",
           Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati" |
           Language == "English (India)") %>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  group_by(SID, Productive, Language, Dataset)%>%
  summarise(mean = mean(as.numeric(as.character(Correct), na.rm=TRUE)),
            sd = sd(as.numeric(as.character(Correct), na.rm=TRUE))) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  geom_violin(alpha = .1) +
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=1.5,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  ylab("Mean correct") + 
  xlab('') + 
  facet_grid(~Productive, scale = "free_x")+
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  # ggtitle("Performance on Unit Task by language, productivity") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_manual(values = india.pal, guide = "none") +
  scale_colour_manual(values = productivity.pal) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

###By productivity and count range
####HK/SLO/US
```{r}
all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  mutate(count_range = factor(count_range, levels = c("Within", "Outside")))%>%
  group_by(SID, count_range, Language, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
ggplot(aes(x=count_range, y=mean, fill = Productive)) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .3, colour = "black") +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(position=position_jitterdodge(jitter.width = .1, 
                                           jitter.height = .1, 
                                           dodge.width = .9),
             aes(colour = Productive, group=Productive), 
             size=1.5,
             alpha = .9,
               show.legend=TRUE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE) +
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 10)) +
  ylim(0, 1.0) +
  scale_fill_manual(values = productivity.pal) + 
  scale_colour_manual(values = productivity.pal) +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.position = "bottom") +
  facet_grid(~Language) 
```

####India
```{r}
all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)" | 
           Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati") %>%
  mutate(count_range = factor(count_range, levels = c("Within", "Outside")))%>%
  group_by(SID, count_range, Language, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
ggplot(aes(x=count_range, y=mean, fill = Productive)) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .3, colour = "black") +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(position=position_jitterdodge(jitter.width = .1, 
                                           jitter.height = .1, 
                                           dodge.width = .9),
             aes(colour = Productive, group=Productive), 
             size=1.5,
             alpha = .9,
               show.legend=TRUE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE) +
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 10)) +
  ylim(0, 1.0) +
  scale_fill_manual(values = productivity.pal) + 
  scale_colour_manual(values = productivity.pal) +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.position = "bottom") +
  facet_grid(~Language) 
```

###Item performance by productivity, Unit Task 
```{r}
##Hk/SLO/US
all.data %>%
  filter(!is.na(Productive))%>%
   mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  filter(Task == "SF", 
         Dataset != "India")%>%
  mutate(Task_item = factor(Task_item, levels = c("5", "7", "16", "24", "52", "71", 
                                                  "105", "107", "116", "224", "252", "271")))%>%
  group_by(Productive, Task_item, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = Task_item, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 13) + 
  facet_grid(~Productive) +
  scale_colour_brewer(palette = "Dark2") +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Number queried", y = "Mean performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

##INDIA
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Task == "SF", 
         Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati" |
           Language == "English (India)")%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  mutate(Task_item = factor(Task_item, levels = c("5", "7", "16", "24", "52", "71", 
                                                  "105", "107", "116", "224", "252", "271")))%>%
  group_by(Productive, Task_item, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = Task_item, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 13) + 
  facet_grid(~Productive) +
  scale_colour_manual(values = india.pal) +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Number queried", y = "Mean performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

---

##WCN
###Overall performance by language
###HK/SLO/US
```{r}
all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  group_by(SID, Language, Dataset, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black", 
               show.legend = FALSE) +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=2,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  guides(shape = "none") + 
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE)+
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  ggtitle("Overall mean correct on NN Task") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_brewer(palette = "Dark2", guide = "none") +
  scale_colour_manual(values = productivity.pal) +
  guides(size = "none")
```

####India
```{r}
all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "English (India)" | 
           Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati") %>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  group_by(SID, Language, Dataset, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black", 
               show.legend = FALSE) +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=2,
             alpha = .9,
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  guides(shape = "none") + 
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE)+
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 13) + 
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_manual(values = india.pal, guide = "none") +
  scale_colour_manual(values = productivity.pal) +
  guides(size = "none")
```

###Performance by language, productivity
####HK/SLO/US
```{r}
all.data %>%
  filter(!is.na(Productive))%>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  filter(Task == "NN", 
         Dataset == "HK/SLO/US")%>%
  group_by(SID, Productive, Language, Dataset)%>%
  summarise(mean = mean(as.numeric(as.character(Correct), na.rm=TRUE)),
            sd = sd(as.numeric(as.character(Correct), na.rm=TRUE))) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  geom_violin(alpha = .1) +
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=1.5,
             alpha = .9, 
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  ylab("Mean correct") + 
  xlab('') + 
  facet_grid(~Productive, scale = "free_x")+
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_brewer(palette = "Dark2", guide = "none") +
  scale_colour_manual(values = productivity.pal) + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1))
```

####India
```{r}
#India
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Task == "NN", 
         Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati" |
           Language == "English (US)")%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  group_by(SID, Productive, Language, Dataset)%>%
  summarise(mean = mean(as.numeric(as.character(Correct), na.rm=TRUE)),
            sd = sd(as.numeric(as.character(Correct), na.rm=TRUE))) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  geom_violin(alpha = .1) +
  geom_point(aes(x = Language, y = mean, colour = Productive),
               position=position_jitter(width=0.15,height=0.02),
               size=1.5,
             alpha = .9, 
               show.legend=TRUE, 
             inherit.aes = FALSE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  ylab("Mean correct") + 
  xlab('') + 
  facet_grid(~Productive, scale = "free_x")+
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.title = element_blank()) +
  ylim(0, 1.0) +
  scale_fill_manual(values = india.pal, guide = "none") +
  scale_colour_manual(values = productivity.pal) + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1))
```


###By count range, language, productivity
###HK/SLO/US
```{r}
all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  mutate(count_range = factor(count_range, levels = c("Within", "Outside")))%>%
  group_by(SID, count_range, Language, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
ggplot(aes(x=count_range, y=mean, fill = Productive)) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .3, colour = "black") +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(position=position_jitterdodge(jitter.width = .1, 
                                           jitter.height = .1, 
                                           dodge.width = .9),
             aes(colour = Productive, group=Productive), 
             size=1.5,
             alpha = .9,
               show.legend=TRUE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE) +
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  ggtitle("Performance on Unit Task by language, within/outside IHC") +
  theme(text = element_text(size = 10)) +
  ylim(0, 1.0) +
  scale_fill_manual(values = productivity.pal) + 
  scale_colour_manual(values = productivity.pal) +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.position = "bottom") +
  facet_grid(~Language) 
```

####India
```{r}
all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (India)" | 
           Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati") %>%
  mutate(count_range = factor(count_range, levels = c("Within", "Outside")))%>%
  group_by(SID, count_range, Language, Productive)%>%
  summarise(mean = mean(as.numeric(as.character(Correct)), na.rm=TRUE),
            sd = sd(as.numeric(as.character(Correct)), na.rm=TRUE)) %>%
ggplot(aes(x=count_range, y=mean, fill = Productive)) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .3, colour = "black") +
  geom_violin(alpha = .1, 
              show.legend = FALSE)  + 
  geom_point(position=position_jitterdodge(jitter.width = .1, 
                                           jitter.height = .1, 
                                           dodge.width = .9),
             aes(colour = Productive, group=Productive), 
             size=1.5,
             alpha = .9,
               show.legend=TRUE) +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2, 
               show.legend = FALSE) +
  ylab("Mean correct") + 
  xlab('') + 
  theme_bw(base_size = 10) + 
  theme(legend.position = "bottom") +
  ggtitle("Performance on Unit Task by language, within/outside IHC") +
  theme(text = element_text(size = 10)) +
  ylim(0, 1.0) +
  scale_fill_manual(values = productivity.pal) + 
  scale_colour_manual(values = productivity.pal) +
  theme(text = element_text(size = 12), 
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank(), 
        legend.position = "bottom") +
  facet_grid(~Language) 
```

###By item, productivity
####HK/SLO/US
```{r}
##HK/SLO/US
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Language == "Cantonese" | 
           Language == "English (US)" |
           Language == "Slovenian") %>%
  filter(Task == "NN")%>%
  mutate(Task_item = factor(Task_item, levels = c("5", "7", "16", "24", "52", "71", 
                                                  "105", "107", "116", "224", "252", "271")))%>%
  group_by(Productive, Task_item, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = Task_item, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 13) + 
  facet_grid(~Productive) +
  scale_colour_brewer(palette = "Dark2") +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Number queried", y = "Mean performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

####India
```{r}
##INDIA
all.data %>%
  filter(!is.na(Productive))%>%
  filter(Task == "NN", 
         Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati" |
           Language == "English (India)")%>%
  mutate(Task_item = factor(Task_item, levels = c("5", "7", "16", "24", "52", "71", 
                                                  "105", "107", "116", "224", "252", "271")))%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  group_by(Productive, Task_item, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = Task_item, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 13) + 
  facet_grid(~Productive) +
  scale_colour_manual(values = india.pal) +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Number queried", y = "Mean performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

---

##WPPSI
###Histogram of scores by language
```{r, warning = FALSE}
##histogram of WPPSI scores
wppsi.ms <- all.data %>%
  filter(Task == "WPPSI")%>%
  filter(Trial_number != "Sample item B", 
         Trial_number != "Sample item A", 
         Trial_number != "1", 
         Trial_number != '2', 
         Trial_number != '7', 
         Trial_number != '8')%>%
  mutate(Trial_number = as.numeric(as.character(Trial_number)))%>%
  group_by(SID, Language)%>%
  summarise(sum_wppsi = sum(as.numeric(as.character(Correct)), na.rm = TRUE), 
            num_trials = n())
 
 ggplot(wppsi.ms, aes(x = sum_wppsi, fill = Language)) +
   geom_histogram(binwidth = 1, colour = "black") +
   theme_bw() + 
   facet_grid(~Language)+
   scale_fill_brewer(palette = "Dark2") + 
   labs(title = "Frequency of WPPSI scores by language") +
   guides(fill = FALSE)
```

###Mean scores by language
```{r}
##Mean WPPSI scores 
all.data %>%
  filter(!is.na(Productive))%>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  filter(Task == "WPPSI")%>%
  filter(Trial_number != "Sample item B", 
         Trial_number != "Sample item A", 
         Trial_number != "1", 
         Trial_number != '2', 
         Trial_number != '7', 
         Trial_number != '8')%>%
  mutate(Trial_number = as.numeric(as.character(Trial_number)))%>%
  group_by(SID, Language, Dataset)%>%
  summarise(mean = mean(sum_wppsi, na.rm=TRUE),
            sd = sd(sum_wppsi, na.rm=TRUE)) %>%
  ggplot(aes(x = Language, y = mean, fill=factor(Language))) +
  stat_summary(fun.y = mean, position = position_dodge(width = .95), 
                      geom="bar", alpha = .5, colour = "black") +
  stat_summary(fun.data = mean_se, geom="errorbar", 
               position = position_dodge(width=0.90), width = 0.2)+
  ylab("Mean WPPSI score") + 
  xlab('') + 
  theme_bw(base_size = 12) + 
  theme(legend.position = "none") +
  theme(text = element_text(size = 12),
        panel.grid.minor = element_blank(), 
        panel.grid.major = element_blank()) +
  geom_violin(alpha = .1) + 
  scale_fill_brewer(palette = "Dark2")+
  facet_grid(~Dataset, scale = "free_x")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
 
```


---

##Scatterplots of correlations
###Overall correlations
```{r}
tmp.data <- all.data %>%
  distinct(SID, Language, Age, FHC, IHC, highest_contig, sum_wppsi)

mean.unit <- all.data %>%
  filter(Task == "SF")%>%
  group_by(SID, Age, Task) %>%
  summarise(mean.unit = mean(Correct, na.rm= TRUE))%>%
  dplyr::select(SID, mean.unit)

sub.dat <- as.data.frame(right_join(mean.unit, tmp.data, by = "SID"))

mean.nn <- all.data %>%
  filter(Task == "NN")%>%
  group_by(SID, Age, Task) %>%
  summarise(mean.nn = mean(Correct, na.rm= TRUE))%>%
  dplyr::select(SID, mean.nn)

sub.dat <- as.data.frame(sub.dat <- full_join(mean.nn, sub.dat, by = "SID"))

sub.dat %<>%
  distinct(SID, Language, Age, IHC, FHC, mean.unit, mean.nn, highest_contig, sum_wppsi)%>%
  dplyr::select(-SID)%>%
  mutate(highest_contig = as.numeric(highest_contig))%>%
  mutate()
  
library(corrplot)
##Write a function to run correlations for all languages 

langs <- as.vector(unique(all.data$Language))

corregram <- function(df) {
  for (language in langs) {
    tmp <- df %>%
      filter(Language == language)%>%
      dplyr::select(-Language)
    
    M<-cor(tmp, use = "complete.obs")
    head(round(M,2))
    
  #   #add p values
  # cor.mtest <- function(mat, ...) {
  #   mat <- as.matrix(mat)
  #   n <- ncol(mat)
  #   p.mat<- matrix(NA, n, n)
  #   diag(p.mat) <- 0
  #   for (i in 1:(n - 1)) {
  #       for (j in (i + 1):n) {
  #           tmp <- cor.test(mat[, i], mat[, j], ...)
  #           p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
  #       }
  #   }
  # colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  # p.mat
  # }
  # # matrix of the p-value of the correlation
  # p.mat <- cor.mtest(sub.dat)
  # head(p.mat[, 1:7])
    
  corr.plot <- corrplot(M, type="upper", order="hclust", method = "color",
         addCoef.col = "white",
         tl.col="black", tl.srt=45, sig.level = 0.01, 
         title = as.character(language), 
         mar=c(0,0,1,0))
  }
  corr.plot
}

corregram(sub.dat)




```


###Age and Unit/NN task perfomance
```{r}
##HK/US/SLO
all.data %>%
  filter(Task == "SF" |
           Task == "NN", 
         Language == "English (US)" |
           Language == "Cantonese" | 
           Language == "Slovenian") %>%
  filter(!is.na(Productive))%>%
  group_by(SID, Task, Age, Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = Age, y = mean, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm") +
  theme_bw(base_size = 12) +
  scale_color_brewer(palette = "Dark2")+
  theme(legend.position = "bottom", 
        legend.title = element_blank())+
  labs(x = "Age", 
       y = "Mean Unit Task Performance") + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  facet_grid(~Task)

all.data %>%
  filter(Task == "SF" |
           Task == "NN", 
         Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati" |
           Language == "English (India)") %>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  filter(!is.na(Productive))%>%
  group_by(SID, Task, Age, Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = Age, y = mean, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm") +
  theme_bw(base_size = 12) +
  scale_color_manual(values = india.pal)+
  theme(legend.position = "bottom", 
        legend.title = element_blank())+
  labs(x = "Age", 
       y = "Mean Unit Task Performance") + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  facet_grid(~Task)
```

##IHC to NN and Unit task mean performance
```{r}
all.data %>%
  filter(Task == "SF", 
         Language == "English (India)" |
           Language == "English (US)" | 
           Language == "Gujarati" |
           Language == "Hindi") %>%
  filter(!is.na(Productive))%>%
  group_by(SID, FHC, Language, Dataset)%>%
  summarise(mean_unit = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = FHC, y = mean_unit, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw(base_size = 12) +
  scale_color_brewer(palette = "Dark2")+
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank())+
  labs(x = "Final Highest Count", 
       y = "Mean Unit Task Performance") + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

all.data %>%
  filter(Task == "NN")%>%
  filter(!is.na(Productive))%>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  group_by(SID, IHC, Language, Dataset)%>%
  summarise(mean_nn = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = IHC, y = mean_nn, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw(base_size = 12) +
  scale_color_brewer(palette = "Dark2", guide = "none")+
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
  theme(legend.position = "bottom")+
  labs(title = "Mean NN Task Performance and IHC by Language", x = "IHC", 
       y = "Mean NN Task Performance") + 
  facet_grid(~Dataset)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# all.data %>%
#   filter(Task == "SF") %>%
#   filter(!is.na(Productive))%>%
#   mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
#                             Language == "Slovenian", "HK/SLO/US", "India"))%>%
#   group_by(SID, IHC, Language, Productive, Dataset)%>%
#   summarise(mean_unit = mean(Correct, na.rm = TRUE))%>%
#   ggplot(aes(x = IHC, y = mean_unit, colour = Language, group = Language)) +
#   geom_point() + 
#   geom_smooth(method = "lm", se = FALSE) +
#   theme_bw(base_size = 12) +
#   scale_color_brewer(palette = "Dark2")+
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
#   theme(legend.position = "bottom")+
#   labs(title = "Mean Unit Task Performance and IHC by Language", x = "IHC", 
#        y = "Mean Unit Task Performance")+
#   facet_grid(Productive~Dataset, scale = "free_x")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# all.data %>%
#   filter(Task == "NN")%>%
#   filter(!is.na(Productive))%>%
#   mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
#                             Language == "Slovenian", "HK/SLO/US", "India"))%>%
#   group_by(SID, IHC, Language, Productive, Dataset)%>%
#   summarise(mean_nn = mean(Correct, na.rm = TRUE))%>%
#   ggplot(aes(x = IHC, y = mean_nn, colour = Language, group = Language)) +
#   geom_point() + 
#   geom_smooth(method = "lm", se = FALSE) +
#   theme_bw(base_size = 12) +
#   scale_color_brewer(palette = "Dark2")+
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
#   theme(legend.position = "bottom")+
#   labs(title = "Mean NN Task Performance and IHC by Language", x = "IHC", 
#        y = "Mean NN Task Performance") + 
#   facet_grid(Productive~Dataset, scale = "free_x")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


##FHC to NN and Unit task mean performance
```{r}
all.data %>%
  filter(Task == "SF") %>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  filter(!is.na(Productive))%>%
  group_by(SID, FHC, Language, Dataset)%>%
  summarise(mean_unit = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = FHC, y = mean_unit, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw(base_size = 12) +
  scale_color_brewer(palette = "Dark2")+
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
  theme(legend.position = "bottom")+
  labs(title = "Mean Unit Task Performance and FHC by Language", x = "FHC", 
       y = "Mean Unit Task Performance") +
  facet_grid(~Dataset)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

all.data %>%
  filter(Task == "NN")%>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  filter(!is.na(Productive))%>%
  group_by(SID, FHC, Language, Dataset)%>%
  summarise(mean_nn = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = FHC, y = mean_nn, colour = Language, group = Language)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE) +
  theme_bw(base_size = 12) +
  scale_color_brewer(palette = "Dark2")+
  scale_x_continuous(breaks = seq(0, 140, 10)) + 
  coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
  theme(legend.position = "bottom")+
  labs(title = "Mean NN Task Performance and FHC by Language", x = "FHC", 
       y = "Mean NN Task Performance") + 
  facet_grid(~Dataset)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# all.data %>%
#   filter(Task == "SF") %>%
#   filter(!is.na(Productive))%>%
#   mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
#                             Language == "Slovenian", "HK/SLO/US", "India"))%>%
#   group_by(SID, FHC, Language, Productive, Dataset)%>%
#   summarise(mean_unit = mean(Correct, na.rm = TRUE))%>%
#   ggplot(aes(x = FHC, y = mean_unit, colour = Language, group = Language)) +
#   geom_point() + 
#   geom_smooth(method = "lm", se = FALSE) +
#   theme_bw(base_size = 12) +
#   scale_color_brewer(palette = "Dark2")+
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
#   theme(legend.position = "bottom")+
#   labs(title = "Mean Unit Task Performance and FHC by Language", x = "FHC", 
#        y = "Mean Unit Task Performance") +
#   facet_grid(Productive~Dataset, scale = "free_x")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# all.data %>%
#   filter(Task == "NN")%>%
#   filter(!is.na(Productive))%>%
#   mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
#                             Language == "Slovenian", "HK/SLO/US", "India"))%>%
#   group_by(SID, FHC, Language, Productive, Dataset)%>%
#   summarise(mean_nn = mean(Correct, na.rm = TRUE))%>%
#   ggplot(aes(x = FHC, y = mean_nn, colour = Language, group = Language)) +
#   geom_point() + 
#   geom_smooth(method = "lm", se = FALSE) +
#   theme_bw(base_size = 12) +
#   scale_color_brewer(palette = "Dark2")+
#   scale_x_continuous(breaks = seq(0, 140, 10)) + 
#   coord_cartesian(ylim = seq(0,1, .2), expand = TRUE) +
#   theme(legend.position = "bottom")+
#   labs(title = "Mean NN Task Performance and FHC by Language", x = "FHC", 
#        y = "Mean NN Task Performance") +
#   facet_grid(Productive~Dataset, scale = "free_x")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##Unit performance by highest contiguous NN for each language
####HK/SLO/US
```{r}
all.data %>%
  filter(Language == "English (US)" | 
           Language == "Cantonese" | 
           Language == "Slovenian") %>%
  filter(!is.na(Productive))%>%
  filter(!is.na(highest_contig))%>% #filter out kids who do not have NN
  filter(Task == "SF")%>%
  mutate(highest_contig = factor(highest_contig))%>%
  group_by(highest_contig, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = highest_contig, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 10) + 
  scale_colour_brewer(palette = "Dark2") +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Highest contiguous NN", y = "Mean Unit Task performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



```

####India
```{r}

all.data %>%
  filter(Language == "English (US)" |
           Language == "English (India)" |
           Language == "Hindi" | 
           Language == "Gujarati") %>%
  filter(!is.na(Productive))%>%
  filter(!is.na(highest_contig))%>% #filter out kids who do not have NN
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))%>%
  filter(Task == "SF")%>%
  mutate(highest_contig = factor(highest_contig))%>%
  group_by(highest_contig, Language, Dataset)%>%
  summarise(mean = mean(Correct, na.rm = TRUE), 
            n = n(), 
            sd = sd(Correct, na.rm = TRUE), 
            se = sd/sqrt(n)) %>%
  ggplot(aes(x = highest_contig, y = mean, colour = Language, group= Language)) +
  geom_point(size = 2) + 
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = .1) +
  theme_bw(base_size = 10) + 
  scale_colour_manual(values = india.pal) +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
  labs(x = "Highest contiguous NN", y = "Mean Unit Task performance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

---

#Main analyses
#Within-language analyses

###Make model analysis dfs
Note that there is a lot more variability in highest counts and highest contiguous NN than in categorical variables. I am centering age, and centering and scaling FHC, IHC, and highest contiguous NN (which has the most variability).
```{r, include = FALSE}
##HK##
sf.hk.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language== "Cantonese")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))
  
wcn.hk.within <- all.data%>%
  filter(Task == "NN")%>%
  filter(Language == "Cantonese")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)),
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))

##SLO##
sf.slo.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language == "Slovenian")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

wcn.slo.within <- all.data%>%
  filter(Language == "Slovenian")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

##US
sf.us.within <- all.data%>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

wcn.us.within <- all.data%>%
  filter(Language == "English (US)")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Task_item = as.integer(as.character(Task_item)))%>%
  filter(!is.na(highest_contig.c))

##English - India
sf.ind.eng.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (India)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

wcn.ind.eng.within <- all.data %>%
  filter(Language == "English (India)")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

#Hindi
sf.hindi.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Hindi")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

wcn.hindi.within <- all.data %>%
  filter(Language == "Hindi")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))


#Gujarati
sf.gujarati.within <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))

wcn.gujarati.within <- all.data %>%
  filter(Language == "Gujarati")%>%
  filter(Task == "NN")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=TRUE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)))%>%
  filter(!is.na(highest_contig.c))
```

###Unit Task

This first set of analyses replicates, in Cantonese English and Slovenian speaking samples, analyses similar to those previously conducted on English-speaking subjects. To identify whether there is connection between counting experience and Unit Task performance for participants within particular language groups, we will conduct four initial analyses (plus the null model) within each language, predicting Unit Task performance from (1) Productivity (defined above); (2) Final Highest Count; (3) Initial Highest Count; and (4) Highest Contiguous Next Number.

All models will be logistic mixed effects models, predicting performance on the unit task (0 or 1) on a trial as a function of the following predictors, with a random intercept for subject. In R, the formula will beglmer(predicted ~ (predictor) + age + within/outside range + (1|subject), family = binomial).

In each language, after running these first four models, any predictor that significantly (p &lt;.05) predicts Unit TaskPerformance (as assessed by running a likelihood ratio test on the Null Model (Model 0) and Models 1, 2, 3, and 4) will be added into Model 5, which will be our “Large” model. We will construct model 5 hierarchically. Model comparisons will be performed at each stage by running a likelihood ratio test between reduced and full models, with significant effects retained in the full model (Model 5). Model selection will be done on the basis of AIC evaluation and significant Chi-square statistic.


-  Model 0 (null model): Unit.Performance ~ Within/Outside range + Age + (1|subject)
-  Model 1: Unit.Performance ~ Productivity + Within/Outside range + Age + (1|subject)
-  Model 2: Unit.Performance ~ Final.Count + Within/Outside range + Age + (1|subject)
-  Model 3: Unit.Performance ~ Initial.Count + Within/Outside range + Age + (1|subject)
-  Model 4: Unit.Performance ~ Highest.Contiguous.Next.Number + Within/Outside range + Age + (1|subject)

#Hong Kong: Within-language models, Unit Task
Build the models

##Build the models
```{r}
#base
sf.hk.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#Productivity
sf.hk.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#FHC
sf.hk.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hk.within)
#IHC
sf.hk.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)
#Highest contig.
sf.hk.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)

##Exploratory - productivity gradient
sf.hk.within.model.pg <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                               family = "binomial", data = sf.hk.within)

# #exp - cluster
# sf.hk.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c + age.c + (1|SID), 
#                                family = "binomial", data = sf.hk.within)

# #post-hoc - mean nn
# sf.hk.within.model.nn <- glmer(Correct ~ mean.nn + count_range + starting_num.c + age.c + (1|SID), 
#                                family = "binomial", data = sf.hk.within)
```

##Hong Kong: Unit task models
```{r}
mtable.sf.hk <- mtable('Base Model' = sf.hk.within.base,
            'Model 1: Productivity' = sf.hk.within.model1,
            'Model 2: FHC' = sf.hk.within.model2,
            'Model 3: IHC' = sf.hk.within.model3,
            'Model 4: Highest Contig.' = sf.hk.within.model4,
            'EXP: Prod. Gradient' = sf.hk.within.model.pg,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hk
```

##Model comparisons
###Base v. productivity - NS, Chisq(1) = 0.05. p = .82
```{r}
anova(sf.hk.within.base, sf.hk.within.model1, test = 'LRT') #ns
```

###Base v. FHC - Sig, Chisq(1) = 11.65, p = 0.0006, AIC = 1616.5
```{r}
anova(sf.hk.within.base, sf.hk.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 38.91, p < .0001, AIC = 1589.3
```{r}
anova(sf.hk.within.base, sf.hk.within.model3, test = 'LRT')
```

###Base v. Highest Contiguous NN - Sig, Chisq(1) = 11.8251, p = .0002, AIC = 1616.3
```{r}
anova(sf.hk.within.base, sf.hk.within.model4, test = 'LRT')
```

#Exploratory - productivity gain - Marginal
```{r}
anova(sf.hk.within.base, sf.hk.within.model.pg, test = 'LRT')
# anova(sf.hk.within.base, sf.hk.within.model.clust, test = 'LRT')
# anova(sf.hk.within.base, sf.hk.within.model.nn, test = 'LRT')
```

###Ranking of predictors from individual models 
1.  IHC - AIC = 1589.3
2.  HCNN - AIC = 1616.3
3.  FHC - AIC = 1616.5
4.  Productivity - 1624.3

####Exploratory
1. Productivity gradient - AIC = 1624.3

##Large model
We have three significant predictors of performance on the Unit task (FHC, IHC, and Highest Contiguous NN). Now, we need to create our 'large' Model 5 which will contain the best predictors of performance on the Unit Task.

The simple model with the lowest AIC is IHC, so we will begin with that as our base term. 
```{r}
#Base = IHC
sf.hk.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)

#IHC and Highest Contiguous
sf.hk.within.plus2.hc <- glmer(Correct ~ highest_contig.c + ihc.c+ count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hk.within)

#IHC and FHC
sf.hk.within.plus2.fhc <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hk.within)

#IHC and FHC and HCNN
sf.hk.within.plus3 <- glmer(Correct ~ highest_contig.c + fhc.c + ihc.c + count_range + starting_num.c + age.c + 
                              (1|SID), family = "binomial", data = sf.hk.within)


#comparison of 3 (minus HCNN)
anova(sf.hk.within.plus1, sf.hk.within.plus2.fhc, sf.hk.within.plus3, test = 'LRT') 
#comparison of 3 (minus FHC)
anova(sf.hk.within.plus1, sf.hk.within.plus2.hc, sf.hk.within.plus3, test = 'LRT') 

mtable.sf.hk.large <- mtable('IHC alone' = sf.hk.within.plus1,
            'Highest Contig + IHC' = sf.hk.within.plus2.hc,
            'FHC + IHC' = sf.hk.within.plus2.fhc,
            'Highest Contig. + FHC + IHC' = sf.hk.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hk.large
```

####Exploratory - productivity gradient
Productivity gradient does not significantly add to the model
```{r}
#Explore 
##What about productivity gradient?
sf.hk.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.hk.within)
anova(sf.hk.within.plus1, sf.hk.within.plus.gain, test = 'LRT') # productivity gradient does not significantly explain add'l variance
```


##HK Unit Task within-language results: IHC emerges as best predictor of performance on Unit Task
```{r}
summary(sf.hk.within.plus1)

# library(dotwhisker)
#visualizing regressions
# full.model.unit.hk <- summary(sf.hk.within.plus1)
# 
# AIC <- as.numeric(full.model.unit.hk$AICtab[1])
# 
# full.model.df.unit.hk <- data.frame(coef(full.model.unit.hk)[,0:4])
# full.model.df.unit.hk <- add_rownames(full.model.df.unit.hk, "Parameter")
# 
# full.model.df.unit.hk %<>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "IHC",
#                                    ifelse(Parameter == "count_rangeWithin", "Within IHC",
#                                           ifelse(Parameter == "age.c", "Age", 
#                                                  ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept"))))) %>%
#   filter(Parameter != "Intercept")%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "IHC")))
# 
# full.model.df.unit.hk %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 12) +
#   theme(axis.text = element_text(size = 10),
#         axis.title = element_text(size = 10), 
#         legend.position = "none") +
#   coord_flip() +
#   langcog::scale_color_solarized() +
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```


---

#SLO: Within-language models, Unit Task

##Build the models
```{r}
#base
sf.slo.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID) , family = "binomial", 
                           data = sf.slo.within)
#productivity
sf.slo.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.slo.within)
#FHC
sf.slo.within.model2 <- glmer(Correct ~ fhc.c + count_range + age.c + starting_num.c + (1|SID), family = "binomial", 
                           data = sf.slo.within)
#IHC
sf.slo.within.model3 <- glmer(Correct ~ ihc.c + count_range + age.c + starting_num.c + (1|SID), 
                             family = "binomial", 
                           data = sf.slo.within)
#highest contiguous NN
sf.slo.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.slo.within) 

#exploratory - productivity gradient
sf.slo.within.model.pg <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                family = "binomial", data = sf.slo.within)

# #exp - cluster
# sf.slo.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c + age.c + (1|SID), 
#                                 family = "binomial", data = sf.slo.within)

# #post-hoc - mean nn
# sf.slo.within.model.nn <- glmer(Correct ~ mean.nn + count_range + starting_num.c + age.c + (1|SID), 
#                                 family = "binomial", data = sf.slo.within)
```

##SLO: Unit task models
```{r}
mtable.sf.slo <- mtable('Base Model' = sf.slo.within.base,
            'Model 1: Productivity' = sf.slo.within.model1,
            'Model 2: FHC' = sf.slo.within.model2,
            'Model 3: IHC' = sf.slo.within.model3,
            'Model 4: Highest Contig.' = sf.slo.within.model4,
            'EXP: Prod. Gradient' = sf.slo.within.model.pg,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.slo
```

##Model Comparisons
###Base v. Productivity - sig, Chis(1) = 6.65, p = .01, AIC = 1397.5
```{r}
anova(sf.slo.within.base, sf.slo.within.model1, test = 'LRT')
```

 
###Base v. FHC - Sig, Chisq(1) = 11.45, p = .0007, AIC = 1392.7
```{r}
anova(sf.slo.within.base, sf.slo.within.model2, test = 'LRT')
```

###Base v. IHC - NS
```{r}
anova(sf.slo.within.base, sf.slo.within.model3, test = 'LRT')
````

###Base v. Highest Contiguous NN - Sig, Chisq(1) = 22.44, p < .0001, AIC = 1369.7
```{r}
anova(sf.slo.within.base, sf.slo.within.model4, test = 'LRT')
```

###Exploratory - Prod. gain - significant, Chisq. = 9.56, p = .002
```{r}
anova(sf.slo.within.base, sf.slo.within.model.pg, test = 'LRT')
# anova(sf.slo.within.base, sf.slo.within.model.clust, test = 'LRT')
# anova(sf.slo.within.base, sf.slo.within.model.nn, test = 'LRT')

```

##Ranking of Productivity predictors from AIC 
1.  HCNN - 1369.7
2.  FHC - 1392.7
3.  Productivity - 1397.5
4.  IHC - 1401 (NS)


##Large model

```{r}
#Base - HCNN
sf.slo.within.plus1 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#HCNN + FHC
sf.slo.within.plus2.fhc <- glmer(Correct ~ fhc.c + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#Productive + HCNN
sf.slo.within.plus2.prod <- glmer(Correct ~ Productive + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")

#Productive + HCNN + FHC
sf.slo.within.plus3 <- glmer(Correct ~ Productive + fhc.c + highest_contig.c + count_range + starting_num.c + age.c + 
                               (1|SID), family = "binomial", data = sf.slo.within)

#comparison of 3, minus prod
anova(sf.slo.within.plus1, sf.slo.within.plus2.fhc,  sf.slo.within.plus3, test = 'LRT') 
#comparison of 3, minus fhc
anova(sf.slo.within.plus1, sf.slo.within.plus2.prod,  sf.slo.within.plus3, test = 'LRT') 


mtable.sf.slo.large <- mtable('Highest Contig. alone' = sf.slo.within.plus1,
            'Highest Contig + FHC' = sf.slo.within.plus2.fhc,
            'Highest Contig + IHC' = sf.slo.within.plus2.prod,
            'Highest Contig + FHC + IHC' = sf.slo.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.slo.large

# #highest contig v. mean nn
# sf.slo.within.plus.nn <- glmer(Correct ~ mean.nn + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
#                              data = sf.slo.within, family = "binomial")
# anova(sf.slo.within.plus1, sf.slo.within.plus.nn, test = 'LRT')

#what about productivity gradient
sf.slo.within.plus.gain <- glmer(Correct ~ prod.gradient + highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.slo.within, family = "binomial")
anova(sf.slo.within.plus1, sf.slo.within.plus.gain, test = 'LRT')

summary(sf.slo.within.plus1)
# summary(sf.slo.within.plus.nn)
```

##Summary, SLO Unit: HCNN is best predictor
```{r}
summary(sf.slo.within.plus1)

# full.model.unit.slo <- summary(sf.slo.within.plus1)
# 
# AIC <- as.numeric(full.model.unit.slo$AICtab[1])
# 
# full.model.df.unit.slo <- data.frame(coef(full.model.unit.slo)[,0:4])
# full.model.df.unit.slo <- add_rownames(full.model.df.unit.slo, "Parameter")
# 
# full.model.df.unit.slo %<>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN",
#                                    ifelse(Parameter == "count_rangeWithin", "Within IHC",
#                                           ifelse(Parameter == "age.c", "Age", 
#                                                  ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept"))))) %>%
#   filter(Parameter != "Intercept")%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "HCNN")))
# 
# full.model.df.unit.slo %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 12) +
#   theme(axis.text = element_text(size = 10),
#         axis.title = element_text(size = 10), 
#         legend.position = "none") +
#   coord_flip() +
#   langcog::scale_color_solarized() +
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

--- 

#English (US): Within-language models, Unit Task

##Build the models
```{r}
#base
sf.us.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#productivity
sf.us.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#FHC
sf.us.within.model2 <- glmer(Correct ~ fhc.c + count_range +  starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.us.within)
#IHC
sf.us.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c +  age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within, control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Highest contiguous
sf.us.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within) 
#Exploratory, Prod. gradient
sf.us.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c +age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.us.within) #ns
# 
# sf.us.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c +age.c + (1|SID), 
#                              family = "binomial", 
#                            data = sf.us.within)
#post-hoc - mean nn
# sf.us.within.model.nn <- glmer(Correct ~ mean.nn + count_range + starting_num.c +age.c + (1|SID), 
#                              family = "binomial", 
#                            data = sf.us.within)

```

##English (US): Unit task models
```{r}
mtable.sf.us <- mtable('Base Model' = sf.us.within.base,
            'Model 1: Productivity' = sf.us.within.model1,
            'Model 2: FHC' = sf.us.within.model2,
            'Model 3: IHC' = sf.us.within.model3,
            'Model 4: Highest Contig.' = sf.us.within.model4,
            'Exp. model: Prod. gradient' = sf.us.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.us
```

##Model comparisons
###Base v. Productivity - NS, Chisq(1) = 1.19, p = .27, AIC = 1514.6
```{r}
anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 18.85, p < .0001, AIC = 1496.9
```{r}
anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 49.48, p < .0001, AIC = 1466.3
```{r}
anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')
````

###Base v. Highest Contig. - Sig, Chisq(1) = 35.86, p < .0001, AIC = 1479.9
```{r}
anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')
```

###Post-hoc: Prod.gradient - Sig, Chisq(1) = 4.3153, p = .04, AIC = 1526.8
```{r}
anova(sf.us.within.base, sf.us.within.model.gain, test = 'LRT')
# anova(sf.us.within.base, sf.us.within.model.clust, test = 'LRT') 
# anova(sf.us.within.base, sf.us.within.model.nn, test = 'LRT')
```

##Ranking of productivity predictors by AIC 
1.  IHC - 1466.3 
2.  HCNN - 1479.9
3.  FHC - 1496.9
4.  Productivity - 1514

##Large model
Base = IHC 
```{r}
#IHC
sf.us.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#IHC + FHC
sf.us.within.plus2.fhc <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                             control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#IHC + HCNN
sf.us.within.plus2.highest.contig <- glmer(Correct ~ highest_contig.c + ihc.c + starting_num.c + count_range + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                             control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
# sf.us.within.plus2.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
#                              data = sf.us.within, family = "binomial", 
#                              control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))

#IHC + FHC + HCNN
sf.us.within.plus3 <- glmer(Correct ~ highest_contig.c + fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))


#compare 3, minus hcnn
anova(sf.us.within.plus1, sf.us.within.plus2.fhc, sf.us.within.plus3, test = 'LRT') 
#compare 3, minus fhc
anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, sf.us.within.plus3, test = 'LRT') 
#regression table
mtable.sf.us.large <- mtable('IHC' = sf.us.within.plus1,
            'FHC + IHC' = sf.us.within.plus2.fhc,
            'Highest Contig + IHC' = sf.us.within.plus2.highest.contig,
            # 'Prod. gradient + IHC' = sf.us.within.plus2.gain,
            'Highest Contig + FHC + IHC' = sf.us.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.us.large

# #exp - mean nn + hcnn + ihc
# sf.us.within.plus3.nn <- glmer(Correct ~ mean.nn + highest_contig.c + ihc.c + starting_num.c + count_range + age.c + (1|SID), 
#                              data = sf.us.within, family = "binomial", 
#                              control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# 
# anova(sf.us.within.plus2.highest.contig, sf.us.within.plus3.nn, test = 'LRT')

#exp - prod.gradient + hcnn + ihc
sf.us.within.plus3.pg <- glmer(Correct ~ prod.gradient + highest_contig.c + ihc.c + starting_num.c + count_range + age.c + (1|SID), 
                             data = sf.us.within, family = "binomial", 
                             control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(sf.us.within.plus2.highest.contig, sf.us.within.plus3.pg, test = 'LRT')

summary(sf.us.within.plus2.highest.contig)
```

##US Unit Task within-language results: IHC and HCNN best predictor of performance on Unit Task
```{r}
summary(sf.us.within.plus2.highest.contig)

# full.model.unit.us <- summary(sf.us.within.plus2.highest.contig)
# 
# AIC <- as.numeric(full.model.unit.us$AICtab[1])
# 
# full.model.df.unit.us <- data.frame(coef(full.model.unit.us)[,0:4])
# full.model.df.unit.us <- add_rownames(full.model.df.unit.us, "Parameter")
# 
# full.model.df.unit.us %<>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN",
#                               ifelse(Parameter == "ihc.c", "IHC", 
#                                    ifelse(Parameter == "count_rangeWithin", "Within IHC",
#                                           ifelse(Parameter == "age.c", "Age", 
#                                                  ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
#   filter(Parameter != "Intercept")%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "HCNN", "IHC")))
# 
# full.model.df.unit.us %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 12) +
#   theme(axis.text = element_text(size = 10),
#         axis.title = element_text(size = 10), 
#         legend.position = "none") +
#   coord_flip() +
#   langcog::scale_color_solarized() +
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

##Visualization of models
To-do: Manually change the colors of prod.predictors

```{r, echo = TRUE}
#Get all the parameters in one model, then add column for parameter so we can graph all the individual models at once
#

# #HK
# #productivity
# hk.prod.model <- summary(sf.hk.within.model1)
# hk.prod.model.df <- data.frame(coef(hk.prod.model)[,0:4])
# hk.prod.model.df <- add_rownames(hk.prod.model.df, "Parameter")
# hk.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hk.within.base, sf.hk.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.hk.within.base, sf.hk.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hk.prod.model$AICtab[1]), 2), 
#          Language = "Cantonese")
# 
# #FHC
# hk.fhc.model <- summary(sf.hk.within.model2)
# hk.fhc.model.df <- data.frame(coef(hk.fhc.model)[,0:4])
# hk.fhc.model.df <- add_rownames(hk.fhc.model.df, "Parameter")
# hk.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hk.within.base, sf.hk.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hk.within.base, sf.hk.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hk.fhc.model$AICtab[1]), 2), 
#          Language = "Cantonese")
# 
# #IHC
# hk.ihc.model <- summary(sf.hk.within.model3)
# hk.ihc.model.df <- data.frame(coef(hk.ihc.model)[,0:4])
# hk.ihc.model.df <- add_rownames(hk.ihc.model.df, "Parameter")
# hk.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hk.within.base, sf.hk.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hk.within.base, sf.hk.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hk.ihc.model$AICtab[1]), 2), 
#          Language = "Cantonese")
# 
# #HCNN
# hk.hcnn.model <- summary(sf.hk.within.model4)
# hk.hcnn.model.df <- data.frame(coef(hk.hcnn.model)[,0:4])
# hk.hcnn.model.df <- add_rownames(hk.hcnn.model.df, "Parameter")
# hk.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(hk.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.hk.within.base, sf.hk.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hk.within.base, sf.hk.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "Cantonese")
# 
# ###SLO
# slo.prod.model <- summary(sf.slo.within.model1)
# slo.prod.model.df <- data.frame(coef(slo.prod.model)[,0:4])
# slo.prod.model.df <- add_rownames(slo.prod.model.df, "Parameter")
# slo.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.slo.within.base, sf.slo.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.slo.within.base, sf.slo.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(slo.prod.model$AICtab[1]), 2), 
#          Language = "Slovenian")
# 
# slo.fhc.model <- summary(sf.slo.within.model2)
# slo.fhc.model.df <- data.frame(coef(slo.fhc.model)[,0:4])
# slo.fhc.model.df <- add_rownames(slo.fhc.model.df, "Parameter")
# slo.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.slo.within.base, sf.slo.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.slo.within.base, sf.slo.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(slo.fhc.model$AICtab[1]), 2), 
#          Language = "Slovenian")
# 
# slo.ihc.model <- summary(sf.slo.within.model3)
# slo.ihc.model.df <- data.frame(coef(slo.ihc.model)[,0:4])
# slo.ihc.model.df <- add_rownames(slo.ihc.model.df, "Parameter")
# slo.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.slo.within.base, sf.slo.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.slo.within.base, sf.slo.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(slo.ihc.model$AICtab[1]), 2), 
#          Language = "Slovenian")
# 
# slo.hcnn.model <- summary(sf.slo.within.model4)
# slo.hcnn.model.df <- data.frame(coef(slo.hcnn.model)[,0:4])
# slo.hcnn.model.df <- add_rownames(slo.hcnn.model.df, "Parameter")
# slo.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(slo.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.slo.within.base, sf.slo.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.slo.within.base, sf.slo.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "Slovenian")
# 
# ###US
# us.prod.model <- summary(sf.us.within.model1)
# us.prod.model.df <- data.frame(coef(us.prod.model)[,0:4])
# us.prod.model.df <- add_rownames(us.prod.model.df, "Parameter")
# us.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.prod.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.fhc.model <- summary(sf.us.within.model2)
# us.fhc.model.df <- data.frame(coef(us.fhc.model)[,0:4])
# us.fhc.model.df <- add_rownames(us.fhc.model.df, "Parameter")
# us.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.fhc.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.ihc.model <- summary(sf.us.within.model3)
# us.ihc.model.df <- data.frame(coef(us.ihc.model)[,0:4])
# us.ihc.model.df <- add_rownames(us.ihc.model.df, "Parameter")
# us.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.ihc.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.hcnn.model <- summary(sf.us.within.model4)
# us.hcnn.model.df <- data.frame(coef(us.hcnn.model)[,0:4])
# us.hcnn.model.df <- add_rownames(us.hcnn.model.df, "Parameter")
# us.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(us.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "English (US)")
# 
# 
# #join togther 
# all.models.unit <- bind_rows(hk.prod.model.df, hk.fhc.model.df, hk.ihc.model.df, hk.hcnn.model.df, 
#                              slo.prod.model.df, slo.fhc.model.df, slo.ihc.model.df, slo.hcnn.model.df, 
#                              us.prod.model.df, us.fhc.model.df, us.ihc.model.df, us.hcnn.model.df) 
# 
# all.models.unit %<>%
#   filter(Parameter != "(Intercept)")%>%
#   mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
#                             ifelse(Parameter == "count_rangeWithin", "Within IHC", 
#                                    ifelse(Parameter == "Prod. Predictor", "Productivity predictor", "Age"))))%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "Productivity predictor")))%>%
#   mutate(colors = ifelse((Parameter == "Age" | Parameter == "Item magnitude" | Parameter == "Within IHC"), as.character(Parameter), 
#                          as.character(Model))) %>%
#   mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Initial Highest Count", 
#                                           "Highest Contiguous Next Number"))) %>%
#   mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
#   mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)")))
# 
# data.r <- all.models.unit %>%
#   distinct(Language, Model, AIC, chi.stat, p.val)
# 
# quartz()
# model.vis <- all.models.unit %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   facet_grid(Language~Model)+
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 10) +
#   coord_flip() +
#   scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
#   geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
#             x = 1.5, y = 1, size = 2.5,
#             data = data.r) + 
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")

####FINAL MODELS####

hk.final <- summary(sf.hk.within.plus1)
hk.final.df <- data.frame(coef(hk.final)[,0:4])
hk.final.df <- add_rownames(hk.final.df, "Parameter")
hk.final.df %<>%
  mutate(Language = "Cantonese")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "IHC", as.character(Parameter)), 
         AIC = round(as.numeric(hk.final$AICtab[1]), 2), 
         p.val = round(anova(sf.hk.within.base, sf.hk.within.plus1, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.hk.within.base, sf.hk.within.plus1, test = 'LRT')[2,6], 2))

slo.final <- summary(sf.slo.within.plus1)
slo.final.df <- data.frame(coef(slo.final)[,0:4])
slo.final.df <- add_rownames(slo.final.df, "Parameter")
slo.final.df %<>%
  mutate(Language = "Slovenian")%>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN", as.character(Parameter)), 
         AIC = round(as.numeric(slo.final$AICtab[1]), 2), 
         p.val = round(anova(sf.slo.within.base, sf.slo.within.plus1, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.slo.within.base, sf.slo.within.plus1, test = 'LRT')[2,6], 2))

us.final <- summary(sf.us.within.plus2.highest.contig)
us.final.df <- data.frame(coef(us.final)[,0:4])
us.final.df <- add_rownames(us.final.df, "Parameter")
us.final.df %<>%
  mutate(Language = "English")%>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN", 
                            ifelse(Parameter == "ihc.c", "IHC", as.character(Parameter))), 
         AIC = round(as.numeric(us.final$AICtab[1]), 2), 
         p.val = round(anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, test = 'LRT')[2,6], 2))

all.models.final <- bind_rows(slo.final.df, hk.final.df, us.final.df)

all.models.final %<>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "(Intercept)", "Intercept", 
                                          ifelse(Parameter == "age.c", "Age", as.character(Parameter))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("IHC", "HCNN", "Intercept", "Age", "Item magnitude", "Within IHC")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
  mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English")))

data.r <- all.models.final %>%
  distinct(Language, Model, AIC, chi.stat, p.val)

all.models.final %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Language, scale = "free_x") +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 13) +
  # coord_flip() +
  scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 4.1, y = .9, size = 3.5,
            data = data.r) + 
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)") + 
  theme(axis.text.x = element_text(angle = 35, hjust = 1))

```

##Within-language comparison of > 100 items
```{r}
##Within language
sf.hk.within %<>%
  mutate(item_100 = ifelse(Task_item > 100, ">100", "<100"))

sf.hk.within.sub.100 <- sf.hk.within %>%
  filter(item_100 == "<100")

post.hk.sf.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), 
                         family = "binomial", data = sf.hk.within)
post.hk.sf.ihc <- glmer(Correct ~ ihc.c*item_100 + count_range + starting_num.c + age.c + (1|SID), 
                        family = "binomial", data = sf.hk.within)
post.hk.sf.fhc <- glmer(Correct ~ fhc.c*item_100 + count_range + starting_num.c + age.c + (1|SID), 
                        family = "binomial", data = sf.hk.within, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
post.hk.sf.hcnn <- glmer(Correct ~ highest_contig.c*item_100 + count_range + starting_num.c + age.c + (1|SID), 
                        family = "binomial", data = sf.hk.within, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
post.hk.sf.prod <- glmer(Correct ~ Productive*item_100 + count_range + starting_num.c + age.c + (1|SID), 
                        family = "binomial", data = sf.hk.within)

#model comparisons
anova(post.hk.sf.base, post.hk.sf.ihc, test = 'LRT')
anova(post.hk.sf.base, post.hk.sf.fhc, test = 'LRT')
anova(post.hk.sf.base, post.hk.sf.hcnn, test = 'LRT')
anova(post.hk.sf.base, post.hk.sf.prod, test = 'LRT')
```

---

#English (India): Within-language models, Unit Task (recall that these models include starting magnitude, centered)

##Build the models
```{r}
#base
sf.ind.eng.within.base <- glmer(Correct ~ count_range + starting_num.c +age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within)
#productivity
sf.ind.eng.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within)
#FHC
sf.ind.eng.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c  + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within)
#IHC
sf.ind.eng.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within)
#Highest contiguous
sf.ind.eng.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within)

#exploratory - prod. gradient
sf.ind.eng.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within) #sig

sf.ind.eng.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within) #sig

#post-hoc - mean nn
sf.ind.eng.within.model.nn <- glmer(Correct ~ mean.nn + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.ind.eng.within) 
```


##English (India): Unit task models
```{r}
mtable.sf.ind.eng <- mtable('Base Model' = sf.ind.eng.within.base,
            'Model 1: Productivity' = sf.ind.eng.within.model1,
            'Model 2: FHC' = sf.ind.eng.within.model2,
            'Model 3: IHC' = sf.ind.eng.within.model3,
            'Model 4: Highest Contig.' = sf.ind.eng.within.model4,
            'Exp: Prod. Gradient' = sf.ind.eng.within.model.gain,
            'Exp: Cluster' = sf.ind.eng.within.model.clust,
            'Exp: Mean NN' = sf.ind.eng.within.model.nn,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.ind.eng
```

##Model comparisons
###Base v. productivity - p = .04
```{r}
anova(sf.ind.eng.within.base, sf.ind.eng.within.model1, test = 'LRT')
```

###Base v. FHC - significant, Chisq(1) = 12.316, p = .0004, AIC = 783.7
```{r}
anova(sf.ind.eng.within.base, sf.ind.eng.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 7.512, p = .006, AIC = 788.49
```{r}
anova(sf.ind.eng.within.base, sf.ind.eng.within.model3, test = 'LRT')
```

###Base v. Highest Contiguous NN - sig, Chisq(1) = 5.11, p = .02, AIC = 778.9
```{r}
anova(sf.ind.eng.within.base, sf.ind.eng.within.model4, test = 'LRT')
```

###Exploratory: Base v. Prod.gradient - Sig, Chisq(1) = 7.42, p = .006
```{r}
anova(sf.ind.eng.within.base, sf.ind.eng.within.model.gain, test = 'LRT')
anova(sf.ind.eng.within.base, sf.ind.eng.within.model.clust, test = 'LRT')
anova(sf.ind.eng.within.base, sf.ind.eng.within.model.nn, test = 'LRT')
```

##Large model
```{r}
#FHC
sf.ind.eng.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = sf.ind.eng.within, 
                           control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#HCNN + FHC
sf.ind.eng.within.plus2.hc <- glmer(Correct ~ highest_contig.c + fhc.c + count_range + starting_num.c + age.c + starting_num.c + (1|SID), 
                            family = "binomial", data = sf.ind.eng.within, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#IHC + FHC
sf.ind.eng.within.plus2.ihc <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c  +(1|SID), 
                            family = "binomial", data = sf.ind.eng.within,control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#HCNN + IHC + FHC
sf.ind.eng.within.plus3 <- glmer(Correct ~ highest_contig.c + ihc.c + fhc.c + count_range + age.c + starting_num.c + (1|SID), 
                            family = "binomial", data = sf.ind.eng.within, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))


#comparison of 3, minus ihc
anova(sf.ind.eng.within.plus1, sf.ind.eng.within.plus2.hc, sf.ind.eng.within.plus3, test = 'LRT')
anova(sf.ind.eng.within.plus1, sf.ind.eng.within.plus2.ihc, sf.ind.eng.within.plus3, test = 'LRT')

mtable.sf.ind.eng.large <- mtable('FHC alone' = sf.ind.eng.within.plus1,
            'Highest Contig. + FHC' = sf.ind.eng.within.plus2.hc,
            'IHC + FHC' = sf.ind.eng.within.plus2.ihc,
            'Highest Contig. + IHC + FHC' = sf.ind.eng.within.plus3, 
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.ind.eng.large

summary(sf.ind.eng.within.plus1)
```

##English (India) Unit Task within-language results: FHC emerges as best predictor of performance on Unit Task

---

#Hindi: Within-language models, Unit Task
##Build the models
```{r}
#Base
sf.hindi.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#Productivity
sf.hindi.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c  + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#FHC
sf.hindi.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#IHC
sf.hindi.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)
#Highest contig
sf.hindi.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.hindi.within)

#Exploratory - prod. gradient 
sf.hindi.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c +
                                      (1|SID), family = "binomial", data = sf.hindi.within)

#Exploratory - cluster
sf.hindi.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c + age.c +
                                      (1|SID), family = "binomial", data = sf.hindi.within)

```

##Hindi: Unit task models
```{r}
mtable.sf.hindi <- mtable('Base Model' = sf.hindi.within.base,
            'Model 1: Productivity' = sf.hindi.within.model1,
            'Model 2: FHC' = sf.hindi.within.model2,
            'Model 3: IHC' = sf.hindi.within.model3,
            'Model 4: Highest Contig.' = sf.hindi.within.model4,
            'Exp: Prod. gradient' = sf.hindi.within.model.gain,
            'Exp: Cluster' = sf.hindi.within.model.clust,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hindi
```

##Model comparisons
###Base v. Productivity - marginal, p = .07
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model1, test = 'LRT')
```

###Base v. FHC - sig, Chisq(1) = 21.6, p < .0001, AIC = 1325.1
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, chisq(1) = 28.436, p < .0001, AIC = 1318.4
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model3, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 27.63, p < .0001, AIC = 1319.1
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model4, test = 'LRT')
```

###Exploratory - prod. gradient, p = .008
```{r}
anova(sf.hindi.within.base, sf.hindi.within.model.gain, test = 'LRT')
```

###Ranking of productivtiy predictors by AIC
1.  IHC = 1318
2.  HCNN = 1319
3.  FHC = 1325
4.  Productivity = 1343


##Large model

IHC v. FHC v. Highest Contig
```{r}
#IHC
sf.hindi.within.plus1 <- glmer(Correct ~ ihc.c + count_range +  starting_num.c + age.c  + (1|SID), 
                             family = "binomial", 
                           data = sf.hindi.within)
#HCNN + IHC 
sf.hindi.within.plus2.hc <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = sf.hindi.within)

#FHC + IHC
sf.hindi.within.plus2.fhc <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hindi.within)

#HCNN + FHC + IHC
sf.hindi.within.plus3 <- glmer(Correct ~ highest_contig.c + fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = sf.hindi.within)

# #Exploratory - prod. gain v. IHC
# sf.hindi.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
#                             family = "binomial", data = sf.hindi.within)

#Comparison of 3 minus fhc
anova(sf.hindi.within.plus1, sf.hindi.within.plus2.hc, sf.hindi.within.plus3, test = 'LRT')
#Comparison of 3 minus HCNN
anova(sf.hindi.within.plus1, sf.hindi.within.plus2.fhc, sf.hindi.within.plus3, test = 'LRT')

mtable.sf.hindi.large <- mtable('IHC alone' = sf.hindi.within.plus1,
            'Highest Contig. + IHC' = sf.hindi.within.plus2.hc,
            'FHC + IHC' = sf.hindi.within.plus2.fhc,
            'Highest Contig. + FHC + IHC' = sf.hindi.within.plus3, 
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.hindi.large

# #IHC V. mean nn
# sf.hindi.within.plus1.nn <- glmer(Correct ~ mean.nn + highest_contig.c + ihc.c + count_range +  starting_num.c + age.c  + (1|SID), 
#                              family = "binomial", 
#                            data = sf.hindi.within)
# anova(sf.hindi.within.plus2.hc, sf.hindi.within.plus1.nn, test = 'LRT')

#SUMMARY of final model
summary(sf.hindi.within.plus2.hc)
# #summary of mean nn model
# summary(sf.hindi.within.plus1.nn)
```

##Hindi Unit Task  within-language results: IHC, and Highest Contig. emerge as best predictor of performance on Unit Task
```{r}
summary(sf.hindi.within.plus2.hc)

full.model.unit.hindi <- summary(sf.hindi.within.plus2.hc)

AIC <- as.numeric(full.model.unit.hindi$AICtab[1])

full.model.df.unit.hindi <- data.frame(coef(full.model.unit.us)[,0:4])
full.model.df.unit.hindi <- add_rownames(full.model.df.unit.hindi, "Parameter")

full.model.df.unit.hindi %<>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN",
                              ifelse(Parameter == "ihc.c", "IHC", 
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "HCNN", "IHC")))

full.model.df.unit.hindi %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#Gujarati: Within-language models, Unit Task
##Build the models
```{r}
#Base
sf.gujarati.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#Productivity
sf.gujarati.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#FHC
sf.gujarati.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#IHC
sf.gujarati.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)
#Highest contig.
sf.gujarati.within.model4 <- glmer(Correct ~ highest_contig.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                           data = sf.gujarati.within)

#Exploratory - prod.gradient
sf.gujarati.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + 
                                         (1|SID), family = "binomial", data = sf.gujarati.within)

#Exploratory - cluster
sf.gujarati.within.model.clust <- glmer(Correct ~ CLUST + count_range + starting_num.c + age.c + 
                                         (1|SID), family = "binomial", data = sf.gujarati.within, 
                                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

# #Post-hoc - mean nn
# sf.gujarati.within.model.nn <- glmer(Correct ~ mean.nn + count_range + starting_num.c + age.c + 
#                                          (1|SID), family = "binomial", data = sf.gujarati.within, 
#                                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
```

##Gujarati: Unit task models
```{r}
mtable.sf.gujarati <- mtable('Base Model' = sf.gujarati.within.base,
            'Model 1: Productivity' = sf.gujarati.within.model1,
            'Model 2: FHC' = sf.gujarati.within.model2,
            'Model 3: IHC' = sf.gujarati.within.model3,
            'Model 4: Highest Contig.' = sf.gujarati.within.model4,
            'Exp.: Prod. gradient' = sf.gujarati.within.model.gain,
            'Exp.: Cluster' = sf.gujarati.within.model.clust,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.gujarati
```

##Model comparisons
###Base v. productivity - NS, p = .4
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model1, test = 'LRT')
```

###Base v. FHC - NS, p = .3
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model2, test = 'LRT')
```

###Base v. IHC - p = .19
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model3, test = 'LRT')
```

###Base v. Highest contig, NS p = .2
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model4, test = 'LRT')
```

###Exploratory - prod.gradient, NS, p = .96
```{r}
anova(sf.gujarati.within.base, sf.gujarati.within.model.gain, test = 'LRT')
```

#Large model - mean NN
```{r}
# summary(sf.gujarati.within.base)
# summary(sf.gujarati.within.model.nn)
```

```{r}
full.model.unit.gujarati <- summary(sf.gujarati.within.base)

AIC <- as.numeric(full.model.unit.gujarati$AICtab[1])

full.model.df.unit.gujarati <- data.frame(coef(full.model.unit.gujarati)[,0:4])
full.model.df.unit.gujarati <- add_rownames(full.model.df.unit.gujarati, "Parameter")

full.model.df.unit.gujarati %<>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN",
                              ifelse(Parameter == "ihc.c", "IHC", 
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC")))

full.model.df.unit.gujarati %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

##Visualizations - India models
```{r, echo = TRUE}
# #Get all the parameters in one model, then add column for parameter so we can graph all the individual models at once
# #
# 
# #Hindi
# #productivity
# hindi.prod.model <- summary(sf.hindi.within.model1)
# hindi.prod.model.df <- data.frame(coef(hindi.prod.model)[,0:4])
# hindi.prod.model.df <- add_rownames(hindi.prod.model.df, "Parameter")
# hindi.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hindi.within.base, sf.hindi.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.hindi.within.base, sf.hindi.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.prod.model$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# #FHC
# hindi.fhc.model <- summary(sf.hindi.within.model2)
# hindi.fhc.model.df <- data.frame(coef(hindi.fhc.model)[,0:4])
# hindi.fhc.model.df <- add_rownames(hindi.fhc.model.df, "Parameter")
# hindi.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hindi.within.base, sf.hindi.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hindi.within.base, sf.hindi.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.fhc.model$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# #IHC
# hindi.ihc.model <- summary(sf.hindi.within.model3)
# hindi.ihc.model.df <- data.frame(coef(hindi.ihc.model)[,0:4])
# hindi.ihc.model.df <- add_rownames(hindi.ihc.model.df, "Parameter")
# hindi.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.hindi.within.base, sf.hindi.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hindi.within.base, sf.hindi.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.ihc.model$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# #HCNN
# hindi.hcnn.model <- summary(sf.hindi.within.model4)
# hindi.hcnn.model.df <- data.frame(coef(hindi.hcnn.model)[,0:4])
# hindi.hcnn.model.df <- add_rownames(hindi.hcnn.model.df, "Parameter")
# hindi.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(hindi.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.hindi.within.base, sf.hindi.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.hindi.within.base, sf.hindi.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "Hindi")
# 
# ###GUJARATI###
# gujarati.prod.model <- summary(sf.gujarati.within.model1)
# gujarati.prod.model.df <- data.frame(coef(gujarati.prod.model)[,0:4])
# gujarati.prod.model.df <- add_rownames(gujarati.prod.model.df, "Parameter")
# gujarati.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.gujarati.within.base, sf.gujarati.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.gujarati.within.base, sf.gujarati.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.prod.model$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# gujarati.fhc.model <- summary(sf.gujarati.within.model2)
# gujarati.fhc.model.df <- data.frame(coef(gujarati.fhc.model)[,0:4])
# gujarati.fhc.model.df <- add_rownames(gujarati.fhc.model.df, "Parameter")
# gujarati.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.gujarati.within.base, sf.gujarati.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.gujarati.within.base, sf.gujarati.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.fhc.model$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# gujarati.ihc.model <- summary(sf.gujarati.within.model3)
# gujarati.ihc.model.df <- data.frame(coef(gujarati.ihc.model)[,0:4])
# gujarati.ihc.model.df <- add_rownames(gujarati.ihc.model.df, "Parameter")
# gujarati.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.gujarati.within.base, sf.gujarati.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.gujarati.within.base, sf.gujarati.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.ihc.model$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# gujarati.hcnn.model <- summary(sf.gujarati.within.model4)
# gujarati.hcnn.model.df <- data.frame(coef(gujarati.hcnn.model)[,0:4])
# gujarati.hcnn.model.df <- add_rownames(gujarati.hcnn.model.df, "Parameter")
# gujarati.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(gujarati.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.gujarati.within.base, sf.gujarati.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.gujarati.within.base, sf.gujarati.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "Gujarati")
# 
# ###US
# us.prod.model <- summary(sf.us.within.model1)
# us.prod.model.df <- data.frame(coef(us.prod.model)[,0:4])
# us.prod.model.df <- add_rownames(us.prod.model.df, "Parameter")
# us.prod.model.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.prod.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.fhc.model <- summary(sf.us.within.model2)
# us.fhc.model.df <- data.frame(coef(us.fhc.model)[,0:4])
# us.fhc.model.df <- add_rownames(us.fhc.model.df, "Parameter")
# us.fhc.model.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.fhc.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.ihc.model <- summary(sf.us.within.model3)
# us.ihc.model.df <- data.frame(coef(us.ihc.model)[,0:4])
# us.ihc.model.df <- add_rownames(us.ihc.model.df, "Parameter")
# us.ihc.model.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.ihc.model$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# us.hcnn.model <- summary(sf.us.within.model4)
# us.hcnn.model.df <- data.frame(coef(us.hcnn.model)[,0:4])
# us.hcnn.model.df <- add_rownames(us.hcnn.model.df, "Parameter")
# us.hcnn.model.df %<>%
#   mutate(Model = "Highest Contiguous Next Number")%>%
#   mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Prod. Predictor", as.character(Parameter)), 
#          AIC = round(as.numeric(us.hcnn.model$AICtab[1]), 2), 
#          p.val = round(anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')[2,8], 5), 
#          chi.stat = round(anova(sf.us.within.base, sf.us.within.model4, test = 'LRT')[2,6], 2), 
#          Language = "English (US)")
# 
# 
# #join togther 
# all.models.unit <- bind_rows(hindi.prod.model.df, hindi.fhc.model.df, hindi.ihc.model.df, hindi.hcnn.model.df, 
#                              gujarati.prod.model.df, gujarati.fhc.model.df, gujarati.ihc.model.df, gujarati.hcnn.model.df, 
#                              us.prod.model.df, us.fhc.model.df, us.ihc.model.df, us.hcnn.model.df) 
# 
# all.models.unit %<>%
#   filter(Parameter != "(Intercept)")%>%
#   mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
#                             ifelse(Parameter == "count_rangeWithin", "Within IHC", 
#                                    ifelse(Parameter == "Prod. Predictor", "Productivity predictor", "Age"))))%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "Productivity predictor")))%>%
#   mutate(colors = ifelse((Parameter == "Age" | Parameter == "Item magnitude" | Parameter == "Within IHC"), as.character(Parameter), 
#                          as.character(Model))) %>%
#   mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Initial Highest Count", 
#                                           "Highest Contiguous Next Number"))) %>%
#   mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
#   mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (US)")))
# 
# data.r <- all.models.unit %>%
#   distinct(Language, Model, AIC, chi.stat, p.val)
# 
# quartz()
# model.vis.india <- all.models.unit %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   facet_grid(Model~Language)+
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 10) +
#   coord_flip() +
#   scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
#   geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
#             x = 1.5, y = 1, size = 2.5,
#             data = data.r) + 
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")



####FINAL MODELS####

hindi.final <- summary(sf.hindi.within.plus2.hc)
hindi.final.df <- data.frame(coef(hindi.final)[,0:4])
hindi.final.df <- add_rownames(hindi.final.df, "Parameter")
hindi.final.df %<>%
  mutate(Language = "Hindi")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "IHC", 
                            ifelse(Parameter == "highest_contig.c", "HCNN", as.character(Parameter))), 
         AIC = round(as.numeric(hindi.final$AICtab[1]), 2), 
         p.val = round(anova(sf.hindi.within.plus1, sf.hindi.within.plus2.hc, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.hindi.within.plus1, sf.hindi.within.plus2.hc, test = 'LRT')[2,6], 2))

gujarati.final <- summary(sf.gujarati.within.base)
gujarati.final.df <- data.frame(coef(gujarati.final)[,0:4])
gujarati.final.df <- add_rownames(gujarati.final.df, "Parameter")
gujarati.final.df %<>%
  mutate(Language = "Gujarati")%>%
  mutate(AIC = NA, 
         p.val = NA, 
         chi.stat = NA)

us.final <- summary(sf.us.within.plus2.highest.contig)
us.final.df <- data.frame(coef(us.final)[,0:4])
us.final.df <- add_rownames(us.final.df, "Parameter")
us.final.df %<>%
  mutate(Language = "English (US)")%>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "HCNN", 
                            ifelse(Parameter == "ihc.c", "IHC", as.character(Parameter))), 
         AIC = round(as.numeric(us.final$AICtab[1]), 2), 
         p.val = round(anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.us.within.plus1, sf.us.within.plus2.highest.contig, test = 'LRT')[2,6], 2))

all.models.final.india <- bind_rows(hindi.final.df, gujarati.final.df, us.final.df)

all.models.final.india %<>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "(Intercept)", "Intercept", 
                                          ifelse(Parameter == "age.c", "Age", as.character(Parameter))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("IHC", "HCNN", "Intercept", "Age", "Item magnitude", "Within IHC")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (US)")))

data.r <- all.models.final.india %>%
  distinct(Language, Model, AIC, chi.stat, p.val)

all.models.final.india %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Language, scale = "free_x") +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 13) +
  # coord_flip() +
  scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s", chi.stat, p.val)),
            x = 4.1, y = .9, size = 3.5,
            data = data.r) + 
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)") + 
  theme(axis.text.x = element_text(angle = 35, hjust = 1))
```


---

##Productivity t-test of Unit Task performance
Using the Productive/Non-Productive categorical classification outlined above, we will compare performance
between both groups on the Unit task using t-tests. We may do this by considering average performance
(averaring the 0’s and 1’s on each task for each participant); should doing so provide greater precision, we may also compare Highest Contiguous Number.

###HK: Marginally significant difference between groups (*p* = .06)
```{r}
#with mean performance
sf.hk.mean.ms <- all.data %>%
  filter(Language == "Cantonese", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.hk.mean.ms, Productive == "Productive")$mean, 
       subset(sf.hk.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #marginally significant difference between productive and nonproductive counters for performance on Unit Task
```

###SLO
```{r}
#with mean performance
sf.slo.mean.ms <- all.data %>%
  filter(Language == "Slovenian", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.slo.mean.ms, Productive == "Productive")$mean, 
       subset(sf.slo.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###US
```{r}
#with mean performance
sf.us.mean.ms <- all.data %>%
  filter(Language == "English (US)", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.us.mean.ms, Productive == "Productive")$mean, 
       subset(sf.us.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###Hindi
```{r}
#with mean performance
sf.hindi.mean.ms <- all.data %>%
  filter(Language == "Hindi", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.hindi.mean.ms, Productive == "Productive")$mean, 
       subset(sf.hindi.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###Gujarati
```{r}
#with mean performance
sf.gujarati.mean.ms <- all.data %>%
  filter(Language == "Gujarati", 
         Task == "SF")%>%
  group_by(SID, Productive)%>% 
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.gujarati.mean.ms, Productive == "Productive")$mean, 
       subset(sf.gujarati.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

###Indian English
```{r}
#with mean performance
sf.ind.eng.mean.ms <- all.data %>%
  filter(Language == "English (India)", 
         Task == "SF")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(sf.ind.eng.mean.ms, Productive == "Productive")$mean, 
       subset(sf.ind.eng.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #significant difference in performance between productive and nonproductive counters
```

---

#T-tests
##Productivity t-test of Highest contiguous NN
###HK: Significant difference between groups (*p* = .002)
```{r}
sf.hk.mean.nn <- all.data %>%
  filter(Language == "Cantonese")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.hk.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.hk.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```

###SLO - sig, p < .0001
```{r}
sf.slo.mean.nn <- all.data %>%
  filter(Language == "Slovenian")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.slo.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.slo.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```


###US - sig, p < .0001
```{r}
sf.us.mean.nn <- all.data %>%
  filter(Language == "English (US)")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.us.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.us.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```

###India-Eng
```{r}
sf.ind.eng.mean.nn <- all.data %>%
  filter(Language == "English (India)")%>%
  distinct(SID, Productive, highest_contig)%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.ind.eng.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.ind.eng.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```

###Hindi
```{r}
sf.hindi.mean.nn <- all.data %>%
  filter(Language == "Hindi")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.hindi.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.hindi.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```


###Gujarati
```{r}
sf.gujarati.mean.nn <- all.data %>%
  filter(Language == "Gujarati")%>%
  group_by(SID, Productive)%>%
  summarise(mean_nn = mean(highest_contig, na.rm = TRUE))

t.test(subset(sf.gujarati.mean.nn, Productive == "Productive")$mean_nn, 
       subset(sf.gujarati.mean.nn, Productive == "Nonproductive")$mean_nn, var.equal = TRUE)
```

---

#WCN Task- within-language analyses, simple models

All models will be logistic mixed effects models, predicting next number performance (0 or 1) on a trial as a function of the following predictors, with a random intercept for subject. In R, the formula will be glmer(predictedSF_correct ~ (predictor) + age + within/outside range + (1|subject), family = binomial).

-  Model 0 (null model): NextNumber.Performance ~ Within/Outside range + Age + (1|subject)
-  Model 1: Next.Number.Performance ~ Productivity + Within/Outside range + Age + (1|subject)
-  Model 2: Next.Number.Performance ~ Final.Count + Within/Outside range + Age + (1|subject)
-  Model 3: Next.Number.Performance ~ Initial.Count + Within/Outside range + Age + (1|subject)

In each language, after running these first three models, any predictor that significantly (p <.05) predicted Next Number Performance (as assessed by running a likelihood ratio test on the Null Model (Model 0) and Models 1, 2, and 3) will be added into Model 6, which will be our “Large” model (containing all predictors that significantly predicted Next Number Task Performance in the simple models). We will construct model 6 hierarchically. Model comparisons will be performed at each stage by running a likelihood ratio test between reduced and full models, with significant effects retained in the full model (Model 6). Model selection will be done on the basis of AIC evaluation and significant Chi-square statistic.

#HK: Within-language analyses, Next Number Task
##Build the models
```{r}
#base
wcn.hk.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#productivity
wcn.hk.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#FHC
wcn.hk.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)
#IHC
wcn.hk.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hk.within)

#exp - prod gradient
wcn.hk.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                  family = "binomial", data = wcn.hk.within)
```

##Hong Kong: NN task models
```{r}
mtable.wcn.hk <- mtable('Base Model' = wcn.hk.within.base,
            'Model 1: Productivity' = wcn.hk.within.model1,
            'Model 2: FHC' = wcn.hk.within.model2,
            'Model 3: IHC' = wcn.hk.within.model3,
            'Exp: Prod. gradient' = wcn.hk.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.hk
```

##Model comparisons
###Base v. Productivity - NS, p = .36
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 34.33, p < .0001, AIC = 1171.2
````{r}
anova(wcn.hk.within.base, wcn.hk.within.model2, test = 'LRT')
````

###Base v. IHC = Sig, Chisq(1) = 68.63, p < .0001, AIC = 1136.9
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model3, test = 'LRT')
```

###Exploratory - prod. gradient - Sig, Prod. 
```{r}
anova(wcn.hk.within.base, wcn.hk.within.model.gain, test = 'LRT')
```

##Ranking of HK prod. predictors - WCN by AIC
1.  IHC - 1136.9
2.  FHC - 1171.2
3.  Productivity - 1206.7 (NS)


##Large Model
```{r}
#IHC
wcn.hk.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hk.within)
#IHC + FHC
wcn.hk.within.plus2 <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.hk.within)

#compare IHC and FHC
anova(wcn.hk.within.plus1, wcn.hk.within.plus2, test = 'LRT') 

#exp - prod.gradient
wcn.hk.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hk.within)
#anova
anova(wcn.hk.within.plus1, wcn.hk.within.plus.gain, test = 'LRT')

mtable.wcn.hk.large <- mtable('IHC alone' = wcn.hk.within.plus1,
            'IHC + FHC' = wcn.hk.within.plus2,
            'Exp: IHC + Gradient' = wcn.hk.within.plus.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.hk.large

summary(wcn.hk.within.plus1)
```



##HK NN Task within-language results: IHC emerge as best predictor of performance on Unit Task
```{r}
full.model.wcn.hk <- summary(wcn.hk.within.plus1)

AIC <- as.numeric(full.model.wcn.hk$AICtab[1])

full.model.df.wcn.hk <- data.frame(coef(full.model.wcn.hk)[,0:4])
full.model.df.wcn.hk <- add_rownames(full.model.df.wcn.hk, "Parameter")

full.model.df.wcn.hk %<>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "IHC",
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept"))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "IHC")))

full.model.df.wcn.hk %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

---

#SLO: Within-language analyses, NN Task
##Build the models
```{r}
#Base
wcn.slo.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#Productivity
wcn.slo.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#FHC
wcn.slo.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)
#IHC
wcn.slo.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.slo.within)

#Explore - prod gradient
wcn.slo.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), 
                                   family = "binomial", data = wcn.slo.within)
```

##SLO: NN task models
```{r}
mtable.wcn.slo <- mtable('Base Model' = wcn.slo.within.base,
            'Model 1: Productivity' = wcn.slo.within.model1,
            'Model 2: FHC' = wcn.slo.within.model2,
            'Model 3: IHC' = wcn.slo.within.model3,
            'Exp: Prod. gradient' = wcn.slo.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.slo
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 20.6, p < .0001, AIC = 847.12
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 41.96, p < .0001, AIC = 825.76
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 15.07 p = .0001, AIC = 865.81
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model3, test = 'LRT')
```

###Productivity gradient - Sig, Chisq(1) = 25.37, p < .0001, AIC = 842.35
```{r}
anova(wcn.slo.within.base, wcn.slo.within.model.gain, test = 'LRT')
```
##Ranking of prod predictors - WCN by AIC
1.  FHC - 839.09
2.  Productivity - 855.51
3.  IHC - 865.81


##Large Model comparison
```{r}
#FHC
wcn.slo.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.slo.within)
#IHC + FHC
wcn.slo.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.slo.within)
#Prod + FHC
wcn.slo.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.slo.within)
#IHC + PROD + FHC
wcn.slo.within.plus3 <- glmer(Correct ~ ihc.c + Productive + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.slo.within)

#Compare3 minus Prod
anova(wcn.slo.within.plus1, wcn.slo.within.plus2, wcn.slo.within.plus3, test = 'LRT') 
#Compare3 minus FHC
anova(wcn.slo.within.plus1, wcn.slo.within.plus2.prod, wcn.slo.within.plus3, test = 'LRT') 

summary(wcn.slo.within.plus1)

mtable.wcn.slo.large <- mtable('FHC alone' = wcn.slo.within.plus1,
            'IHC + FHC' = wcn.slo.within.plus2,
            'Prod. + FHC' = wcn.slo.within.plus2.prod,
            'IHC + Prod. + FHC' = wcn.slo.within.plus3,
             summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.slo.large

# #add prod gradient
# wcn.slo.within.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
#                              family = "binomial", 
#                            data = wcn.slo.within)
# anova(wcn.slo.within.plus1, wcn.slo.within.plus.gain, test = 'LRT')
# 
# summary(wcn.slo.within.plus.gain)
```

##SLO NN Task (interim) within-language results: FHC emerges as best predictors of performance on Unit Task
```{r}
summary(wcn.slo.within.plus1)

full.model.wcn.slo <- summary(wcn.slo.within.plus1)

AIC <- as.numeric(full.model.wcn.slo$AICtab[1])

full.model.df.wcn.slo <- data.frame(coef(full.model.wcn.slo)[,0:4])
full.model.df.wcn.slo <- add_rownames(full.model.df.wcn.slo, "Parameter")

full.model.df.wcn.slo %<>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC",
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept"))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "FHC")))

full.model.df.wcn.slo %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#US: Within-language analyses, NN Task
##Build the models
```{r}
#base
wcn.us.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#productivity
wcn.us.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#FHC
wcn.us.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
#IHC
wcn.us.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)

#Explore - prod gradient
wcn.us.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.us.within)
```

##English (US): NN Task models
```{r}
mtable.wcn.us <- mtable('Base Model' = wcn.us.within.base,
            'Model 1: Productivity' = wcn.us.within.model1,
            'Model 2: FHC' = wcn.us.within.model2,
            'Model 3: IHC' = wcn.us.within.model3,
            'Exp: Prod. gradient' = wcn.us.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.us
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 14.8, p = .0001, AIC = 1042.3
```{r}
anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 44, p < .0001, AIC = 1013
```{r}
anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 30.52, p < .0001, AIC = 1026.5
```{r}
anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')
```

###Prod gradient
```{r}
anova(wcn.us.within.base, wcn.us.within.model.gain, test = 'LRT')
```

##Ranking of prod predictors - WCN by AIC
1.  FHC - 1013
2.  IHC - 1026.5
3.  Productivity - 1042.3

##Large Model comparison
```{r}
#FHC
wcn.us.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.us.within)
#IHC + FHC
wcn.us.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + 
                               age.c + (1|SID), 
                            family = "binomial", data = wcn.us.within)
#Prod + FHC
wcn.us.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c + 
                                    age.c + (1|SID), 
                            family = "binomial", data = wcn.us.within)
#IHC + PROD + FHC
wcn.us.within.plus3 <- glmer(Correct ~ ihc.c + Productive + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.us.within, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Compare 3 minus Prod
anova(wcn.us.within.plus1, wcn.us.within.plus2, wcn.us.within.plus3, test = 'LRT') 
#Compare 3 minus IHC
anova(wcn.us.within.plus1, wcn.us.within.plus2.prod, wcn.us.within.plus3, test = 'LRT') 
summary(wcn.us.within.plus1)

mtable.wcn.us.large <- mtable('FHC alone' = wcn.us.within.plus1,
            'IHC + FHC' = wcn.us.within.plus2,
            'Prod. + FHC' = wcn.us.within.plus2.prod,
            'IHC + Prod. + FHC' = wcn.us.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.us.large

# #add prod. gradient, compare
# wcn.us.within.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + count_range + starting_num.c + age.c + (1|SID), 
#                              family = "binomial", 
#                            data = wcn.us.within)
# anova(wcn.us.within.plus1, wcn.us.within.plus.gain, test = 'LRT')
```

##US NN Task (interim) within-language results: FHC emerges as best predictor of performance on Unit Task
```{r}
full.model.wcn.us <- summary(wcn.us.within.plus1)

AIC <- as.numeric(full.model.wcn.us$AICtab[1])

full.model.df.wcn.us <- data.frame(coef(full.model.wcn.us)[,0:4])
full.model.df.wcn.us <- add_rownames(full.model.df.wcn.us, "Parameter")

full.model.df.wcn.us %<>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC",
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept"))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "FHC")))

full.model.df.wcn.us%>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

##Visualizations

```{r, echo = TRUE}
#Get all the parameters in one model, then add column for parameter so we can graph all the individual models at once
#

#HK
#productivity
hk.prod.model.wcn <- summary(wcn.hk.within.model1)
hk.prod.model.wcn.df <- data.frame(coef(hk.prod.model.wcn)[,0:4])
hk.prod.model.wcn.df <- add_rownames(hk.prod.model.wcn.df, "Parameter")
hk.prod.model.wcn.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.hk.within.base, wcn.hk.within.model1, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.hk.within.base, wcn.hk.within.model1, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.prod.model.wcn$AICtab[1]), 2), 
         Language = "Cantonese")

#FHC
hk.fhc.model.wcn <- summary(wcn.hk.within.model2)
hk.fhc.model.wcn.df <- data.frame(coef(hk.fhc.model.wcn)[,0:4])
hk.fhc.model.wcn.df <- add_rownames(hk.fhc.model.wcn.df, "Parameter")
hk.fhc.model.wcn.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.hk.within.base, wcn.hk.within.model2, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.hk.within.base, wcn.hk.within.model2, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.fhc.model.wcn$AICtab[1]), 2), 
         Language = "Cantonese")

#IHC
hk.ihc.model.wcn <- summary(wcn.hk.within.model3)
hk.ihc.model.wcn.df <- data.frame(coef(hk.ihc.model.wcn)[,0:4])
hk.ihc.model.wcn.df <- add_rownames(hk.ihc.model.wcn.df, "Parameter")
hk.ihc.model.wcn.df %<>%
  mutate(Model = "Initial Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.hk.within.base, wcn.hk.within.model3, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.hk.within.base, wcn.hk.within.model3, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.ihc.model.wcn$AICtab[1]), 2), 
         Language = "Cantonese")

##SLO##
#productivity
slo.prod.model.wcn <- summary(wcn.slo.within.model1)
slo.prod.model.wcn.df <- data.frame(coef(slo.prod.model.wcn)[,0:4])
slo.prod.model.wcn.df <- add_rownames(slo.prod.model.wcn.df, "Parameter")
slo.prod.model.wcn.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.slo.within.base, wcn.slo.within.model1, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.slo.within.base, wcn.slo.within.model1, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(slo.prod.model.wcn$AICtab[1]), 2), 
         Language = "Slovenian")

#FHC
slo.fhc.model.wcn <- summary(wcn.slo.within.model2)
slo.fhc.model.wcn.df <- data.frame(coef(slo.fhc.model.wcn)[,0:4])
slo.fhc.model.wcn.df <- add_rownames(slo.fhc.model.wcn.df, "Parameter")
slo.fhc.model.wcn.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.slo.within.base, wcn.slo.within.model2, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.slo.within.base, wcn.slo.within.model2, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(slo.fhc.model.wcn$AICtab[1]), 2), 
         Language = "Slovenian")

#IHC
slo.ihc.model.wcn <- summary(wcn.slo.within.model3)
slo.ihc.model.wcn.df <- data.frame(coef(slo.ihc.model.wcn)[,0:4])
slo.ihc.model.wcn.df <- add_rownames(slo.ihc.model.wcn.df, "Parameter")
slo.ihc.model.wcn.df %<>%
  mutate(Model = "Initial Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.slo.within.base, wcn.slo.within.model3, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.slo.within.base, wcn.slo.within.model3, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(slo.ihc.model.wcn$AICtab[1]), 2), 
         Language = "Slovenian")


##US##
#productivity
us.prod.model.wcn <- summary(wcn.us.within.model1)
us.prod.model.wcn.df <- data.frame(coef(us.prod.model.wcn)[,0:4])
us.prod.model.wcn.df <- add_rownames(us.prod.model.wcn.df, "Parameter")
us.prod.model.wcn.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(us.prod.model.wcn$AICtab[1]), 2), 
         Language = "English (US)")

#FHC
us.fhc.model.wcn <- summary(wcn.us.within.model2)
us.fhc.model.wcn.df <- data.frame(coef(us.fhc.model.wcn)[,0:4])
us.fhc.model.wcn.df <- add_rownames(us.fhc.model.wcn.df, "Parameter")
us.fhc.model.wcn.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(us.fhc.model.wcn$AICtab[1]), 2), 
         Language = "English (US)")

#IHC
us.ihc.model.wcn <- summary(wcn.us.within.model3)
us.ihc.model.wcn.df <- data.frame(coef(us.ihc.model.wcn)[,0:4])
us.ihc.model.wcn.df <- add_rownames(us.ihc.model.wcn.df, "Parameter")
us.ihc.model.wcn.df %<>%
  mutate(Model = "Initial Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
         p.val = round(anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(us.ihc.model.wcn$AICtab[1]), 2), 
         Language = "English (US)")
#join togther 
all.models.wcn <- bind_rows(hk.prod.model.wcn.df, hk.fhc.model.wcn.df, hk.ihc.model.wcn.df, 
                            slo.prod.model.wcn.df, slo.fhc.model.wcn.df, slo.ihc.model.wcn.df, 
                            us.prod.model.wcn.df, us.fhc.model.wcn.df, us.ihc.model.wcn.df) 

all.models.wcn %<>%
  filter(Parameter != "(Intercept)")%>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "Prod. Predictor", "Productivity predictor", "Age"))))%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "Productivity predictor")))%>%
  mutate(colors = ifelse((Parameter == "Age" | Parameter == "Item magnitude" | Parameter == "Within IHC"), as.character(Parameter), 
                         as.character(Model))) %>%
  mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Initial Highest Count"))) %>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
  mutate(Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)")))

data.r <- all.models.wcn %>%
  distinct(Language, Model, AIC, chi.stat, p.val)

all.models.wcn %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(Language~Model)+
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 10) +
  coord_flip() +
  scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 1.5, y = 2, size = 2.5,
            data = data.r) + 
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#India English: Within-language analyses, NN task

Build the models
```{r}
#Base Model
wcn.ind.eng.within.base <- glmer(Correct ~ count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#Productivity
wcn.ind.eng.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#FHC
wcn.ind.eng.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
#IHC
wcn.ind.eng.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)

#prod.gradient
wcn.ind.eng.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.ind.eng.within)
```

---

##English (India) WCN Models 
Summary
```{r}
mtable.ind.eng <- mtable('Base Model' = wcn.ind.eng.within.base,
            'Model 1: Productivity' = wcn.ind.eng.within.model1,
            'Model 2: FHC' = wcn.ind.eng.within.model2,
            'Model 3: IHC' = wcn.ind.eng.within.model3,
            'Exp: Prod. gradient' = wcn.ind.eng.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.ind.eng
```

##Model comparisons
###Base v. Productivity - NS
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 21.1, p < .0001, AIC = 678.7
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 19.49, p < .0001, AIC = 680.30
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model3, test = 'LRT')
```

###Base v. prod. gradient - marginal
```{r}
anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model.gain, test = 'LRT')
```

##Large Model

```{r}
#FHC
wcn.ind.eng.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.ind.eng.within)
#IHC + FHC
wcn.ind.eng.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = wcn.ind.eng.within)

anova(wcn.ind.eng.within.plus1, wcn.ind.eng.within.plus2,test = 'LRT') 

mtable.wcn.ind.eng.large <- mtable('FHC alone' = wcn.ind.eng.within.plus1,
            'IHC + FHC' = wcn.ind.eng.within.plus2,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.ind.eng.large

summary(wcn.ind.eng.within.plus2)
```

##English (India) NN Task within-language results: IHC and FHC emerge as best predictors of performance on Unit Task
```{r}
summary(wcn.ind.eng.within.plus2)

full.model.wcn.ind.eng <- summary(wcn.ind.eng.within.plus2)

AIC <- as.numeric(full.model.wcn.ind.eng$AICtab[1])

full.model.df.wcn.ind.eng <- data.frame(coef(full.model.wcn.ind.eng)[,0:4])
full.model.df.wcn.ind.eng <- add_rownames(full.model.df.wcn.ind.eng, "Parameter")

full.model.df.wcn.ind.eng %<>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC",
                              ifelse(Parameter == "ihc.c", "IHC", 
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "IHC", "FHC")))

full.model.df.wcn.ind.eng %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#Hindi: Within-language analyses, NN
##Build the models
```{r}
#Base Model
wcn.hindi.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c  + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#Productivity
wcn.hindi.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c + age.c +(1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#FHC
wcn.hindi.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +(1|SID), family = "binomial", 
                            data = wcn.hindi.within)
#IHC
wcn.hindi.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)

#Exp- prod.gradient
wcn.hindi.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.hindi.within)

```

##Hindi: NN Task models 
Summary
```{r}
mtable.hindi <- mtable('Base Model' = wcn.hindi.within.base,
            'Model 1: Productivity' = wcn.hindi.within.model1,
            'Model 2: FHC' = wcn.hindi.within.model2,
            'Model 3: IHC' = wcn.hindi.within.model3,
            'Exp: Prod. gradient' = wcn.hindi.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.hindi
```

##Model comparisons
###Base v. Productivity - sig, Chisq(1) = 4.5, p = .03, AIC = 850.45
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model1, test = 'LRT')
```

###Base v. FHC - sig, Chisq(1) = 27.4, p < .0001, AIC = 827.62
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model2, test = 'LRT')
```

###Base v. IHC - Sig, Chisq(1) = 33.41, p < .0001, AIC = 821.6
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model3, test = 'LRT')
```

###Base v. Prod. gradient - Sig, Chisq(1) = 10.03, p = .001, AIC = 844.97
```{r}
anova(wcn.hindi.within.base, wcn.hindi.within.model.gain, test = 'LRT')
```

##Ranking of NN predictors, HIndi, by AIC
1.  IHC - 821.6
2.  FHC - 827.6
3.  Productivity - 850


##Large Model
```{r}
#IHC
wcn.hindi.within.plus1 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hindi.within)
#FHC + IHC
wcn.hindi.within.plus2 <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                            family = "binomial", data = wcn.hindi.within)

#Prod + IHC
wcn.hindi.within.plus2.prod <- glmer(Correct ~ Productive + ihc.c + count_range + starting_num.c +age.c +  (1|SID), 
                            family = "binomial", data = wcn.hindi.within)
#Prod + FHC + IHC
wcn.hindi.within.plus3 <- glmer(Correct ~ Productive + fhc.c + ihc.c + count_range + starting_num.c +age.c +  (1|SID), 
                            family = "binomial", data = wcn.hindi.within)

#IHC v. IHC+FHC
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2, test = 'LRT') 
#IHC v. Prod + FHC
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus2.prod, test = 'LRT') 

mtable.wcn.hindi.large <- mtable('IHC alone' = wcn.hindi.within.plus1,
            'IHC + FHC' = wcn.hindi.within.plus2,
            'Prod. + iHC' = wcn.hindi.within.plus2.prod,
            'Prod + FHC + IHC' = wcn.hindi.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.hindi.large

#Add Prod. gradient, test
wcn.hindi.within.plus.gain <- glmer(Correct ~ prod.gradient + ihc.c + count_range + starting_num.c + age.c + (1|SID), 
                             family = "binomial", 
                           data = wcn.hindi.within)
anova(wcn.hindi.within.plus1, wcn.hindi.within.plus.gain, test = 'LRT')

summary(wcn.hindi.within.plus1)
```

##Hindi NN Task within-language results: IHC emerges as best predictor of performance on Unit Task
```{r}
summary(wcn.hindi.within.plus1)

full.model.wcn.hindi <- summary(wcn.hindi.within.plus1)

AIC <- as.numeric(full.model.wcn.hindi$AICtab[1])

full.model.df.wcn.hindi <- data.frame(coef(full.model.wcn.hindi)[,0:4])
full.model.df.wcn.hindi <- add_rownames(full.model.df.wcn.hindi, "Parameter")

full.model.df.wcn.hindi %<>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC",
                              ifelse(Parameter == "ihc.c", "IHC", 
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "IHC", "FHC")))

full.model.df.wcn.hindi %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#Gujarati: Within-language analyses, NN
##Build the models
```{r}
#Base Model
wcn.gujarati.within.base <- glmer(Correct ~ count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#Productivity
wcn.gujarati.within.model1 <- glmer(Correct ~ Productive + count_range + starting_num.c +age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#FHC
wcn.gujarati.within.model2 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
#IHC
wcn.gujarati.within.model3 <- glmer(Correct ~ ihc.c + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)

#Exp. - prod. gradient
wcn.gujarati.within.model.gain <- glmer(Correct ~ prod.gradient + count_range + starting_num.c + age.c + (1|SID), family = "binomial", 
                            data = wcn.gujarati.within)
```

##Gujarati: NN Task models 
Summary
```{r}
mtable.gujarati <- mtable('Base Model' = wcn.gujarati.within.base,
            'Model 1: Productivity' = wcn.gujarati.within.model1,
            'Model 2: FHC' = wcn.gujarati.within.model2,
            'Model 3: IHC' = wcn.gujarati.within.model3,
            'Exp: Prod. gradient' = wcn.gujarati.within.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.gujarati
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 10.06, p = .002, AIC = 787.41
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 36.25, p < .0001, AIC  761.2
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model2, test = 'LRT')
```

###Base v. IHC = Sig, Chisq(1) = 33.45, p < .0001, AIC = 764.02
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model3, test = 'LRT')
```

###Base v. Prod. gradient
```{r}
anova(wcn.gujarati.within.base, wcn.gujarati.within.model.gain, test = 'LRT')
```

##Ranking of NN Predictors, Gujarati, by AIC 
1.  FHC - 761.2
2.  IHC - 764.02
3.  Productivity - 787

##Large Model
```{r}
#FHC
wcn.gujarati.within.plus1 <- glmer(Correct ~ fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.gujarati.within)
#IHC + FHC
wcn.gujarati.within.plus2 <- glmer(Correct ~ ihc.c + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                            family = "binomial", data = wcn.gujarati.within)
#Prod + FHC
wcn.gujarati.within.plus2.prod <- glmer(Correct ~ Productive + fhc.c + count_range + starting_num.c +age.c +  (1|SID), 
                            family = "binomial", data = wcn.gujarati.within)

wcn.gujarati.within.plus3 <- glmer(Correct ~ ihc.c + Productive + fhc.c + count_range + age.c + starting_num.c + (1|SID), 
                            family = "binomial", data = wcn.gujarati.within)

#FHC v FHC+IHC
anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2, test = 'LRT') 
#FHC v. FHC+Prod
anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2.prod, test = 'LRT') 

mtable.wcn.gujarati.large <- mtable('FHC alone' = wcn.gujarati.within.plus1,
            'IHC + FHC' = wcn.gujarati.within.plus2,
            'Prod. + FHC' = wcn.gujarati.within.plus2.prod,
            'IHC + Prod. + FHC' = wcn.gujarati.within.plus3,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.gujarati.large

#add prod.gradient, compare
wcn.gujarati.within.plus.gain <- glmer(Correct ~ prod.gradient + Productive + fhc.c + count_range + starting_num.c + age.c +  (1|SID), 
                             family = "binomial", 
                           data = wcn.gujarati.within)
anova(wcn.gujarati.within.plus2, wcn.gujarati.within.plus.gain, test = 'LRT')

summary(wcn.gujarati.within.plus2.prod)
summary(wcn.gujarati.within.plus.gain)
```

##Gujarati NN Task within-language results: FHC and Productivity emerge as best predictor of performance on Unit Task
```{r}
summary(wcn.gujarati.within.plus2.prod)

full.model.wcn.gujarati <- summary(wcn.gujarati.within.plus2.prod)

AIC <- as.numeric(full.model.wcn.gujarati$AICtab[1])

full.model.df.wcn.gujarati <- data.frame(coef(full.model.wcn.gujarati)[,0:4])
full.model.df.wcn.gujarati <- add_rownames(full.model.df.wcn.gujarati, "Parameter")

full.model.df.wcn.gujarati %<>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC",
                              ifelse(Parameter == "ProductiveProductive", "Productive", 
                                   ifelse(Parameter == "count_rangeWithin", "Within IHC",
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "starting_num.c", "Item magnitude", "Intercept")))))) %>%
  filter(Parameter != "Intercept")%>%
  mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "Productive", "FHC")))

full.model.df.wcn.gujarati %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 10), 
        legend.position = "none") +
  coord_flip() +
  langcog::scale_color_solarized() +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

##Visualizations

```{r, echo = TRUE}
# #Get all the parameters in one model, then add column for parameter so we can graph all the individual models at once
# #
# 
# #Hindi
# #productivity
# hindi.prod.model.wcn <- summary(wcn.hindi.within.model1)
# hindi.prod.model.wcn.df <- data.frame(coef(hindi.prod.model.wcn)[,0:4])
# hindi.prod.model.wcn.df <- add_rownames(hindi.prod.model.wcn.df, "Parameter")
# hindi.prod.model.wcn.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.hindi.within.base, wcn.hindi.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.hindi.within.base, wcn.hindi.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.prod.model.wcn$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# #FHC
# hindi.fhc.model.wcn <- summary(wcn.hindi.within.model2)
# hindi.fhc.model.wcn.df <- data.frame(coef(hindi.fhc.model.wcn)[,0:4])
# hindi.fhc.model.wcn.df <- add_rownames(hindi.fhc.model.wcn.df, "Parameter")
# hindi.fhc.model.wcn.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.hindi.within.base, wcn.hindi.within.model2, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.hindi.within.base, wcn.hindi.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.fhc.model.wcn$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# #IHC
# hindi.ihc.model.wcn <- summary(wcn.hindi.within.model3)
# hindi.ihc.model.wcn.df <- data.frame(coef(hindi.ihc.model.wcn)[,0:4])
# hindi.ihc.model.wcn.df <- add_rownames(hindi.ihc.model.wcn.df, "Parameter")
# hindi.ihc.model.wcn.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.hindi.within.base, wcn.hindi.within.model3, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.hindi.within.base, wcn.hindi.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(hindi.ihc.model.wcn$AICtab[1]), 2), 
#          Language = "Hindi")
# 
# ##Gujarati##
# #productivity
# gujarati.prod.model.wcn <- summary(wcn.gujarati.within.model1)
# gujarati.prod.model.wcn.df <- data.frame(coef(gujarati.prod.model.wcn)[,0:4])
# gujarati.prod.model.wcn.df <- add_rownames(gujarati.prod.model.wcn.df, "Parameter")
# gujarati.prod.model.wcn.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.prod.model.wcn$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# #FHC
# gujarati.fhc.model.wcn <- summary(wcn.gujarati.within.model2)
# gujarati.fhc.model.wcn.df <- data.frame(coef(gujarati.fhc.model.wcn)[,0:4])
# gujarati.fhc.model.wcn.df <- add_rownames(gujarati.fhc.model.wcn.df, "Parameter")
# gujarati.fhc.model.wcn.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model2, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.fhc.model.wcn$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# #IHC
# gujarati.ihc.model.wcn <- summary(wcn.gujarati.within.model3)
# gujarati.ihc.model.wcn.df <- data.frame(coef(gujarati.ihc.model.wcn)[,0:4])
# gujarati.ihc.model.wcn.df <- add_rownames(gujarati.ihc.model.wcn.df, "Parameter")
# gujarati.ihc.model.wcn.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model3, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.gujarati.within.base, wcn.gujarati.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(gujarati.ihc.model.wcn$AICtab[1]), 2), 
#          Language = "Gujarati")
# 
# 
# ##US##
# #productivity
# us.prod.model.wcn <- summary(wcn.us.within.model1)
# us.prod.model.wcn.df <- data.frame(coef(us.prod.model.wcn)[,0:4])
# us.prod.model.wcn.df <- add_rownames(us.prod.model.wcn.df, "Parameter")
# us.prod.model.wcn.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.prod.model.wcn$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# #FHC
# us.fhc.model.wcn <- summary(wcn.us.within.model2)
# us.fhc.model.wcn.df <- data.frame(coef(us.fhc.model.wcn)[,0:4])
# us.fhc.model.wcn.df <- add_rownames(us.fhc.model.wcn.df, "Parameter")
# us.fhc.model.wcn.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.fhc.model.wcn$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# #IHC
# us.ihc.model.wcn <- summary(wcn.us.within.model3)
# us.ihc.model.wcn.df <- data.frame(coef(us.ihc.model.wcn)[,0:4])
# us.ihc.model.wcn.df <- add_rownames(us.ihc.model.wcn.df, "Parameter")
# us.ihc.model.wcn.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.us.within.base, wcn.us.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(us.ihc.model.wcn$AICtab[1]), 2), 
#          Language = "English (US)")
# 
# ##English - India##
# #productivity
# ind.eng.prod.model.wcn <- summary(wcn.ind.eng.within.model1)
# ind.eng.prod.model.wcn.df <- data.frame(coef(ind.eng.prod.model.wcn)[,0:4])
# ind.eng.prod.model.wcn.df <- add_rownames(ind.eng.prod.model.wcn.df, "Parameter")
# ind.eng.prod.model.wcn.df %<>%
#   mutate(Model = "Productivity")%>%
#   mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model1, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model1, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(ind.eng.prod.model.wcn$AICtab[1]), 2), 
#          Language = "English (India)")
# 
# #FHC
# ind.eng.fhc.model.wcn <- summary(wcn.ind.eng.within.model2)
# ind.eng.fhc.model.wcn.df <- data.frame(coef(ind.eng.fhc.model.wcn)[,0:4])
# ind.eng.fhc.model.wcn.df <- add_rownames(ind.eng.fhc.model.wcn.df, "Parameter")
# ind.eng.fhc.model.wcn.df %<>%
#   mutate(Model = "Final Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "fhc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model2, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model2, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(ind.eng.fhc.model.wcn$AICtab[1]), 2), 
#          Language = "English (India)")
# 
# #IHC
# ind.eng.ihc.model.wcn <- summary(wcn.ind.eng.within.model3)
# ind.eng.ihc.model.wcn.df <- data.frame(coef(ind.eng.ihc.model.wcn)[,0:4])
# ind.eng.ihc.model.wcn.df <- add_rownames(ind.eng.ihc.model.wcn.df, "Parameter")
# ind.eng.ihc.model.wcn.df %<>%
#   mutate(Model = "Initial Highest Count")%>%
#   mutate(Parameter = ifelse(Parameter == "ihc.c", "Prod. Predictor", as.character(Parameter)), 
#          p.val = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model3, test = 'LRT')[2,8], 2), 
#          chi.stat = round(anova(wcn.ind.eng.within.base, wcn.ind.eng.within.model3, test = 'LRT')[2,6], 2), 
#          AIC = round(as.numeric(ind.eng.ihc.model.wcn$AICtab[1]), 2), 
#          Language = "English (India)")
# #join togther 
# india.all.models.wcn <- bind_rows(hindi.prod.model.wcn.df, hindi.fhc.model.wcn.df, hindi.ihc.model.wcn.df, 
#                             gujarati.prod.model.wcn.df, gujarati.fhc.model.wcn.df, gujarati.ihc.model.wcn.df, 
#                             us.prod.model.wcn.df, us.fhc.model.wcn.df, us.ihc.model.wcn.df, 
#                             ind.eng.prod.model.wcn.df, ind.eng.fhc.model.wcn.df,ind.eng.ihc.model.wcn.df) 
# 
# india.all.models.wcn %<>%
#   filter(Parameter != "(Intercept)")%>%
#   mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
#                             ifelse(Parameter == "count_rangeWithin", "Within IHC", 
#                                    ifelse(Parameter == "Prod. Predictor", "Productivity predictor", "Age"))))%>%
#   mutate(Parameter = factor(Parameter, levels = c("Age", "Item magnitude", "Within IHC", "Productivity predictor")))%>%
#   mutate(colors = ifelse((Parameter == "Age" | Parameter == "Item magnitude" | Parameter == "Within IHC"), as.character(Parameter), 
#                          as.character(Model))) %>%
#   mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Initial Highest Count"))) %>%
#   mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
#   mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))
# 
# data.r <- india.all.models.wcn %>%
#   distinct(Language, Model, AIC, chi.stat, p.val)
# 
# india.all.models.wcn %>%
# ggplot(aes(x = Parameter, y = Estimate)) +
#   facet_grid(Language~Model)+
#   geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
#                       ymax = Estimate + 1.96 * Std..Error,
#                       colour = Parameter)) +
#   geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
#   theme_bw(base_size = 10) +
#   coord_flip() +
#   scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
#   geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
#             x = 1.5, y = 2, size = 2.5,
#             data = data.r) + 
#   xlab("") +
#   scale_y_continuous(name = "Coefficient Estimate (log likelihood)")

####FINAL MODELS####

hindi.final.wcn <- summary(wcn.hindi.within.plus1)
hindi.final.wcn.df <- data.frame(coef(hindi.final.wcn)[,0:4])
hindi.final.wcn.df <- add_rownames(hindi.final.wcn.df, "Parameter")
hindi.final.wcn.df %<>%
  mutate(Language = "Hindi")%>%
  mutate(Parameter = ifelse(Parameter == "ihc.c", "IHC", as.character(Parameter)), 
         AIC = round(as.numeric(hindi.final.wcn$AICtab[1]), 2), 
         p.val = round(anova(wcn.hindi.within.base, wcn.hindi.within.plus1, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.hindi.within.base, wcn.hindi.within.plus1, test = 'LRT')[2,6], 2))

gujarati.final.wcn <- summary(wcn.gujarati.within.plus2.prod)
gujarati.final.wcn.df <- data.frame(coef(gujarati.final.wcn)[,0:4])
gujarati.final.wcn.df <- add_rownames(gujarati.final.wcn.df, "Parameter")
gujarati.final.wcn.df %<>%
  mutate(Language = "Gujarati")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC", 
                            ifelse(Parameter == "ProductiveProductive", "Productive", as.character(Parameter))), 
         AIC = round(as.numeric(gujarati.final.wcn$AICtab[1]), 2), 
         p.val = round(anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2.prod, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.gujarati.within.plus1, wcn.gujarati.within.plus2.prod, test = 'LRT')[2,6], 2))

us.final.wcn <- summary(wcn.us.within.plus1)
us.final.wcn.df <- data.frame(coef(us.final.wcn)[,0:4])
us.final.wcn.df <- add_rownames(us.final.wcn.df, "Parameter")
us.final.wcn.df %<>%
  mutate(Language = "English (US)")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC", as.character(Parameter)), 
         AIC = round(as.numeric(us.final.wcn$AICtab[1]), 2), 
         p.val = round(anova(wcn.us.within.base, wcn.us.within.plus1, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.us.within.base, wcn.us.within.plus1, test = 'LRT')[2,6], 2))

ind.eng.final.wcn <- summary(wcn.ind.eng.within.plus2)
ind.eng.final.wcn.df <- data.frame(coef(ind.eng.final.wcn)[,0:4])
ind.eng.final.wcn.df <- add_rownames(ind.eng.final.wcn.df, "Parameter")
ind.eng.final.wcn.df %<>%
  mutate(Language = "English (India)")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "FHC", 
                            ifelse(Parameter == "ihc.c", "IHC", as.character(Parameter))), 
         AIC = round(as.numeric(ind.eng.final.wcn$AICtab[1]), 2), 
         p.val = round(anova(wcn.ind.eng.within.plus1, wcn.ind.eng.within.plus2, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.ind.eng.within.plus1, wcn.ind.eng.within.plus2, test = 'LRT')[2,6], 2))

all.models.final.india.wcn <- bind_rows(hindi.final.wcn.df, gujarati.final.wcn.df, us.final.wcn.df, ind.eng.final.wcn.df)

all.models.final.india.wcn %<>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "(Intercept)", "Intercept", 
                                          ifelse(Parameter == "age.c", "Age", as.character(Parameter))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("IHC", "FHC", "Productive", "Intercept", "Age", "Item magnitude", "Within IHC")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))%>%
  mutate(Language = factor(Language, levels = c("Hindi", "Gujarati", "English (India)", "English (US)")))

data.r <- all.models.final.india.wcn %>%
  distinct(Language, Model, AIC, chi.stat, p.val)

all.models.final.india.wcn %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Language, scale = "free_x") +
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 13) +
  # coord_flip() +
  scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s", chi.stat, p.val)),
            x = 4.1, y = 1.8, size = 3.5,
            data = data.r) + 
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)") + 
  theme(axis.text.x = element_text(angle = 35, hjust = 1))
```

---

##Productivity t-test of WCN performance
Using the Productive/Non-Productive categorical classification outlined above, we will compare performance
between both groups on the Next Number task using t-tests. We may do this by considering average performance
(averaring the 0’s and 1’s on each task for each participant).

###HK: Significant difference between productive and nonproductive counters (*p* = .002)
```{r}
#with mean performance
wcn.hk.mean.ms <- all.data %>%
  filter(Language == "Cantonese", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.hk.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.hk.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###SLO: Significant difference between groups (*p* < .0001)

```{r}
#with mean performance
wcn.slo.mean.ms <- all.data %>%
  filter(Language == "Slovenian", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.slo.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.slo.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###US: Significant difference between groups (*p* < .0001)

```{r}
#with mean performance
wcn.us.mean.ms <- all.data %>%
  filter(Language == "English (US)", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))


t.test(subset(wcn.us.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.us.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```


###Hindi

```{r}
#with mean performance
wcn.hindi.mean.ms <- all.data %>%
  filter(Language == "Hindi", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.hindi.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.hindi.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###Gujarati

```{r}
#with mean performance
wcn.gujarati.mean.ms <- all.data %>%
  filter(Language == "Gujarati", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.gujarati.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.gujarati.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

###Indian English

```{r}
#with mean performance
wcn.ind.eng.mean.ms <- all.data%>%
  filter(Language == "English (India)", 
         Task == "NN")%>%
  group_by(SID, Productive)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))

t.test(subset(wcn.ind.eng.mean.ms, Productive == "Productive")$mean, 
       subset(wcn.ind.eng.mean.ms, Productive == "Nonproductive")$mean, var.equal = TRUE) #Significant difference in performance between productive and nonproductive counters
```

---

#Cross-linguistic comparisons (HK/SLO/US)
Our second set of analyses is aimed at understanding cross-linguistic differences in performance on the Unit Task. To do this, we will analyze all participants, from all language groups, in a single model. We will then construct our models from above, but will add (a) a measure of Working Memory and (b) the interaction of Initial Highest Count and Language group to each model. These models therefore allow us to test whether (a) language; (b) counting ability; or (c) some interaction between the two predict unit performance. We include Working Memory in all cross-linguistic models with the intention of taking into account baseline differences in processing across samples.

Cross-Linguistic Models:
Model 0a (the Null Model): Unit.Performance~ Language*IHC + Within/Outside range + Age + WM
+ (1|subject)
Model 1a: Unit.Performance ~ Productivity + Language*IHC + Within/Outside range + Age + WM + (1|subject)
Model 2a: Unit.Performance ~ Final.Count + Language*IHC + Within/Outside range + Age + WM + (1|subject)
Model 3a: Unit.Performance ~ Highest.Contiguous.Next.Number + Language*IHC + Within/Outside range +
Age + WM + (1|subject)
Make model dfs


We will then compare Model 0a (the Null Model) to each of the models containing measures of productivity (1a, 2a, and 3a) using a likelihood ratio test in testing whether these measures of productivity significantly explain variance in children’s performance. Should effects of Language emerge, we will also test these using a likelihood ratio test comparing models with significant Language effects to one excluding those effects (e.g., Unit.Performance ~ Productivity + IHC + Within/Outside range + Age + WM + (1|subject)). After running the four models above, any predictor that significantly (p &lt;.05) predicted Unit Task Performance will be added into Model 6a, which will be our “Large” model (containing all predictors that significantly predicted Unit Task Performance in the simple models). We will construct model 6a hierarchically. Model comparisons will be performed at each stage by running a likelihood ratio test between reduced and full models, with significant effects retained in the full model (Model 6a). Model selection will be done on the basis of AIC evaluation and significant Chi-square statistic.

##Make model dfs
```{r, include = FALSE}
#currently for Exp 1
sf.df.cross <- all.data %>%
  filter(Task == "SF", 
         Language == "Cantonese" |
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("Cantonese", "Slovenian", "English (US)"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN
  
wcn.df.cross <- all.data %>%
  filter(Task == "NN",
         Language == "Cantonese" |
           Language == "Slovenian" | 
           Language == "English (US)")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)),
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))

##For India
sf.df.cross.india <- all.data %>%
  filter(Task == "SF", 
         Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (US)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN

wcn.df.cross.india <- all.data %>%
  filter(Task == "NN", 
         Language == "English (US)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (US)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN

#followup with Indian English 
wcn.df.cross.india.follow <- all.data %>%
  filter(Task == "NN", 
         Language == "English (India)" |
           Language == "Hindi" | 
           Language == "Gujarati")%>%
  mutate(SID = factor(SID), 
         Productive = factor(Productive), 
         count_range = factor(count_range), 
         highest_contig = as.integer(highest_contig), 
         age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         fhc.c = as.vector(scale(FHC, center = TRUE, scale = TRUE)), 
         ihc.c = as.vector(scale(IHC, center = TRUE, scale = TRUE)), 
         highest_contig.c = as.vector(scale(highest_contig, center = TRUE, scale = TRUE)), 
         starting_num.c = as.vector(scale(as.numeric(as.character(Task_item)), center = TRUE, scale = TRUE)), 
         Language = factor(Language, levels = c("English (India)", "Hindi", "Gujarati"))) %>%
  mutate(wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=TRUE)))%>%
  mutate(Language = factor(Language))%>%
  filter(!is.na(highest_contig.c)) #filter out kids who do not have HCNN
```

---

#Unit Task: Cross linguistic models - HK/SLO/US
##Build the models
```{r}
#base
sf.cross.base <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#productivity
sf.cross.model1 <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#fhc
sf.cross.model2 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#highest contig.
sf.cross.model3 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#highest contig.
sf.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

# ###up to 100
# sf.df.cross.sub.100 <- sf.df.cross %>%
#   filter(as.numeric(as.character(Task_item)) < 100)
# 
# sf.cross.base.sub.100 <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
#                        family = "binomial", data = sf.df.cross.sub.100, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# #productivity
# sf.cross.model1.sub.100 <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
#                        family = "binomial", data = sf.df.cross.sub.100, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# #fhc
# sf.cross.model2sub.100 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
#                        family = "binomial", data = sf.df.cross.sub.100, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# #highest contig.
# sf.cross.model3sub.100 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
#                            (1|SID), 
#                        family = "binomial", data = sf.df.cross.sub.100, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))

# ##exploratory - mean.nn
# sf.cross.model.nn <- glmer(Correct ~ mean.nn + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
#                            (1|SID), 
#                        family = "binomial", data = sf.df.cross, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
```

##Cross-linguistic model comparison
```{r}
mtable.sf.cross <- mtable('Base Model' = sf.cross.base,
            'Model 1: Productivity' = sf.cross.model1,
            'Model 2: FHC' = sf.cross.model2,
            'Model 3: Highest Contig.' = sf.cross.model3, 
            'Exp: Prod. gradient' = sf.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.cross
```

##Model Comparisons
###Base v. productivity - NS, p = .31
```{r}
anova(sf.cross.base, sf.cross.model1, test = 'LRT')
```

###Base v. FHC - NS, p = .08
```{r}
anova(sf.cross.base, sf.cross.model2, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 26.01, p < .0001, AIC = 4361.
```{r}
anova(sf.cross.base, sf.cross.model3, test = 'LRT')
```

###Exploratory - mean nn - Sig
```{r}
# anova(sf.cross.base, sf.cross.model.nn, test = 'LRT')
anova(sf.cross.base, sf.cross.model.gain, test = 'LRT')
```

##Large model - no model comparison needed, only sig. predictor above is HCNN
```{r}
summary(sf.cross.model3)
```

```{r}
#Exploraotory - mean nn v. hcnn
sf.cross.model3 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
# sf.cross.model.plus.nn <- glmer(Correct ~ mean.nn+ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
#                            (1|SID), 
#                        family = "binomial", data = sf.df.cross, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
# #compare
# anova(sf.cross.model3, sf.cross.model.plus.nn, test = 'LRT')


summary(sf.cross.model3)
# summary(sf.cross.model.plus.nn)

```

#Test if effects of language are significant
```{r}
sf.nolang.base <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.nolang.model1 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.nolang.base, sf.nolang.model1, test = 'LRT') 
```

##Follow-up - HCNN significantly interacts with Language group
In the event that, when analyzing each language group separately, we find evidence that a particular counting/productivity measure (Next Number, Final HC, Productivity) improves model fit for one language group by not another, we will conduct a follow-up analysis testing whether productivity classification interacts with language group. We will compare the model containing an interaction to one that excludes the interaction. It is important to note that our critical effect of interest is not necessarily a [Productivity Measure]:[Language Group] interaction, although finding such an interaction may be interpretable (e.g., it may suggest that productivity predicts other measures to a greater degree in some languages vs. others): ProductivityLang: Unit ~ Productivity Measure (Highest NN, FHC, Productivity classification)*Language.Group +
Language*IHC + Within/Outside range + Age + WM (1|subject)
```{r}
#HK/SLO/US
#HCNN
lang.prod.int.hk.noint <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = sf.df.cross, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
lang.prod.int.hk <- glmer(Correct ~ highest_contig.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = sf.df.cross, 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(lang.prod.int.hk.noint, lang.prod.int.hk, test = 'LRT')

summary(lang.prod.int.hk)
summary(lang.prod.int.hk.noint)
```

##Visualizations - HK/SLO/US - Unit, Xling
```{r}
#productivity
hk.cross.prod.model <- summary(sf.cross.model1)
hk.cross.prod.model.df <- data.frame(coef(hk.cross.prod.model)[,0:4])
hk.cross.prod.model.df <- add_rownames(hk.cross.prod.model.df, "Parameter")
hk.cross.prod.model.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageSlovenian", "Slovenian", 
                            ifelse(Parameter == "LanguageEnglish (US)", "English (US)", as.character(Parameter))), 
         p.val = round(anova(sf.cross.base, sf.cross.model1, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(sf.cross.base, sf.cross.model1, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.cross.prod.model$AICtab[1]), 2))

#FHC
hk.cross.fhc.model <- summary(sf.cross.model2)
hk.cross.fhc.model.df <- data.frame(coef(hk.cross.fhc.model)[,0:4])
hk.cross.fhc.model.df <- add_rownames(hk.cross.fhc.model.df, "Parameter")
hk.cross.fhc.model.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageSlovenian", "Slovenian", 
                            ifelse(Parameter == "LanguageEnglish (US)", "English (US)", as.character(Parameter))),
         p.val = round(anova(sf.cross.base, sf.cross.model2, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.cross.base, sf.cross.model2, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.cross.fhc.model$AICtab[1]), 2))

#hcnn
hk.cross.hcnn.model <- summary(sf.cross.model3)
hk.cross.hcnn.model.df <- data.frame(coef(hk.cross.hcnn.model)[,0:4])
hk.cross.hcnn.model.df <- add_rownames(hk.cross.hcnn.model.df, "Parameter")
hk.cross.hcnn.model.df %<>%
  mutate(Model = "Highest Contiguous Next Number")%>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageSlovenian", "Slovenian", 
                            ifelse(Parameter == "LanguageEnglish (US)", "English (US)", as.character(Parameter))), 
         p.val = round(anova(sf.cross.base, sf.cross.model3, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.cross.base, sf.cross.model3, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(hk.cross.hcnn.model$AICtab[1]), 2))

#join togther 
cross.models.unit <- bind_rows(hk.cross.prod.model.df, hk.cross.fhc.model.df, hk.cross.hcnn.model.df) 

cross.models.unit %<>%
  filter(Parameter != "(Intercept)")%>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "ihc.c", "IHC", 
                                          ifelse(Parameter == "wppsi.c", "WPPSI", 
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "LanguageSlovenian:ihc.c", 
                                                        "Slovenian*IHC", 
                                                        ifelse(Parameter == "LanguageEnglish (US):ihc.c",
                                                               "English*IHC", as.character(Parameter)))))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("Slovenian*IHC", "English*IHC", "WPPSI", 
                                                  "Age", "Item magnitude", "Within IHC", "IHC", "Slovenian", 
                                                  "English (US)", "Productivity predictor")))%>%
  mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Highest Contiguous Next Number")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))

data.r <- cross.models.unit %>%
  distinct(Model, AIC, chi.stat, p.val)

quartz()
model.vis.cross <- cross.models.unit %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Model)+
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 10) +
  coord_flip() +
  # scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 1.1, y = .8, size = 2.5,
            data = data.r) + 
  theme(legend.position = "none") +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```


***
#Unit Task: Cross linguistic models - India (English/Hindi/Gujarati)
##Build the models
```{r}
#base
sf.cross.base.india <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#productivity
sf.cross.model1.india <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c +age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#fhc
sf.cross.model2.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#highest contig.
sf.cross.model3.india <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

##exploratory - prod.gain
sf.cross.model.gain.india <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
                           (1|SID), 
                       family = "binomial", data = sf.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

# ##exploratory - mean nn
# sf.cross.model.nn.india <- glmer(Correct ~ mean.nn + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c +
#                            (1|SID), 
#                        family = "binomial", data = sf.df.cross.india, 
#                         control=glmerControl(optimizer="bobyqa",
#                          optCtrl=list(maxfun=2e4)))
```

##Cross-linguistic model comparison
```{r}
mtable.sf.cross.india <- mtable('Base Model' = sf.cross.base.india,
            'Model 1: Productivity' = sf.cross.model1.india,
            'Model 2: FHC' = sf.cross.model2.india,
            'Model 3: Highest Contig.' = sf.cross.model3.india, 
            'Exp: Prod. gradient' = sf.cross.model.gain.india,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.sf.cross.india
```

##Model Comparisons
###Base v. productivity - NS, p = .85
```{r}
anova(sf.cross.base.india, sf.cross.model1.india, test = 'LRT')
```

###Base v. FHC - NS, p = .99
```{r}
anova(sf.cross.base.india, sf.cross.model2.india, test = 'LRT')
```

###Base v. Highest contig. - Sig, Chisq(1) = 13.11, p = .0003, AIC = 3943.9
```{r}
anova(sf.cross.base.india, sf.cross.model3.india, test = 'LRT')
```

#Exploratory - Prod. gradient, NS - p = .46
```{r}
anova(sf.cross.base.india, sf.cross.model.gain.india, test = 'LRT')
# anova(sf.cross.base.india, sf.cross.model.nn.india, test = 'LRT')
```

##Large model - no model comparison needed, only sig. predictor above is HCNN
```{r}
#Summary of final model - hcnn
summary(sf.cross.model3.india)

# #summary of model with hcnn + mean nn
# summary(sf.cross.plus.nn.india)
```

###Visualization
```{r}
#productivity
india.cross.prod.model <- summary(sf.cross.model1.india)
india.cross.prod.model.df <- data.frame(coef(india.cross.prod.model)[,0:4])
india.cross.prod.model.df <- add_rownames(india.cross.prod.model.df, "Parameter")
india.cross.prod.model.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageHindi", "Hindi", 
                            ifelse(Parameter == "LanguageGujarati", "Gujarati", as.character(Parameter))), 
         p.val = round(anova(sf.cross.base.india, sf.cross.model1.india, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(sf.cross.base.india, sf.cross.model1.india, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(india.cross.prod.model$AICtab[1]), 2))

#FHC
india.cross.fhc.model <- summary(sf.cross.model2.india)
india.cross.fhc.model.df <- data.frame(coef(india.cross.fhc.model)[,0:4])
india.cross.fhc.model.df <- add_rownames(india.cross.fhc.model.df, "Parameter")
india.cross.fhc.model.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageHindi", "Hindi", 
                            ifelse(Parameter == "LanguageGujarati", "Gujarati", as.character(Parameter))),
         p.val = round(anova(sf.cross.base.india, sf.cross.model2.india, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.cross.base.india, sf.cross.model2.india, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(india.cross.fhc.model$AICtab[1]), 2))

#hcnn
india.cross.hcnn.model <- summary(sf.cross.model3.india)
india.cross.hcnn.model.df <- data.frame(coef(india.cross.hcnn.model)[,0:4])
india.cross.hcnn.model.df <- add_rownames(india.cross.hcnn.model.df, "Parameter")
india.cross.hcnn.model.df %<>%
  mutate(Model = "Highest Contiguous Next Number")%>%
  mutate(Parameter = ifelse(Parameter == "highest_contig.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageHindi", "Hindi", 
                            ifelse(Parameter == "LanguageGujarati", "Gujarati", as.character(Parameter))), 
         p.val = round(anova(sf.cross.base.india, sf.cross.model3.india, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(sf.cross.base.india, sf.cross.model3.india, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(india.cross.hcnn.model$AICtab[1]), 2))

#join togther 
india.cross.models.unit <- bind_rows(india.cross.prod.model.df, india.cross.fhc.model.df, india.cross.hcnn.model.df) 

india.cross.models.unit %<>%
  filter(Parameter != "(Intercept)")%>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "ihc.c", "IHC", 
                                          ifelse(Parameter == "wppsi.c", "WPPSI", 
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "LanguageHindi:ihc.c", 
                                                        "Hindi*IHC", 
                                                        ifelse(Parameter == "LanguageGujarati:ihc.c",
                                                               "Gujarati*IHC", as.character(Parameter)))))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("Hindi*IHC", "Gujarati*IHC", "WPPSI", 
                                                  "Age", "Item magnitude", "Within IHC", "IHC", "Hindi", 
                                                  "Gujarati", "Productivity predictor")))%>%
  mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count", "Highest Contiguous Next Number")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))

data.r <- india.cross.models.unit %>%
  distinct(Model, AIC, chi.stat, p.val)

quartz()
india.cross.models.unit %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Model)+
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 10) +
  coord_flip() +
  # scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 2, y = .8, size = 2.5,
            data = data.r) + 
  theme(legend.position = "none") +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```

#Test if effects of language are significant
```{r}
sf.nolang.base <- glmer(Correct ~ highest_contig.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross.india, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.nolang.model1 <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = sf.df.cross.india, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.nolang.base, sf.nolang.model1, test = 'LRT') 
```

#Lang*prod interaction followup
```{r}
tmp <- sf.df.cross.india %>%
  mutate(Language = factor(Language, levels = c("Gujarati", "English (US)", "Hindi")))

sf.india.lang.noint <- glmer(Correct ~ highest_contig.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = tmp, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
sf.india.lang.int <- glmer(Correct ~ highest_contig.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = tmp, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(sf.india.lang.noint, sf.india.lang.int, test = 'LRT') 

summary(sf.india.lang.int)
```

#Cross-linguistic comparison of mean performance on unit task 
```{r}
sf.df.cross.india.ms <- all.data %>%
  filter(Task == "SF")%>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = sf.df.cross.india.ms)
summary(lm.india)
```


---

##WCN India
##Build the models
```{r}
#base
wcn.cross.base.india <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1.india <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - Prod. gradient
wcn.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross.india <- mtable('Base Model' = wcn.cross.base.india,
            'Model 1: Productivity' = wcn.cross.model1.india,
            'Model 2: FHC' = wcn.cross.model2.india,
            'Exp: Prod. gradient' = wcn.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.india
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 9.9, p = .002, AIC = 2550
```{r}
anova(wcn.cross.base.india, wcn.cross.model1.india, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 22.71, p < .0001, AIC = 2537.9
```{r}
anova(wcn.cross.base.india, wcn.cross.model2.india, test = 'LRT')
```

###Base v. Prod. gradient - Sig, Chisq(1) = 16.05, p < .0001, AIC = 2544
```{r}
anova(wcn.cross.base.india, wcn.cross.model.gain, test = 'LRT')
```

##Large model
```{r}
#FHC
wcn.cross.plus1.india <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Prod + FHC
wcn.cross.plus2.india <- glmer(Correct ~ Productive + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1.india, wcn.cross.plus2.india, test = 'LRT')

#what about productivity gradient
wcn.cross.plus2.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross.india, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1.india, wcn.cross.plus2.gain, test = 'LRT')


mtable.wcn.cross.large.india <- mtable('FHC alone' = wcn.cross.plus1.india,
            'Productive + FHC.' = wcn.cross.plus2.india,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.large.india

#summary of final model
summary(wcn.cross.plus1.india)

```

##Test if interaction between FHC and language is significant
```{r}
lang.prod.int.india.noint <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                            control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
lang.prod.int.india <- glmer(Correct ~ fhc.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), family = "binomial", data = wcn.df.cross.india, 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(lang.prod.int.india.noint, lang.prod.int.india, test = 'LRT')

summary(lang.prod.int.india)
summary(lang.prod.int.india.noint)
```

#Cross-linguistic comparison of mean performance on nn task 
```{r}
nn.df.cross.india.ms <- all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "English (US)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = nn.df.cross.india.ms)
summary(lm.india)

nn.df.cross.india.ms <- all.data %>%
  filter(Task == "NN")%>%
  filter(Language == "English (India)" |
           Language == "Hindi" |
           Language == "Gujarati")%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale=FALSE)))%>%
  group_by(SID, Language, age.c, wppsi.c)%>%
  summarise(mean_sf = mean(Correct, na.rm = TRUE))

lm.india <- lm(mean_sf ~ Language*age.c + wppsi.c, data = nn.df.cross.india.ms)
summary(lm.india)
```

##Visualizations
```{r}
#productivity
wcn.india.cross.prod.model <- summary(wcn.cross.model1.india)
wcn.india.cross.prod.model.df <- data.frame(coef(wcn.india.cross.prod.model)[,0:4])
wcn.india.cross.prod.model.df <- add_rownames(wcn.india.cross.prod.model.df, "Parameter")
wcn.india.cross.prod.model.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageHindi", "Hindi", 
                            ifelse(Parameter == "LanguageGujarati", "Gujarati", as.character(Parameter))), 
         p.val = round(anova(wcn.cross.base.india, wcn.cross.model1.india, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.cross.base.india, wcn.cross.model1.india, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(wcn.india.cross.prod.model$AICtab[1]), 2))

#FHC
wcn.india.cross.fhc.model <- summary(wcn.cross.model2.india)
wcn.india.cross.fhc.model.df <- data.frame(coef(wcn.india.cross.fhc.model)[,0:4])
wcn.india.cross.fhc.model.df <- add_rownames(wcn.india.cross.fhc.model.df, "Parameter")
wcn.india.cross.fhc.model.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageHindi", "Hindi", 
                            ifelse(Parameter == "LanguageGujarati", "Gujarati", as.character(Parameter))),
         p.val = round(anova(wcn.cross.base.india, wcn.cross.model2.india, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.cross.base.india, wcn.cross.model2.india, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(wcn.india.cross.fhc.model$AICtab[1]), 2))

#join togther 
india.cross.models.wcn <- bind_rows(wcn.india.cross.prod.model.df, wcn.india.cross.fhc.model.df) 

india.cross.models.wcn %<>%
  filter(Parameter != "(Intercept)")%>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "ihc.c", "IHC", 
                                          ifelse(Parameter == "wppsi.c", "WPPSI", 
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "LanguageHindi:ihc.c", 
                                                        "Hindi*IHC", 
                                                        ifelse(Parameter == "LanguageGujarati:ihc.c",
                                                               "Gujarati*IHC", as.character(Parameter)))))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("Hindi*IHC", "Gujarati*IHC", "WPPSI", 
                                                  "Age", "Item magnitude", "Within IHC", "IHC", "Hindi", 
                                                  "Gujarati", "Productivity predictor")))%>%
  mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))

data.r <- india.cross.models.wcn %>%
  distinct(Model, AIC, chi.stat, p.val)

india.cross.models.wcn %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Model)+
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 10) +
  coord_flip() +
  # scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 2, y = 1.5, size = 3,
            data = data.r) + 
  theme(legend.position = "none") +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
---

#WCN - HK/SLO/US Cross linguistic

##Build the models
```{r}
#base
wcn.cross.base <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1 <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - prod. gradient
wcn.cross.model.gain <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross <- mtable('Base Model' = wcn.cross.base,
            'Model 1: Productivity' = wcn.cross.model1,
            'Model 2: FHC' = wcn.cross.model2,
            'Exp: Prod.gradient' = wcn.cross.model.gain,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross
```

##Model comparisons
###Base v. Productivity - Sig, Chisq(1) = 14.67, p = .0001, AIC = 2963.8
```{r}
anova(wcn.cross.base, wcn.cross.model1, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 37.76, p < .0001, AIC = 2940.8
```{r}
anova(wcn.cross.base, wcn.cross.model2, test = 'LRT')
```

###Base v. Prod. gradient 
```{r}
anova(wcn.cross.base, wcn.cross.model.gain, test = 'LRT')
```

##Ranking of productivity predictors - WCN by AIC
1.  FHC - 2940.8
2.  Productivity - 2963.8

##Large model
```{r}
wcn.cross.plus1 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.cross.plus2 <- glmer(Correct ~ Productive + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.plus1, wcn.cross.plus2, test = 'LRT')

#what about productivity gradient? 
wcn.cross.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                           (1|SID), family = "binomial", data = wcn.df.cross, 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.cross.plus1, wcn.cross.plus.gain, test = 'LRT')

mtable.wcn.cross.large <- mtable('FHC alone' = wcn.cross.plus1,
            'Productive + FHC.' = wcn.cross.plus2,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.large

#summary of final model
summary(wcn.cross.plus1)
summary(wcn.cross.plus.gain)

```

```{r}
summary(wcn.cross.plus1)
```

#Test if effects of language are significant
```{r}
wcn.nolang.base <- glmer(Correct ~ fhc.c + ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.nolang.model1 <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.nolang.base, wcn.nolang.model1, test = 'LRT') 
```

#Lang*prod interaction because we found significant effects for FHC in SLO and English, but not Cantonese
```{r}
wcn.prod.int <- glmer(Correct ~ fhc.c*Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
wcn.prod.noint <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                         data = wcn.df.cross, family = "binomial", 
                         control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
anova(wcn.prod.noint, wcn.prod.int, test = 'LRT') 

summary(wcn.prod.int)

all.data %>%
  filter(Task == "NN", 
         Language == "Cantonese" | 
           Language == "English (US)" | 
           Language == "Slovenian")%>%
  group_by(SID, IHC, FHC, Language)%>%
  summarise(mean = mean(Correct, na.rm = TRUE))%>%
  ggplot(aes(x = FHC, y = mean, color = IHC, group = Language)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  facet_grid(~Language)
```

##Visualizations
```{r}
#productivity
wcn.hk.cross.prod.model <- summary(wcn.cross.model1)
wcn.hk.cross.prod.model.df <- data.frame(coef(wcn.hk.cross.prod.model)[,0:4])
wcn.hk.cross.prod.model.df <- add_rownames(wcn.hk.cross.prod.model.df, "Parameter")
wcn.hk.cross.prod.model.df %<>%
  mutate(Model = "Productivity")%>%
  mutate(Parameter = ifelse(Parameter == "ProductiveProductive", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageSlovenian", "Slovenian", 
                            ifelse(Parameter == "LanguageEnglish (US)", "English (US)", as.character(Parameter))), 
         p.val = round(anova(wcn.cross.base, wcn.cross.model1, test = 'LRT')[2,8], 2), 
         chi.stat = round(anova(wcn.cross.base, wcn.cross.model1, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(wcn.hk.cross.prod.model$AICtab[1]), 2))

#FHC
wcn.hk.cross.fhc.model <- summary(wcn.cross.model2)
wcn.hk.cross.fhc.model.df <- data.frame(coef(wcn.hk.cross.fhc.model)[,0:4])
wcn.hk.cross.fhc.model.df <- add_rownames(wcn.hk.cross.fhc.model.df, "Parameter")
wcn.hk.cross.fhc.model.df %<>%
  mutate(Model = "Final Highest Count")%>%
  mutate(Parameter = ifelse(Parameter == "fhc.c", "Productivity predictor", as.character(Parameter)))%>%
  mutate(Parameter = ifelse(Parameter == "LanguageSlovenian", "Slovenian", 
                            ifelse(Parameter == "LanguageEnglish (US)", "English (US)", as.character(Parameter))),
         p.val = round(anova(wcn.cross.base, wcn.cross.model2, test = 'LRT')[2,8], 5), 
         chi.stat = round(anova(wcn.cross.base, wcn.cross.model2, test = 'LRT')[2,6], 2), 
         AIC = round(as.numeric(wcn.hk.cross.fhc.model$AICtab[1]), 2))

#join togther 
cross.models.wcn <- bind_rows(wcn.hk.cross.prod.model.df, wcn.hk.cross.fhc.model.df) 

cross.models.wcn %<>%
  filter(Parameter != "(Intercept)")%>%
  mutate(Parameter = ifelse(Parameter == "starting_num.c", "Item magnitude", 
                            ifelse(Parameter == "count_rangeWithin", "Within IHC", 
                                   ifelse(Parameter == "ihc.c", "IHC", 
                                          ifelse(Parameter == "wppsi.c", "WPPSI", 
                                          ifelse(Parameter == "age.c", "Age", 
                                                 ifelse(Parameter == "LanguageSlovenian:ihc.c", 
                                                        "Slovenian*IHC", 
                                                        ifelse(Parameter == "LanguageEnglish (US):ihc.c",
                                                               "English*IHC", as.character(Parameter)))))))))%>%
  mutate(Parameter = factor(Parameter, levels = c("Slovenian*IHC", "English*IHC", "WPPSI", 
                                                  "Age", "Item magnitude", "Within IHC", "IHC", "Slovenian", 
                                                  "English (US)", "Productivity predictor")))%>%
  mutate(Model = factor(Model, levels = c("Productivity", "Final Highest Count")))%>%
  mutate(p.val = ifelse(p.val < .000001, "<.0001", as.numeric(p.val)))

data.r <- cross.models.wcn %>%
  distinct(Model, AIC, chi.stat, p.val)

cross.models.wcn %>%
ggplot(aes(x = Parameter, y = Estimate)) +
  facet_grid(~Model)+
  geom_pointrange(aes(ymin = Estimate - 1.96 * Std..Error,
                      ymax = Estimate + 1.96 * Std..Error,
                      colour = Parameter)) +
  geom_hline(yintercept = 0, color = "grey", linetype = "dashed") +
  theme_bw(base_size = 10) +
  coord_flip() +
  # scale_colour_brewer(palette = "Dark2", ",", guide = "none") +
  geom_text(aes(label = sprintf("χ² = %-11s \np = %-11s \nAIC = %s", chi.stat, p.val, AIC)),
            x = 1.5, y = 1.5, size = 3,
            data = data.r) + 
  theme(legend.position = "none") +
  xlab("") +
  scale_y_continuous(name = "Coefficient Estimate (log likelihood)")
```
  


---
#Followup with Indian English for NN
##Build the models
```{r}
#base
wcn.cross.base.india.follow <- glmer(Correct ~ Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india.follow, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#Productivity
wcn.cross.model1.india.follow <- glmer(Correct ~ Productive + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + (1|SID), 
                        family = "binomial", data = wcn.df.cross.india.follow, 
                        control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))
#FHC
wcn.cross.model2.india.follow <- glmer(Correct ~ fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

#Exp - prod. gradient
wcn.cross.model.gain.india.follow <- glmer(Correct ~ prod.gradient + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

```

##Cross-linguistic model comparison
```{r}
mtable.wcn.cross.india.follow <- mtable('Base Model' = wcn.cross.base.india.follow,
            'Model 1: Productivity' = wcn.cross.model1.india.follow,
            'Model 2: FHC' = wcn.cross.model2.india.follow,
            'Exp: Prod. gradient' = wcn.cross.model.gain.india.follow,
            summary.stats = c('Nagelkerke R-sq.','Log-likelihood','AIC','N'))
mtable.wcn.cross.india.follow
```

##Model comparisons
###Base v. Productivity - NS
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model1.india.follow, test = 'LRT')
```

###Base v. FHC - Sig, Chisq(1) = 8.58, p = .003, AIC = 2145.4
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model2.india.follow, test = 'LRT')
```

###Base v. Prod. gradient
```{r}
anova(wcn.cross.base.india.follow, wcn.cross.model.gain.india.follow, test = 'LRT')
```

##Large model
```{r}
#compare with prod. gradient
wcn.cross.model.india.follow.plus.gain <- glmer(Correct ~ prod.gradient + fhc.c + Language*ihc.c + count_range + starting_num.c + age.c + wppsi.c + 
                            (1|SID), data = wcn.df.cross.india.follow, family = "binomial", 
                          control=glmerControl(optimizer="bobyqa",
                         optCtrl=list(maxfun=2e4)))

anova(wcn.cross.model2.india.follow, wcn.cross.model.india.follow.plus.gain, test = 'LRT')

#summary of final model
summary(wcn.cross.model2.india.follow)
```

---

#Cross-linguistic comparison for mean performance on NN task (India)
```{r}
nn.ms <- all.data %>%
  filter(Task == "NN", 
         Language == "English (India)" | 
           Language == "Gujarati" | 
           Language == "Hindi")%>%
  group_by(SID)%>%
  mutate(mean_nn = mean(Correct, na.rm = TRUE))

lm1 <- lm(mean_nn ~ Language*Age + sum_wppsi, data = nn.ms)
summary(lm1)
```

---

#Cross-linguistic comparison for mean performance on Unit task (US)
```{r}
sf.ms <- all.data %>%
  filter(Task == "SF", 
         Language == "English (India)" | 
           Language == "Gujarati" | 
           Language == "Hindi")%>%
  group_by(SID)%>%
  mutate(mean_sf = mean(Correct, na.rm = TRUE))

lm2 <- lm(mean_sf ~ Language*Age + sum_wppsi, data = sf.ms)
summary(lm2)
```

---

#Counting distribution
We plan to conduct descriptive analyses to describe the ways in which Initial Highest Count differs across
languages.
```{r}
hc.df %>%
  group_by(Language)%>%
  summarise(mean = mean(IHC, na.rm = TRUE), 
            sd = sd(IHC, na.rm = TRUE), 
            median = median(IHC, na.rm = TRUE))
```

In addition, we plan to test whether children in transparent languages can become productive with less counting experience. To test this, we will consider non-productive counters (those who were labeled as non-Productive). We will then ask whether IHC for these non-productive counters differs across languages. We will only conduct these analyses if we have at least 30 non-productive counters in each language. If count-list transparency allows children to converge on a productive count rule more quickly, then children who learn a system with a transparent-count list should move to the “productive counter” category on the basis of relatively less experience than children who learn a system with an opaque- count list. This predicts that, when considering non-Productive counters, initial highest count should be higher for opaque languages (like English) than for Slovenian, and higher for Slovenian than for Cantonese. The model would like this: 

Model 1: IHC ~ Language + Age + WM, data = NonProductiveCounters

###Model
```{r}
ihc.cross <- all.data %>%
   filter(!is.na(Productive))%>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  distinct(SID, Language, Age, sum_wppsi, Productive, IHC, Dataset)%>%
  filter(Productive == "Nonproductive")%>%
  mutate(Language = factor(Language))%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale = TRUE)))

ihc.cross.hk.slo <- ihc.cross %>%
  filter(Dataset == "HK/SLO/US")

ihc.cross.model.hk.slo <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.hk.slo)
summary(ihc.cross.model.hk.slo)

ihc.cross.ind <- ihc.cross %>%
  filter(Language == "English (US)"|
           Language == "Hindi" |
           Language == "Gujarati")

ihc.cross.model.ind <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.ind)
summary(ihc.cross.model.ind)

ihc.cross.ind <- ihc.cross %>%
  filter(Language == "English (India)"|
           Language == "Hindi" |
           Language == "Gujarati")

ihc.cross.model.ind <- lm(IHC ~ Language + age.c + wppsi.c, data = ihc.cross.ind)
summary(ihc.cross.model.ind)
```

In addition, we will test whether count-list transparency allows children to acquire some degree of productivity, even before they are labeled productive counters based on their overall counting performance. To test this, we will predict Highest Contiguous Next Number from Language. If transparent languages allow children to generate a productive counting rule, speakers of these transparent languages may perform better on the Next Number task than speakers of non- transparent languages, even when only considering non-productive counters. Model 2: Highest.Contiguous.NextNumber ~ Language + Age + WM + (1|subject), data = NonProductiveCounters

###Model: No effect of Language here
```{r}
wcn.model <- all.data %>%
  mutate(Dataset = ifelse(Language == "English (US)" | Language == "Cantonese" |
                            Language == "Slovenian", "HK/SLO/US", "India"))%>%
  distinct(SID, Language, Age, sum_wppsi, Productive, highest_contig, Dataset)%>%
  filter(Productive == "Nonproductive")%>%
  mutate(Language = factor(Language))%>%
  mutate(age.c = as.vector(scale(Age, center = TRUE, scale=FALSE)), 
         wppsi.c = as.vector(scale(sum_wppsi, center = TRUE, scale = TRUE)))

wcn.model.hk.slo <- wcn.model %>%
  filter(Dataset == "HK/SLO/US")

highest_contig.model.hk.slo <- lm(highest_contig ~ Language + age.c + wppsi.c, data = wcn.model.hk.slo)
summary(highest_contig.model.hk.slo)

wcn.model.ind <- wcn.model %>%
  filter(Dataset == "India")

highest_contig.model.ind <- lm(highest_contig ~ Language + age.c + wppsi.c, data = wcn.model.ind)
summary(highest_contig.model.ind)

```
---

#Exploratory - predicting Unit Task from clustering
```{r}
#test with US English
tmp.English <- all.data %>%
  filter(Task == "SF", 
         Language == "English (US)")%>%
  distinct(SID, IHC, FHC)%>%
  group_by(SID)%>%
  summarise(n = n())%>%
  filter(n != 1)
```

#Productivity*Count range for Unit
##Within language
```{r}
hk.prod.nn.range <- glmer(Correct ~ Productive*count_range + ihc.c + starting_num.c + age.c + (1|SID), 
                          family = "binomial", data = wcn.hk.within)
summary(hk.prod.nn.range)

slo.prod.nn.range <- glmer(Correct ~ Productive*count_range + ihc.c + starting_num.c + age.c + (1|SID), 
                          family = "binomial", data = wcn.slo.within)
summary(slo.prod.nn.range)

us.prod.nn.range <- glmer(Correct ~ Productive*count_range + ihc.c + starting_num.c+ age.c + (1|SID), 
                          family = "binomial", data = wcn.us.within)
summary(us.prod.nn.range)

hindi.prod.nn.range <- glmer(Correct ~ Productive*count_range + ihc.c + starting_num.c + age.c + (1|SID), 
                          family = "binomial", data = wcn.hindi.within)
summary(hindi.prod.nn.range)

gujarati.prod.nn.range <- glmer(Correct ~ Productive*count_range + ihc.c + starting_num.c + age.c + (1|SID), 
                          family = "binomial", data = wcn.gujarati.within)
summary(gujarati.prod.nn.range)
```



TO-do for RMS: 
- Follow up analysis for productivity:lang interactions: In the event that, when analyzing each language group separately, we find evidence that a particular counting/productivity measure (Next Number, Final HC, Productivity) improves model fit for one language group by not another, we will conduct a follow-up analysis testing whether productivity classification interacts with language group. We will compare the model containing an interaction to one that excludes the interaction. It is important to note that our critical effect of interest is not necessarily a [Productivity Measure]:[Language Group] interaction, although finding such an interaction may be interpretable (e.g., it may suggest that productivity predicts other measures to a greater degree in some languages vs. others): ProductivityLang: Unit ~ Productivity Measure (Highest NN, FHC, Productivity classification)*Language.Group +
Language*IHC + Within/Outside range + Age + WM (1|subject)
- Exploratory analyses
- Include vs. exclude memory check failure SF trials
- Highest contiguous Successor vs. Highest contiguous NN
- Teacher survey data...
- Comparison of numbers on NN and SF
- Comparison of above and below 100 for NN and SF
- 